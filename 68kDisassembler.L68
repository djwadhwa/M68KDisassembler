00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 11:54:58 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 49 6E 70 75 74 73 ...     23  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
000001CC= 57 6F 75 6C 64 20 ...     24  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
000001EF= 45 78 69 74 69 6E ...     25  ExitMsg             dc.b    'Exiting Program',0
000001FF                            26  
000001FF                            27  START_ADDR_BUFFER  DS.B    256
000002FF                            28  END_ADDR_BUFFER    DS.B    256
000003FF                            29  
000003FF                            30  *size
000003FF= 2E 4C 20 00               31  long                DC.B    '.L ',0
00000403= 2E 57 20 00               32  word                DC.B    '.W ',0
00000407= 2E 42 20 00               33  byte                DC.B    '.B ',0
0000040B                            34  
0000040B                            35  *instructions
0000040B= 4E 4F 50 00               36  nop_ins             DC.B    'NOP',0
0000040F= 52 54 53 00               37  rts_ins             DC.B    'RTS',0
00000413= 4D 4F 56 45 00            38  move_ins            DC.B    'MOVE',0
00000418= 4D 4F 56 45 51 20 00      39  moveq_ins           DC.B    'MOVEQ ',0
0000041F= 4D 4F 56 45 4D 00         40  movem_ins           DC.B    'MOVEM',0
00000425= 4D 4F 56 45 41 00         41  movea_ins           DC.B    'MOVEA',0
0000042B= 41 44 44 00               42  add_ins             DC.B    'ADD',0
0000042F= 41 44 44 41 00            43  adda_ins            DC.B    'ADDA',0
00000434= 41 44 44 51 00            44  addq_ins            DC.B    'ADDQ',0
00000439= 4F 52 00                  45  or_ins              DC.B    'OR',0
0000043C= 41 4E 44 00               46  and_ins             DC.B    'AND',0
00000440= 53 55 42 00               47  sub_ins             DC.B    'SUB',0
00000444= 4C 53 00                  48  ls_ins              DC.B    'LS',0
00000447= 41 53 00                  49  as_ins              DC.B    'AS',0
0000044A= 52 4F 00                  50  ro_ins              DC.B    'RO',0
0000044D= 4E 4F 54 00               51  not_ins             DC.B    'NOT',0
00000451= 4A 53 52 20 00            52  jsr_ins             DC.B    'JSR ',0
00000456= 4C 45 41 20 00            53  lea_ins             DC.B    'LEA ',0
0000045B= 41 44 44 51 00            54  andq_ins            DC.B    'ADDQ',0
00000460= 42 47 54 00               55  bgt_ins             DC.B    'BGT',0
00000464= 42 4C 45 00               56  ble_ins             DC.B    'BLE',0
00000468= 42 45 51 00               57  beq_ins             DC.B    'BEQ',0
0000046C= 42 52 41 00               58  bra_ins             DC.B    'BRA',0
00000470                            59  
00000470                            60  *direction
00000470= 52 00                     61  right               DC.B    'R',0
00000472= 4C 00                     62  left                DC.B    'L',0
00000474                            63  
00000474                            64  *EA
00000474= 44 00                     65  D_reg               DC.B    'D',0
00000476= 41 00                     66  A_reg               DC.B    'A',0
00000478= 28 41 00                  67  open_paran          DC.B    '(A',0
0000047B= 29 00                     68  close_paran         DC.B    ')',0
0000047D= 29 2B 00                  69  post_inc            DC.B    ')+',0
00000480= 2D 28 41 00               70  pre_dec             DC.B    '-(A',0
00000484                            71  
00000484                            72  *extra
00000484= 20 00                     73  space               DC.B    ' ',0
00000486= 2C 20 00                  74  comma               DC.B    ', ',0
00000489= 23 00                     75  pound               DC.B    '#',0
0000048B= 2D 00                     76  dash                DC.B    '-',0
0000048D= 2F 00                     77  slash               DC.B    '/',0
0000048F  =00000009                 78  tab                 EQU     $9
0000048F= 0D 0A 00                  79  return              DC.B    CR,LF,0
00000492= 44 41 54 41 20 24 00      80  data                DC.B    'DATA $',0
00000499= 24 00                     81  dollar              DC.B    '$',0
00001000                            82      ORG    $1000    *Start at address $1000
00001000                            83  START:                  ; first instruction of program
00001000                            84  
00001000                            85  *---------- Test value, will remove in final build ----------*
00001000                            86  
00001000                            87  *   Move.W #$4E75,$00009234 *RTS
00001000                            88  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            89  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            90  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            91  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            92  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            93  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            94  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            95  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            96  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            97  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            98  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                            99  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           100  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           101  *   MOVE.W #$000C,$00009250
00001000                           102  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           103  *   MOVE.L #$12345678,$00009254
00001000                           104  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           105  *   MOVE.W #$0012,$0000925A
00001000                           106  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           107  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           108  *   MOVE.L #$00009208,$00009260
00001000                           109  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           110  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           111  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           112  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           113  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           114  *    MOVE.W #$FE7A,$0000926E
00001000                           115  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           116  *    MOVE.W #$FE60,$00009272
00001000                           117  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           118  *    MOVE.L #$00009208,$000009276
00001000                           119  *    MOVE.W #$48A1,$0000927A
00001000                           120  *    MOVE.W #$011F,$0000927C
00001000                           121  *    MOVE.W #$4C91,$0000927E
00001000                           122  *    MOVE.W #$FE00,$00009280
00001000                           123  *   MOVE.W #$C2BC, $00009000
00001000                           124  *   MOVE.L #$12345678, $00009002
00001000                           125  *   MOVE.W #$82F9 , $00009000
00001000                           126  *   MOVE.L #$12345678, $00009002 
00001000                           127  *   MOVE.W #$9441, $00009006
00001000                           128  *   MOVE.L #$12345678, $00009002
00001000                           129  *---------- END Test ----------*
00001000                           130  
00001000                           131  
00001000                           132  
00001000                           133  *---------- Beginning Messages ----------*
00001000                           134      
00001000  103C 000E                135      move.b      #14,D0
00001004  43F8 0000                136      lea         StartingMsg,A1 
00001008  4E4F                     137      trap        #15
0000100A                           138      
0000100A  103C 000E                139      move.b      #14,D0
0000100E  43F8 001F                140      lea         Creators,A1
00001012  4E4F                     141      trap        #15
00001014                           142      
00001014  4EB9 00001066            143      jsr         MENU
0000101A                           144      
0000101A                           145      
0000101A                           146  * ---------- END OF PROGRAM -------------*
0000101A                           147  
0000101A  103C 000E                148      move.b      #14,D0
0000101E  43F8 01EF                149      lea         ExitMsg,A1 
00001022  4E4F                     150      trap        #15
00001024                           151      
00001024  103C 0009                152      move.b      #9,D0
00001028  4E4F                     153      trap        #15
0000102A                           154  * ---------------------------------------*
0000102A                           155      
0000102A                           156  *-- End of Opening and Ending Messages --*
0000102A                           157  
0000102A                           158  *--------- Start of I/O Section ---------*
0000102A                           159  
0000102A                           160  Clear_Registers:
0000102A  4280                     161      clr.l     D0
0000102C  4281                     162      clr.l     D1
0000102E  4282                     163      clr.l     D2
00001030  4283                     164      clr.l     D3
00001032  4284                     165      clr.l     D4
00001034  4285                     166      clr.l     D5
00001036  4286                     167      clr.l     D6
00001038  4287                     168      clr.l     D7
0000103A                           169      
0000103A  207C 00000000            170      movea.l   #0,A0
00001040  227C 00000000            171      movea.l   #0,A1
00001046  247C 00000000            172      movea.l   #0,A2
0000104C  267C 00000000            173      movea.l   #0,A3
00001052  287C 00000000            174      movea.l   #0,A4
00001058  2A7C 00000000            175      movea.l   #0,A5
0000105E  2C7C 00000000            176      movea.l   #0,A6
00001064  4E75                     177      rts
00001066                           178  
00001066                           179  MENU:
00001066  4EB8 102A                180      jsr         Clear_Registers
0000106A  4EB9 00001084            181      jsr         GetStartAddress
00001070  4EB9 0000109E            182      jsr         GetEndAddress
00001076  4EB9 000010B8            183      jsr         CheckAddress
0000107C                           184      
0000107C  4EB9 000010BC            185      jsr         MemSearch
00001082  4E75                     186      rts
00001084                           187      
00001084                           188  GetStartAddress:
00001084                           189      
00001084  103C 000E                190      move.b      #14, D0         *Display input message
00001088  43F8 004E                191      lea         InputMsg1,A1
0000108C  4E4F                     192      trap        #15
0000108E                           193      
0000108E  103C 0002                194      move.b      #2,D0
00001092  4E4F                     195      trap        #15
00001094                           196          
00001094  4EB9 00001A70            197      jsr ASCIItoHex              *conversion to Hex
0000109A                           198      * Address Located in D6
0000109A  2846                     199      movea.l     D6,A4           *move into address register 4
0000109C  4E75                     200      rts
0000109E                           201      
0000109E                           202      
0000109E                           203  GetEndAddress:
0000109E  103C 000E                204      move.b      #14,D0          *Display input message
000010A2  43F8 008F                205      lea         InputMsg2,A1
000010A6  4E4F                     206      trap        #15
000010A8                           207      
000010A8  103C 0002                208      move.b      #2,D0
000010AC  4E4F                     209      trap        #15
000010AE                           210      
000010AE  4EB9 00001A70            211      jsr         ASCIItoHex      *conversion to hex
000010B4                           212      * Address Located in D6 (overwrite)
000010B4  2A46                     213      movea.l     D6,A5           *move into address register 5
000010B6  4E75                     214      rts
000010B8                           215      
000010B8                           216  CheckAddress:
000010B8  BBCC                     217      cmp.l       A4,A5
000010BA  67AA                     218      beq         Menu
000010BC                           219  
000010BC                           220      
000010BC                           221  MemSearch:
000010BC  4EB9 000010C4            222      jsr MemSearchLoop
000010C2  4E75                     223      rts
000010C4                           224      
000010C4                           225  MemSearchLoop:
000010C4                           226      
000010C4                           227      * Check if we reached the end address
000010C4  BBCC                     228      cmp.l       A4,A5
000010C6  6700 002A                229      beq         MemSearch_Done
000010CA                           230      
000010CA                           231      * Get data from memory
000010CA  4241                     232      CLR D1
000010CC  3414                     233      move.w     (A4),D2
000010CE  3602                     234      move.w      D2, D3  mutable copy in D3
000010D0                           235      * OPCODE Word Located in D2, mutable copy in D3
000010D0  220C                     236      MOVE.L      A4, D1
000010D2  143C 0010                237      MOVE.B      #16, D2
000010D6  103C 000F                238      MOVE.B      #15, D0     print address of instruction
000010DA  4E4F                     239      TRAP        #15
000010DC  3403                     240      MOVE.W      D3,D2
000010DE  43F8 0484                241      LEA         space,A1
000010E2  4EB9 000011CA            242      JSR         print
000010E8  4EB9 00001114            243      jsr         OPCODE_DECODE    
000010EE                           244      
000010EE  544C                     245      adda.w      #2,A4
000010F0  60D2                     246      bra         MemSearchLoop
000010F2                           247      
000010F2                           248      
000010F2                           249  MemSearch_Done:
000010F2  103C 000E                250      move.b      #14,D0
000010F6  43F8 0173                251      lea         EndOfMemLoop,A1 
000010FA  4E4F                     252      trap        #15
000010FC  4E75                     253      rts
000010FE                           254      
000010FE                           255  TerminateOrCont:
000010FE                           256      * Used to check if user would like to terminate the program or continue to disassemble more data
000010FE  103C 000E                257      move.b      #14,D0
00001102  43F8 01CC                258      lea         ContinueOrNotMsg,A1 
00001106  4E4F                     259      trap        #15
00001108                           260      
00001108  4E75                     261      rts
0000110A                           262  
0000110A                           263  ScreenFlush:
0000110A  B63C 001E                264      cmp.b       #30,D3
0000110E  6700 0004                265      beq         FlushScreen
00001112  4E75                     266      rts 
00001114                           267  
00001114                           268  FlushScreen:
00001114                           269  
00001114                           270  * -------- Start of Opcode Section -------*    
00001114                           271  
00001114                           272  OPCODE_DECODE:
00001114                           273      * Begin OPCODE Decoding here
00001114                           274      * Check first four bits and begin
00001114                           275      * if-branch breakdown
00001114  4284                     276      CLR.L D4
00001116  4285                     277      CLR.L D5
00001118  4286                     278      CLR.L D6
0000111A  4287                     279      CLR.L D7
0000111C                           280      
0000111C  B47C 4E71                281      CMP.W #$4E71, D2        
00001120  6700 00C4                282      BEQ print_nop           *check if value is NOP
00001124                           283      
00001124  B47C 4E75                284      CMP.W #$4E75, D2        
00001128  6700 00C6                285      BEQ print_rts           *check if value is RTS
0000112C                           286      
0000112C                           287      * Mask out only the first 4 bits
0000112C  C67C F000                288      AND.W #$F000,D3
00001130                           289      
00001130  B67C 9000                290      CMP.W #$9000,D3
00001134  6700 01FA                291      BEQ print_sub_and_or    *check if value is SUB
00001138                           292      
00001138  B67C 6000                293      CMP.W #$6000,D3
0000113C  6700 0408                294      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
00001140                           295      
00001140  B67C 8000                296      CMP.W #$8000, D3
00001144  6700 01EA                297      BEQ print_sub_and_or    *check if value is OR
00001148                           298  
00001148  B67C C000                299      CMP.W #$C000,D3
0000114C  6700 01E2                300      BEQ print_sub_and_or    *check if value is AND
00001150                           301      
00001150  B67C D000                302      CMP.W #$D000,D3
00001154  6700 0132                303      BEQ print_add_adda      *check if value is ADD or ADDA
00001158                           304      
00001158  B67C E000                305      CMP.W #$E000,D3
0000115C  6700 0296                306      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001160                           307      
00001160  B67C 7000                308      CMP.W #$7000,D3
00001164  6700 0094                309      BEQ print_moveq     *check if value is MOVEQ
00001168                           310      
00001168  B47C 1000                311      CMP.W #$1000,D2
0000116C  6D00 003E                312      BLT invalid
00001170  B47C 4000                313      CMP.W #$4000,D2
00001174  6D00 00C8                314      BLT print_move_movea    *check if value is MOVE or MOVEA
00001178                           315      
00001178                           316      * Mask out only the first 8 bits
00001178  3602                     317      MOVE.W D2, D3
0000117A  C67C FF00                318      AND.W #$FF00,D3
0000117E                           319      
0000117E  B67C 4600                320      CMP.W #$4600,D3
00001182  6700 0324                321      BEQ print_not           *check if value is NOT
00001186                           322      
00001186  B67C 4E00                323      CMP.W #$4E00,D3
0000118A  6700 0346                324      BEQ print_jsr           *check if value is JSR
0000118E                           325      
0000118E                           326      * Mask out only the first 4 bits and the 8th bit
0000118E  3602                     327      MOVE.W D2,D3
00001190  C67C F100                328      AND.W #$F100, D3
00001194                           329      
00001194  B67C 4000                330      CMP.W #$4000, D3
00001198  6700 045E                331      BEQ print_movem         *check if value is MOVEM
0000119C                           332      
0000119C  B67C 4100                333      CMP.W #$4100, D3
000011A0  6700 0346                334      BEQ print_lea           *check if value is LEA
000011A4                           335      
000011A4  B67C 5000                336      CMP.W #$5000,D3
000011A8  6700 0362                337      BEQ print_addq          *check if value is ANDQ     
000011AC                           338      
000011AC                           339      
000011AC                           340  invalid 
000011AC  43F8 0492                341      LEA data, A1
000011B0  4EB9 000011CA            342      JSR print
000011B6  2202                     343      MOVE.L D2, D1
000011B8  143C 0010                344      MOVE.B #16, D2
000011BC  103C 000F                345      MOVE.B  #15, D0     
000011C0  4E4F                     346      TRAP #15
000011C2  4EB9 000011DC            347      JSR enter
000011C8  4E75                     348  out rts
000011CA                           349  
000011CA                           350      
000011CA                           351  * -------- End of Opcode Section --------*   
000011CA                           352  
000011CA                           353  * --------- Print Instructions ----------*
000011CA                           354  
000011CA                           355  
000011CA                           356  print:
000011CA  4240                     357      CLR D0 
000011CC  103C 000E                358      MOVE.B #14,D0
000011D0  4E4F                     359      TRAP #15
000011D2  4E75                     360      RTS
000011D4                           361  
000011D4                           362  println:
000011D4  103C 000D                363      MOVE.B #13, D0
000011D8  4E4F                     364      TRAP #15
000011DA  4E75                     365      RTS
000011DC                           366      
000011DC                           367  enter: 
000011DC  43F8 048F                368      LEA return, A1
000011E0  4EB8 11CA                369      JSR print
000011E4  4E75                     370      RTS
000011E6                           371      
000011E6                           372  print_nop
000011E6  43F8 040B                373      LEA nop_ins, A1
000011EA  4EB8 11D4                374      JSR println
000011EE  60D8                     375      BRA out
000011F0                           376  
000011F0                           377  print_rts
000011F0  43F8 040F                378      LEA rts_ins, A1
000011F4  4EB8 11D4                379      JSR println
000011F8  60CE                     380      BRA out
000011FA                           381      
000011FA                           382  print_moveq
000011FA  43F8 0418                383      lea moveq_ins, A1   *print MOVEQ
000011FE  4EB8 11CA                384      jsr print
00001202  3602                     385      move.w  D2,D3
00001204  C67C 00FF                386      and.w   #$00FF,D3   * Figure out the immediate address value
00001208  43F8 0489                387      lea pound,A1        *print '#'
0000120C  4EB8 11CA                388      jsr print
00001210  43F8 0499                389      LEA dollar, A1
00001214  4EB8 11CA                390      JSR print
00001218  3203                     391      move.w  D3,D1
0000121A  3602                     392      MOVE.W D2,D3
0000121C  343C 0010                393      MOVE.W #16, D2
00001220  103C 000F                394      move.b  #15,D0
00001224  4E4F                     395      trap    #15         *print immediate address value
00001226  43F8 0486                396      lea comma,A1        *print comma
0000122A  4EB8 11CA                397      jsr print
0000122E  3403                     398      MOVE.W D3, D2
00001230  3A02                     399      MOVE.W D2, D5
00001232  4EB9 0000189E            400      JSR data_reg_sr     *figure out data address
00001238  4EB8 11DC                401      jsr enter           *print out enter
0000123C  608A                     402      bra out
0000123E                           403      
0000123E                           404  print_move_movea
0000123E  3602                     405      MOVE.W D2, D3       
00001240  C67C 01C0                406      AND.W #$01C0, D3
00001244  B67C 0040                407      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001248  6700 000E                408      BEQ move_a
0000124C  43F8 0413                409      LEA move_ins, A1 *print Instruction 
00001250  4EB8 11CA                410      JSR print
00001254  6000 000A                411      BRA m_size
00001258                           412  move_a          *if instruction is MOVEA
00001258  43F8 0425                413      LEA movea_ins, A1
0000125C  4EB8 11CA                414      JSR print
00001260                           415  m_size              *determine instruction size
00001260  4EB9 000016B8            416      JSR move_size
00001266  4EB9 0000171A            417      JSR addr        *determine the source address
0000126C  43F8 0486                418      LEA comma, A1   *print comma
00001270  4EB8 11CA                419      JSR print
00001274  4207                     420      CLR.B D7
00001276  1E3C 0001                421      MOVE.B #1, D7   *determine destination address
0000127A  4EB9 0000171A            422      JSR addr
00001280  4EB8 11DC                423      JSR enter       *print enter
00001284  6000 FF42                424      BRA out
00001288                           425      
00001288                           426  print_add_adda
00001288  3602                     427      MOVE.W D2, D3   
0000128A  C63C 00C0                428      AND.B #$C0, D3
0000128E  B63C 00C0                429      CMP.B #$C0, D3      *determine if ADD or ADDA
00001292  6700 0052                430      BEQ add_a
00001296                           431      *if just ADD then print instruction
00001296  43F8 042B                432      LEA add_ins, A1
0000129A  4EB8 11CA                433      JSR print
0000129E                           434      *print instruction size for ADD
0000129E  4EB9 000016FE            435      JSR size
000012A4                           436      *determine direction of ADD, Dn -> EA or EA -> Dn
000012A4  3602                     437      MOVE.W D2,D3
000012A6  C67C 0100                438      AND.W #$0100, D3
000012AA  B67C 0100                439      CMP.W #$0100, D3
000012AE  6700 001C                440      BEQ ea_dest_add 
000012B2  4EB9 0000171A            441      JSR addr            *if Direction bit is 0
000012B8  43F8 0486                442      LEA comma, A1
000012BC  4EB8 11CA                443      JSR print
000012C0  3A02                     444      MOVE.W D2,D5
000012C2  4EB9 0000189E            445      JSR data_reg_sr
000012C8  6000 005E                446      BRA end_add
000012CC                           447  ea_dest_add             *if Direction bit is 1
000012CC  3A02                     448      MOVE.W D2,D5
000012CE  4EB9 0000189E            449      JSR data_reg_sr
000012D4  43F8 0486                450      LEA comma, A1
000012D8  4EB8 11CA                451      JSR print
000012DC  4EB9 0000171A            452      JSR addr
000012E2  6000 0044                453      BRA end_add
000012E6                           454  add_a                   *if instruction is ADDA
000012E6  43F8 042F                455      LEA adda_ins, A1
000012EA  4EB8 11CA                456      JSR print
000012EE                           457      *print instruction size for ADDA (either W or L)
000012EE  3602                     458      MOVE.W D2,D3
000012F0  C67C 0100                459      AND.W #$0100, D3
000012F4  B67C 0100                460      CMP.W #$0100, D3
000012F8  6700 000E                461      BEQ adda_size
000012FC  43F8 0403                462      LEA word, A1
00001300  4EB8 11CA                463      JSR print
00001304  6000 000E                464      BRA next_add
00001308                           465  adda_size
00001308  43F8 03FF                466      LEA long,A1
0000130C  4EB8 11CA                467      JSR print
00001310  183C 0080                468      MOVE.B #$80, D4
00001314                           469  next_add                *print effective address for ADDA
00001314  4EB9 0000171A            470      JSR addr            
0000131A  43F8 0486                471      LEA comma, A1
0000131E  4EB8 11CA                472      JSR print
00001322  4EB9 000018B6            473      JSR add_reg_sr
00001328                           474  end_add                 *complete instruction printing by printing enter
00001328  4EB8 11DC                475      JSR enter
0000132C  6000 FE9A                476      BRA out
00001330                           477  
00001330                           478  print_sub_and_or
00001330                           479      *determine if instruction is SUB, AND, or OR.
00001330  3602                     480      MOVE.W D2, D3
00001332  C67C F0C0                481      AND.W #$F0C0, D3
00001336  B67C C0C0                482      CMP.W #$C0C0, D3
0000133A  6700 0090                483      BEQ mul_div
0000133E  B67C 80C0                484      CMP.W #$80C0, D3
00001342  6700 0088                485      BEQ mul_div
00001346  C67C F000                486      AND.W #$F000,D3
0000134A  B67C 8000                487      CMP.W #$8000, D3
0000134E  6700 0028                488      BEQ print_or
00001352  B67C 9000                489      CMP.W #$9000, D3
00001356  6700 000A                490      BEQ print_sub
0000135A  43F8 043C                491      LEA and_ins, A1
0000135E  6000 001C                492      BRA print_instruction
00001362                           493  print_sub
00001362  3602                     494      MOVE.W D2, D3
00001364  C67C 00C0                495      AND.W #$00C0, D3
00001368  B63C 00C0                496      CMP.B #$C0, D3
0000136C  6700 FE3E                497      BEQ invalid
00001370  43F8 0440                498      LEA sub_ins, A1
00001374  6000 0006                499      BRA print_instruction
00001378                           500  print_or
00001378  43F8 0439                501      LEA or_ins, A1
0000137C                           502  print_instruction       *print correct instruction
0000137C  4EB8 11CA                503      JSR print
00001380  4EB9 000016FE            504      JSR size            *print instruction size
00001386  3602                     505      MOVE.W D2,D3
00001388                           506  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001388  C67C 0100                507      AND.W #$0100, D3
0000138C  B67C 0100                508      CMP.W #$0100, D3
00001390  6700 001C                509      BEQ ea_dest_sub_and_or
00001394  4EB9 0000171A            510      JSR addr            *if Direction bit is 0
0000139A  43F8 0486                511      LEA comma, A1
0000139E  4EB8 11CA                512      JSR print
000013A2  3A02                     513      MOVE.W D2,D5
000013A4  4EB9 0000189E            514      JSR data_reg_sr
000013AA  6000 FF7C                515      BRA end_add
000013AE                           516  ea_dest_sub_and_or      *if Direction bit is 1
000013AE  3A02                     517      MOVE.W D2,D5
000013B0  4EB9 0000189E            518      JSR data_reg_sr
000013B6  43F8 0486                519      LEA comma, A1
000013BA  4EB8 11CA                520      JSR print
000013BE  4EB9 0000171A            521      JSR addr
000013C4                           522      *complete instruction printing by printing enter
000013C4  4EB8 11DC                523      JSR enter
000013C8  6000 FDFE                524      BRA out
000013CC                           525      
000013CC                           526  mul_div             *deal with MULU and DIVU cases
000013CC  4283                     527      CLR.L D3
000013CE  3602                     528      MOVE.W D2,D3
000013D0  C67C 00FF                529      AND.W #$00FF, D3
000013D4  B6BC 000000F8            530      CMP.L #$00F8, D3
000013DA  6D00 FDD0                531      BLT invalid
000013DE  B6BC 000000F9            532      CMP.L #$00F9, D3
000013E4  6700 0008                533      BEQ mul_div_long
000013E8  544C                     534      ADDA.W #2,A4
000013EA  6000 FDC0                535      BRA invalid
000013EE                           536  mul_div_long
000013EE  584C                     537      ADDA.W #4,A4
000013F0  6000 FDBA                538      BRA invalid
000013F4                           539      
000013F4                           540  print_ls_as_ro
000013F4                           541      *figure out if shift or rotation are memory or register based               
000013F4  3602                     542      MOVE.W D2, D3
000013F6  C63C 00C0                543      AND.B #$C0, D3
000013FA  B63C 00C0                544      CMP.B #$C0, D3
000013FE  6700 0072                545      BEQ ls_as_ro_mem
00001402  3602                     546      MOVE.W D2, D3
00001404  E60B                     547      LSR.B #3, D3
00001406                           548      *print correct instruction type (logical shift, arithmetic shift, or rotation)
00001406  4EB9 00001686            549      JSR print_correct_shift_rotation
0000140C  4EB9 00001664            550      JSR print_direction     *print direction
00001412  4EB9 000016FE            551      JSR size                *print size
00001418  3602                     552      MOVE.W D2, D3
0000141A  C63C 0020                553      AND.B #$20,D3
0000141E  B63C 0020                554      CMP.B #$20, D3
00001422                           555      *determine if instruction is using immediate address or register
00001422  6700 0030                556      BEQ ls_as_ro_reg     
00001426  43F8 0489                557      LEA pound, A1        *if immediate address print '#'
0000142A  4EB8 11CA                558      JSR print
0000142E                           559      *print immediate address rotation value
0000142E  3C02                     560      MOVE.W D2,D6
00001430  EF5E                     561      ROL.W #7,D6
00001432  CC7C 0007                562      AND.W #$0007, D6
00001436  43F8 0499                563      LEA dollar, A1
0000143A  4EB8 11CA                564      JSR print
0000143E  4281                     565      CLR.L D1
00001440  3206                     566      MOVE.W D6, D1
00001442  3602                     567      MOVE.W D2, D3
00001444  143C 0010                568      MOVE.B #16, D2
00001448  103C 000F                569      MOVE.B #15, D0
0000144C  4E4F                     570      TRAP #15
0000144E  3403                     571      MOVE.W D3,D2
00001450  6000 000A                572      BRA continue_instruction_ls_as_ro
00001454                           573  ls_as_ro_reg            *if instruction is using register to shift values in another register
00001454  3A02                     574      MOVE.W D2,D5
00001456  4EB9 0000189E            575      JSR data_reg_sr
0000145C                           576  continue_instruction_ls_as_ro *complete instrcuction
0000145C  43F8 0486                577      LEA comma, A1       *print comma
00001460  4EB8 11CA                578      JSR print
00001464  3A02                     579      MOVE.W D2,D5
00001466  EE5D                     580      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001468  4EB9 0000189E            581      JSR data_reg_sr     *determine destination data register to perform instruction on
0000146E  6000 0030                582      BRA next_ls_as_ro   *finish printing instruction
00001472                           583  ls_as_ro_mem            *check if immediate address is being shifted or rotated
00001472  3602                     584      MOVE.W D2, D3
00001474  C63C 003F                585      AND.B #$3F, D3
00001478  B63C 003C                586      CMP.B #$3C, D3
0000147C  6700 FD2E                587      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001480                           588      *if not immediate adress print normally 
00001480  3602                     589      MOVE.W D2, D3
00001482  EF5B                     590      ROL.W #7, D3    
00001484  4EB9 00001686            591      JSR print_correct_shift_rotation
0000148A  3602                     592      MOVE.W D2,D3
0000148C  4EB9 00001664            593      JSR print_direction
00001492  43F8 0403                594      LEA word, A1
00001496  4EB8 11CA                595      JSR print
0000149A  4EB9 0000171A            596      JSR addr
000014A0                           597  next_ls_as_ro
000014A0  4EB8 11DC                598      JSR enter
000014A4  6000 FD22                599      BRA out
000014A8                           600      
000014A8                           601  print_not
000014A8  43F8 044D                602      LEA not_ins, A1 *print instruction
000014AC  4EB8 11CA                603      JSR print
000014B0  4EB9 000016FE            604      JSR size
000014B6  3602                     605      MOVE.W D2, D3
000014B8  C63C 003F                606      AND.B #$3F, D3
000014BC  B63C 003C                607      CMP.B #$3C, D3
000014C0  6700 FCEA                608      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
000014C4  4EB9 0000171A            609      JSR addr
000014CA  4EB8 11DC                610      JSR enter
000014CE  6000 FCF8                611      BRA out
000014D2                           612  
000014D2                           613  print_jsr
000014D2  43F8 0451                614      LEA jsr_ins, A1 *print instruction
000014D6  4EB8 11CA                615      JSR print
000014DA  4EB9 0000171A            616      JSR addr    *print address
000014E0  4EB8 11DC                617      JSR enter   *print enter (next line)
000014E4  6000 FCE2                618      BRA out
000014E8                           619  
000014E8                           620  print_lea
000014E8  43F8 0456                621      LEA lea_ins, A1 *print instruction
000014EC  4EB8 11CA                622      JSR print   
000014F0  4EB9 0000171A            623      JSR addr    *print address
000014F6  43F8 0486                624      LEA comma, A1   *print comma
000014FA  4EB8 11CA                625      JSR print
000014FE  4EB9 000018B6            626      JSR add_reg_sr *print destination address register
00001504  4EB8 11DC                627      JSR enter
00001508  6000 FCBE                628      BRA out
0000150C                           629  
0000150C                           630  print_addq
0000150C  43F8 0434                631      LEA addq_ins, A1    *print instruction
00001510  4EB8 11CA                632      JSR print
00001514  4EB9 000016FE            633      JSR size            *print instruction size
0000151A  43F8 0489                634      LEA pound, A1
0000151E  4EB8 11CA                635      JSR print           *print '#' for immediate addressing
00001522  3C02                     636      MOVE.W D2,D6
00001524  EF5E                     637      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
00001526  CC7C 0007                638      AND.W #$0007, D6
0000152A  4EB9 00001892            639      JSR Xn
00001530  43F8 0486                640      LEA comma, A1       *print comma
00001534  4EB8 11CA                641      JSR print
00001538  4EB9 0000171A            642      JSR addr            *print destination address
0000153E  4EB8 11DC                643      JSR enter
00001542  6000 FC84                644      BRA out
00001546                           645  
00001546                           646  print_bra_bcc           *needs comments
00001546  3602                     647      MOVE.W D2,D3
00001548  C67C 0F00                648      AND.W #$0F00, D3
0000154C  B67C 0000                649      CMP.W #$0000, D3
00001550  6700 001E                650      BEQ print_bra
00001554  B67C 0700                651      CMP.W #$0700, D3
00001558  6700 0022                652      BEQ print_beq
0000155C  B67C 0E00                653      CMP.W #$0E00, D3
00001560  6700 0032                654      BEQ print_bgt
00001564  B67C 0F00                655      CMP.W #$0F00, D3
00001568  6700 001E                656      BEQ print_ble
0000156C  6000 FC3E                657      BRA invalid
00001570                           658  print_bra
00001570  43F8 046C                659      LEA bra_ins, A1
00001574  4EB8 11CA                660      JSR print
00001578  6000 0022                661      BRA next_bra_bcc
0000157C                           662  print_beq
0000157C  43F8 0468                663      LEA beq_ins, A1
00001580  4EB8 11CA                664      JSR print
00001584  6000 0016                665      BRA next_bra_bcc
00001588                           666  print_ble
00001588  43F8 0464                667      LEA ble_ins, A1
0000158C  4EB8 11CA                668      JSR print
00001590  6000 000A                669      BRA next_bra_bcc
00001594                           670  print_bgt
00001594  43F8 0460                671      LEA bgt_ins, A1
00001598  4EB8 11CA                672      JSR print
0000159C                           673  next_bra_bcc
0000159C  3602                     674      MOVE.W D2, D3
0000159E  C67C 00FF                675      AND.W #$00FF, D3
000015A2  B67C 0000                676      CMP.W #$0000, D3
000015A6  6700 0026                677      BEQ check_word
000015AA  43F8 0407                678      LEA byte, A1
000015AE  4EB8 11CA                679      JSR print
000015B2  43F8 0499                680      LEA dollar, A1
000015B6  4EB8 11CA                681      JSR print
000015BA  3203                     682      MOVE.W D3, D1
000015BC  3602                     683      MOVE.W D2, D3
000015BE  343C 0010                684      MOVE.W #16, D2
000015C2  303C 000F                685      MOVE.W #15,D0
000015C6  4E4F                     686      trap #15            *print immediate address value
000015C8  3403                     687      MOVE.W D3, D2
000015CA  6000 0024                688      BRA end_bra_bcc
000015CE                           689  check_word
000015CE  43F8 0403                690      LEA word, A1
000015D2  4EB8 11CA                691      JSR print
000015D6  43F8 0499                692      LEA dollar, A1
000015DA  4EB8 11CA                693      JSR print
000015DE  544C                     694      ADDA.W #2,A4        *update current address
000015E0  3214                     695      MOVE.W (A4),D1      *retrieve word data stored in the new current address
000015E2  3602                     696      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
000015E4  343C 0010                697      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
000015E8  103C 000F                698      MOVE.B #15, D0      *use trap instruction that allows use of base 16
000015EC  4E4F                     699      TRAP #15
000015EE  3403                     700      MOVE.W D3,D2        *copy opcode back to register D2
000015F0                           701  end_bra_bcc
000015F0  4EB8 11DC                702      JSR enter
000015F4  6000 FBD2                703      BRA out
000015F8                           704  
000015F8                           705  print_movem         *needs comments
000015F8  43F8 041F                706      LEA movem_ins, A1
000015FC  4EB8 11CA                707      JSR print
00001600  3602                     708      MOVE.W D2,D3
00001602  C67C 0040                709      AND.W #$0040,D3
00001606  B67C 0040                710      CMP.W #$0040,D3
0000160A  6700 000E                711      BEQ movem_long
0000160E  43F8 0403                712      LEA word, A1
00001612  4EB8 11CA                713      JSR print
00001616  6000 000A                714      BRA movem_direction
0000161A                           715  movem_long
0000161A  43F8 03FF                716      LEA long, A1
0000161E  4EB8 11CA                717      JSR print
00001622                           718  movem_direction
00001622  3602                     719      MOVE.W D2,D3
00001624  C67C 0400                720      AND.W #$0400,D3
00001628  B67C 0400                721      CMP.W #$0400,D3
0000162C  6700 001A                722      BEQ mem_to_reg
00001630  4EB9 000018CE            723      JSR movem_predec
00001636  43F8 0486                724      LEA comma, A1
0000163A  4EB8 11CA                725      JSR print
0000163E  4EB9 0000171A            726      JSR addr
00001644  6000 0016                727      BRA end_movem
00001648                           728  mem_to_reg
00001648  4EB9 0000171A            729      JSR addr
0000164E  43F8 0486                730      LEA comma, A1
00001652  4EB8 11CA                731      JSR print
00001656  4EB9 000019A0            732      JSR movem_postinc
0000165C                           733  end_movem
0000165C  4EB8 11DC                734      JSR enter
00001660  6000 FB66                735      BRA out
00001664                           736  
00001664                           737  print_direction:
00001664                           738  *print correct direction given direction bit
00001664  C67C 0100                739      AND.W #$0100, D3
00001668  B67C 0100                740      CMP.W #$0100, D3
0000166C  6700 000E                741      BEQ print_left  *print left
00001670  43F8 0470                742      LEA right, A1
00001674  4EB8 11CA                743      JSR print
00001678  6000 FB4E                744      BRA out
0000167C                           745  print_left
0000167C  43F8 0472                746      LEA left, A1
00001680  4EB8 11CA                747      JSR print *print right
00001684  4E75                     748      RTS
00001686                           749      
00001686                           750  print_correct_shift_rotation:
00001686                           751  *determine if instruction is logical, arithmetic, or rotation 
00001686  C63C 0003                752      AND.B #$03, D3
0000168A  B63C 0000                753      CMP.B #$00, D3
0000168E  6700 0016                754      BEQ print_as
00001692  B63C 0001                755      CMP.B #$01, D3
00001696  6700 0016                756      BEQ print_ls
0000169A  B63C 0003                757      CMP.B #$03, D3
0000169E  43F8 044A                758      LEA ro_ins, A1  print rotation
000016A2  6000 000E                759      BRA print_it
000016A6                           760  print_as
000016A6  43F8 0447                761      LEA as_ins, A1  print arithmetic shift
000016AA  6000 0006                762      BRA print_it
000016AE                           763  print_ls
000016AE  43F8 0444                764      LEA ls_ins, A1 print logical shift
000016B2                           765  print_it
000016B2  4EB8 11CA                766      JSR print
000016B6  4E75                     767      RTS
000016B8                           768  * --------- End Print Instruction ----------*
000016B8                           769  
000016B8                           770  * ------- Instruction sizes ---------*
000016B8                           771  
000016B8                           772  move_size:  *print size for MOVE and MOVEA instruction
000016B8  4284                     773      CLR.L D4
000016BA  3802                     774      MOVE.W D2, D4
000016BC  C87C 3000                775      AND.W #$3000, D4
000016C0  B87C 1000                776      CMP.W #$1000, D4
000016C4  6700 0014                777      BEQ print_b
000016C8  B87C 3000                778      CMP.W #$3000, D4
000016CC  6700 0018                779      BEQ print_w
000016D0  B87C 2000                780      CMP.W #$2000, D4
000016D4  6700 001C                781      BEQ print_l
000016D8  4E75                     782      RTS
000016DA                           783      
000016DA                           784  print_b     *print '.B'
000016DA  43F8 0407                785      LEA byte, A1
000016DE  4EB8 11CA                786      JSR print
000016E2  6000 FAE4                787      BRA out
000016E6                           788      
000016E6                           789  print_w     *print '.W'
000016E6  43F8 0403                790      LEA word, A1
000016EA  4EB8 11CA                791      JSR print
000016EE  6000 FAD8                792      BRA out
000016F2                           793      
000016F2                           794  print_l:    *print '.L'
000016F2  43F8 03FF                795      LEA long, A1
000016F6  4EB8 11CA                796      JSR print
000016FA  6000 FACC                797      BRA out
000016FE                           798  
000016FE                           799  size:       *print size for non "move" instructions
000016FE  4284                     800      CLR.L D4
00001700  1802                     801      MOVE.B D2,D4
00001702  C83C 00C0                802      AND.B #$C0, D4
00001706  B83C 0000                803      CMP.B #$00, D4
0000170A  67CE                     804      BEQ print_b
0000170C  B83C 0040                805      CMP.B #$40,D4
00001710  67D4                     806      BEQ print_w
00001712  B83C 0080                807      CMP.B #$80, D4
00001716  67DA                     808      BEQ print_l
00001718  4E75                     809      RTS
0000171A                           810      
0000171A                           811  * ------- End Instruction sizes ---------*
0000171A                           812  
0000171A                           813  * ------- Effective Address -------*
0000171A                           814  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
0000171A  3A02                     815      MOVE.W D2, D5
0000171C  3C02                     816      MOVE.W D2, D6               
0000171E  BE3C 0001                817      CMP.B #1, D7
00001722  6700 003A                818      BEQ destination *check if evaluating destination address (used for MOVE)
00001726                           819  cont
00001726  CC3C 0038                820      AND.B #$38, D6
0000172A  BC3C 0000                821      CMP.B #0, D6
0000172E  6700 0038                822      BEQ data_reg        *check if EA mode is data register
00001732  BC3C 0008                823      CMP.B #$08, D6
00001736  6700 0048                824      BEQ add_reg         *check if EA mode is address register
0000173A  BC3C 0010                825      CMP.B #$10, D6
0000173E  6700 0058                826      BEQ add_indirect    *check if EA mode is address indirect
00001742  BC3C 0018                827      CMP.B #$18, D6
00001746  6700 0070                828      BEQ post_increment  *check if EA mode is post increment
0000174A  BC3C 0020                829      CMP.B #$20, D6
0000174E  6700 0088                830      BEQ pre_decrement   *check if EA mode is pre_decrement
00001752  BC3C 0038                831      CMP.B #$38, D6
00001756  6700 00A0                832      BEQ absolute_or_immediate
0000175A  6000 FA6C                833      BRA out *needs Immediate, Abs Long, and Abs Word
0000175E                           834  destination     *perform correct rotation to retrieve destination address
0000175E  3C05                     835      MOVE.W D5,D6
00001760  EF5D                     836      ROL.W #7,D5
00001762  E64E                     837      LSR.W #3,D6
00001764  60C0                     838      BRA cont
00001766  4E75                     839      RTS
00001768                           840  
00001768                           841  data_reg    *used with addr sub routine
00001768  3C05                     842      MOVE.W D5,D6    
0000176A  CC3C 0007                843      AND.B #$07, D6  
0000176E  43F8 0474                844      LEA D_reg, A1   
00001772  4EB8 11CA                845      JSR print
00001776  4EB9 00001892            846      JSR Xn
0000177C  6000 FA4A                847      BRA out
00001780                           848  
00001780                           849  add_reg     *used with addr sub routine
00001780  3C05                     850      MOVE.W D5,D6    
00001782  CC3C 0007                851      AND.B #$07, D6
00001786  43F8 0476                852      LEA A_reg, A1   
0000178A  4EB8 11CA                853      JSR print
0000178E  4EB9 00001892            854      JSR Xn
00001794  6000 FA32                855      BRA out
00001798                           856      
00001798                           857  add_indirect    *used with addr sub routine
00001798  3C05                     858      MOVE.W D5,D6    
0000179A  CC3C 0007                859      AND.B #$07, D6
0000179E  43F8 0478                860      LEA open_paran, A1  
000017A2  4EB8 11CA                861      JSR print
000017A6  4EB9 00001892            862      JSR Xn
000017AC  43F8 047B                863      LEA close_paran, A1 
000017B0  4EB8 11CA                864      JSR print
000017B4  6000 FA12                865      BRA out
000017B8                           866      
000017B8                           867  post_increment  *used with addr sub routine
000017B8  3C05                     868      MOVE.W D5,D6    
000017BA  CC3C 0007                869      AND.B #$07, D6
000017BE  43F8 0478                870      LEA open_paran, A1  
000017C2  4EB8 11CA                871      JSR print
000017C6  4EB9 00001892            872      JSR Xn
000017CC  43F8 047D                873      LEA post_inc, A1    
000017D0  4EB8 11CA                874      JSR print
000017D4  6000 F9F2                875      BRA out
000017D8                           876      
000017D8                           877  pre_decrement   *used with addr sub routine
000017D8  3C05                     878      MOVE.W D5,D6    
000017DA  CC3C 0007                879      AND.B #$07, D6
000017DE  43F8 0480                880      LEA pre_dec, A1 
000017E2  4EB8 11CA                881      JSR print
000017E6  4EB9 00001892            882      JSR Xn
000017EC  43F8 047B                883      LEA close_paran, A1 
000017F0  4EB8 11CA                884      JSR print
000017F4  6000 F9D2                885      BRA out
000017F8                           886  
000017F8                           887  absolute_or_immediate *check if EA is immediate or absolute address
000017F8  3C05                     888      MOVE.W D5,D6    
000017FA  CC3C 0007                889      AND.B #$07, D6
000017FE  BC3C 0000                890      CMP.B #$00, D6
00001802  6700 0054                891      BEQ w_imm
00001806  BC3C 0001                892      CMP.B #$01, D6
0000180A  6700 0068                893      BEQ l_imm
0000180E  BC3C 0004                894      CMP.B #04, D6
00001812  6700 0002                895      BEQ immediate
00001816                           896      
00001816                           897  immediate
00001816  43F8 0489                898      LEA pound, A1
0000181A  4EB8 11CA                899      JSR print
0000181E  B4BC 00004000            900      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
00001824  6D00 0016                901      BLT move_movea      *check if instruction is move or movea
00001828  B8BC 00000040            902      CMP.L #$0040, D4        *if not move or movea
0000182E  6D00 0028                903      BLT w_imm           *byte and word check the next 2 addresses in mem
00001832  B8BC 00000080            904      CMP.L #$0080, D4
00001838  6700 003A                905      BEQ l_imm           *long checks the next 4 addresses in mem
0000183C                           906  move_movea              *similar comparisons, but for different bits in OPCODE
0000183C  B87C 1000                907      CMP.W #$1000, D4
00001840  6700 0016                908      BEQ w_imm
00001844  B87C 3000                909      CMP.W #$3000, D4
00001848  6700 000E                910      BEQ w_imm
0000184C  B87C 2000                911      CMP.W #$2000, D4
00001850  6700 0022                912      BEQ l_imm
00001854                           913  imm_complete
00001854  6000 F972                914      BRA out
00001858                           915      
00001858                           916  w_imm
00001858  43F8 0499                917      LEA dollar, A1      *print '$'
0000185C  4EB8 11CA                918      JSR print
00001860  544C                     919      ADDA.W #2,A4        *update current address
00001862  3214                     920      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001864  3602                     921      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001866  343C 0010                922      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000186A  103C 000F                923      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000186E  4E4F                     924      TRAP #15
00001870  3403                     925      MOVE.W D3,D2        *copy opcode back to register D2
00001872  60E0                     926      BRA imm_complete    *exit addr subroutine
00001874                           927      
00001874                           928  l_imm
00001874  43F8 0499                929      LEA dollar, A1      *print '$'
00001878  4EB8 11CA                930      JSR print
0000187C  544C                     931      ADDA.W  #2,A4       *update current address
0000187E  2214                     932      MOVE.L (A4),D1      *retrieve long data stored in the new current address
00001880  3602                     933      MOVE.W D2, D3
00001882  343C 0010                934      MOVE.W #16, D2
00001886  103C 000F                935      MOVE.B #15, D0
0000188A  4E4F                     936      TRAP #15
0000188C  3403                     937      MOVE.W D3,D2
0000188E  544C                     938      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
00001890  60C2                     939      BRA imm_complete    *exit addr subroutine
00001892                           940  
00001892                           941  Xn:                     *retieve signed decimal value of data stored in register D6
00001892  4281                     942      CLR.L D1
00001894  1206                     943      MOVE.B D6,D1
00001896  103C 0003                944      MOVE.B #3, D0
0000189A  4E4F                     945      TRAP #15
0000189C  4E75                     946      RTS
0000189E                           947  
0000189E                           948  data_reg_sr:    *use if dealing with Dn only
0000189E  4286                     949      CLR.L D6
000018A0  3C05                     950      MOVE.W D5,D6
000018A2  EF5E                     951      ROL.W #7,D6
000018A4  CC3C 0007                952      AND.B #$07, D6  
000018A8  43F8 0474                953      LEA D_reg, A1   
000018AC  4EB8 11CA                954      JSR print
000018B0  4EB8 1892                955      JSR Xn
000018B4  4E75                     956      RTS
000018B6                           957      
000018B6                           958  add_reg_sr:     *use if dealing with An only
000018B6  4286                     959      CLR.L D6
000018B8  3C02                     960      MOVE.W D2,D6
000018BA  EF5E                     961      ROL.W #7,D6
000018BC  CC3C 0007                962      AND.B #$07, D6  
000018C0  43F8 0476                963      LEA A_reg, A1   
000018C4  4EB8 11CA                964      JSR print
000018C8  4EB8 1892                965      JSR Xn
000018CC  4E75                     966      RTS
000018CE                           967      
000018CE                           968  movem_predec:           *needs to be worked on
000018CE  4285                     969      CLR.L D5
000018D0  544C                     970      ADDA.W  #2,A4       *update current address
000018D2  3A14                     971      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000018D4  BA3C 0000                972      CMP.B #$00, D5
000018D8  6700 006C                973      BEQ predec_skip_to_d
000018DC  3C05                     974      MOVE.W D5,D6
000018DE  4281                     975      CLR.L D1
000018E0  123C 0000                976      MOVE.B #0, D1
000018E4                           977  a_loop1
000018E4  E31E                     978      ROL.B #1,D6
000018E6  6500 0006                979      BCS a_loop1_done
000018EA  5201                     980      ADD.B #1,D1
000018EC  60F6                     981      BRA a_loop1
000018EE                           982  a_loop1_done
000018EE  43F8 0476                983      LEA A_reg,A1
000018F2  4EB8 11CA                984      JSR print
000018F6  103C 0003                985      MOVE.B #3,D0
000018FA  4E4F                     986      TRAP #15
000018FC  4287                     987      CLR.L D7
000018FE  1E3C 0000                988      MOVE.B #0, D7
00001902                           989  a_loop2
00001902  E31E                     990      ROL.B #1,D6
00001904  6400 0010                991      BCC a_loop2_done
00001908  5207                     992      ADD.B #1,D7
0000190A  5201                     993      ADD.B #1,D1
0000190C  B23C 0007                994      CMP.B #7, D1
00001910  6700 0004                995      BEQ a_loop2_done
00001914  60EC                     996      BRA a_loop2
00001916                           997  a_loop2_done
00001916  BE3C 0000                998      CMP.B #0, D7
0000191A  6700 0018                999      BEQ predec_no_dash
0000191E  43F8 048B               1000      LEA dash, A1
00001922  4EB8 11CA               1001      JSR print
00001926  43F8 0476               1002      LEA A_reg,A1
0000192A  4EB8 11CA               1003      JSR print
0000192E  103C 0003               1004      MOVE.B #3,D0
00001932  4E4F                    1005      TRAP #15
00001934                          1006  predec_no_dash
00001934  BABC 000000FF           1007      CMP.L #$00FF,D5
0000193A  6F00 0062               1008      BLE end_movem_predec
0000193E  43F8 048D               1009      LEA slash, A1
00001942  4EB8 11CA               1010      JSR print
00001946                          1011  predec_skip_to_d    
00001946  3C05                    1012      MOVE.W D5,D6
00001948  E04E                    1013      LSR.W #8,D6
0000194A  4281                    1014      CLR.L D1
0000194C  123C 0000               1015      MOVE.B #0, D1
00001950                          1016  d_loop1
00001950  E31E                    1017      ROL.B #1,D6
00001952  6500 0006               1018      BCS d_loop1_done
00001956  5201                    1019      ADD.B #1,D1
00001958  60F6                    1020      BRA d_loop1
0000195A                          1021  d_loop1_done
0000195A  43F8 0474               1022      LEA D_reg,A1
0000195E  4EB8 11CA               1023      JSR print
00001962  103C 0003               1024      MOVE.B #3,D0
00001966  4E4F                    1025      TRAP #15
00001968  4287                    1026      CLR.L D7
0000196A  1E3C 0000               1027      MOVE.B #0, D7
0000196E                          1028  d_loop2
0000196E  E31E                    1029      ROL.B #1,D6
00001970  6400 000E               1030      BCC d_loop2_done
00001974  5201                    1031      ADD.B #1,D1
00001976  B23C 0007               1032      CMP.B #7, D1
0000197A  6700 0004               1033      BEQ d_loop2_done
0000197E  60EE                    1034      BRA d_loop2
00001980                          1035  d_loop2_done
00001980  BE3C 0000               1036      CMP.B #0, D7
00001984  6F00 0018               1037      BLE end_movem_predec
00001988  43F8 048B               1038      LEA dash, A1
0000198C  4EB8 11CA               1039      JSR print
00001990  43F8 0474               1040      LEA D_reg,A1
00001994  4EB8 11CA               1041      JSR print
00001998  103C 0003               1042      MOVE.B #3,D0
0000199C  4E4F                    1043      TRAP #15
0000199E                          1044  end_movem_predec
0000199E  4E75                    1045      RTS
000019A0                          1046      
000019A0                          1047  movem_postinc:          *needs to be worked on
000019A0  4285                    1048      CLR.L D5
000019A2  544C                    1049      ADDA.W  #2,A4       *update current address
000019A4  3A14                    1050      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019A6  3C05                    1051      MOVE.W D5,D6
000019A8  E04E                    1052      LSR.W #8,D6
000019AA  BC3C 0000               1053      CMP.B #$00, D6
000019AE  6700 0068               1054      BEQ postinc_skip_to_d
000019B2  4281                    1055      CLR.L D1
000019B4  123C 0000               1056      MOVE.B #0, D1
000019B8                          1057  a_loop3
000019B8  E21E                    1058      ROR.B #1,D6
000019BA  6500 0006               1059      BCS a_loop3_done
000019BE  5201                    1060      ADD.B #1,D1
000019C0  60F6                    1061      BRA a_loop3
000019C2                          1062  a_loop3_done
000019C2  43F8 0476               1063      LEA A_reg,A1
000019C6  4EB8 11CA               1064      JSR print
000019CA  103C 0003               1065      MOVE.B #3,D0
000019CE  4E4F                    1066      TRAP #15
000019D0  4287                    1067      CLR.L D7
000019D2  1E3C 0000               1068      MOVE.B #0, D7
000019D6                          1069  a_loop4
000019D6  E21E                    1070      ROR.B #1,D6
000019D8  6400 0010               1071      BCC a_loop4_done
000019DC  5207                    1072      ADD.B #1,D7
000019DE  5201                    1073      ADD.B #1,D1
000019E0  B23C 0007               1074      CMP.B #7, D1
000019E4  6700 0004               1075      BEQ a_loop4_done
000019E8  60EC                    1076      BRA a_loop4
000019EA                          1077  a_loop4_done
000019EA  BE3C 0000               1078      CMP.B #0, D7
000019EE  6700 0018               1079      BEQ postinc_no_dash
000019F2  43F8 048B               1080      LEA dash, A1
000019F6  4EB8 11CA               1081      JSR print
000019FA  43F8 0476               1082      LEA A_reg,A1
000019FE  4EB8 11CA               1083      JSR print
00001A02  103C 0003               1084      MOVE.B #3,D0
00001A06  4E4F                    1085      TRAP #15
00001A08                          1086  postinc_no_dash
00001A08  BA3C 0000               1087      CMP.B #$00, D5
00001A0C  6700 0060               1088      BEQ end_movem_postinc
00001A10  43F8 048D               1089      LEA slash, A1
00001A14  4EB8 11CA               1090      JSR print
00001A18                          1091  postinc_skip_to_d   
00001A18  3C05                    1092      MOVE.W D5,D6
00001A1A  4281                    1093      CLR.L D1
00001A1C  123C 0000               1094      MOVE.B #0, D1
00001A20                          1095  d_loop3
00001A20  E21E                    1096      ROR.B #1,D6
00001A22  6500 0006               1097      BCS d_loop3_done
00001A26  5201                    1098      ADD.B #1,D1
00001A28  60F6                    1099      BRA d_loop3
00001A2A                          1100  d_loop3_done
00001A2A  43F8 0474               1101      LEA D_reg,A1
00001A2E  4EB8 11CA               1102      JSR print
00001A32  103C 0003               1103      MOVE.B #3,D0
00001A36  4E4F                    1104      TRAP #15
00001A38  4287                    1105      CLR.L D7
00001A3A  1E3C 0000               1106      MOVE.B #0, D7
00001A3E                          1107  d_loop4
00001A3E  E21E                    1108      ROR.B #1,D6
00001A40  6400 000E               1109      BCC d_loop4_done
00001A44  5201                    1110      ADD.B #1,D1
00001A46  B23C 0007               1111      CMP.B #7, D1
00001A4A  6700 0004               1112      BEQ d_loop4_done
00001A4E  60EE                    1113      BRA d_loop4
00001A50                          1114  d_loop4_done
00001A50  BE3C 0000               1115      CMP.B #0, D7
00001A54  6F00 0018               1116      BLE end_movem_postinc
00001A58  43F8 048B               1117      LEA dash, A1
00001A5C  4EB8 11CA               1118      JSR print
00001A60  43F8 0474               1119      LEA D_reg,A1
00001A64  4EB8 11CA               1120      JSR print
00001A68  103C 0003               1121      MOVE.B #3,D0
00001A6C  4E4F                    1122      TRAP #15
00001A6E                          1123  end_movem_postinc
00001A6E  4E75                    1124      RTS
00001A70                          1125  
00001A70                          1126  
00001A70                          1127  * ------- End Effective Address -------*
00001A70                          1128  
00001A70                          1129  * ----- Hex to ASCII & ASCII to HEX -----*
00001A70                          1130  
00001A70                          1131  ASCIItoHex:
00001A70  4EB9 00001A7E           1132          jsr     ASCII2Hex_init  
00001A76  4EB9 00001A84           1133          jsr     conversion_loop
00001A7C  4E75                    1134          rts                    
00001A7E                          1135  
00001A7E                          1136  ASCII2Hex_init:   
00001A7E  143C 0000               1137          move.b  #0,D2       *set up counter    
00001A82  4E75                    1138          rts         
00001A84                          1139          
00001A84                          1140  conversion_loop:            
00001A84  5282                    1141          add.l   #1,D2       *increment counter
00001A86  B4BC 00000009           1142          cmp.l   #9,D2       *ends at 9
00001A8C  6700 004A               1143          BEQ     DONE        *branch when compare is true
00001A90  1819                    1144          move.b  (A1)+,D4    *Get first num
00001A92                          1145          
00001A92  B83C 0040               1146          cmp.b   #$40,D4        
00001A96  6E00 000C               1147          bgt     Letters_Cap  
00001A9A                          1148          
00001A9A  B83C 0039               1149          cmp.b   #$39,D4
00001A9E  6F00 0016               1150          BLE     Numbers      
00001AA2  4E75                    1151          rts
00001AA4                          1152          
00001AA4                          1153  Letters_Cap:      
00001AA4  B83C 0046               1154          cmp.b   #$46,D4          
00001AA8  6E00 001E               1155          bgt     ERROR  
00001AAC  0404 0037               1156          sub.b   #$37,D4     
00001AB0  E986                    1157          asl.l   #4,D6       
00001AB2  DC84                    1158          add.l   D4,D6     
00001AB4  60CE                    1159          bra     conversion_loop 
00001AB6                          1160  Numbers:
00001AB6  B83C 0030               1161          cmp.b   #$30,D4         
00001ABA  6D00 000C               1162          blt     ERROR        
00001ABE  0404 0030               1163          sub.b   #$30,D4      
00001AC2  E986                    1164          asl.l   #4,D6        
00001AC4  DC84                    1165          add.l   D4,D6     
00001AC6  60BC                    1166          bra     conversion_loop
00001AC8                          1167          
00001AC8                          1168  ERROR:
00001AC8  43F8 011E               1169          lea     ErrorMsg,A1    
00001ACC  103C 000E               1170          move.b  #14,D0
00001AD0  4E4F                    1171          trap    #15
00001AD2                          1172      
00001AD2  103C 0009               1173          move.b  #9,D0
00001AD6  4E4F                    1174          trap    #15
00001AD8                          1175          
00001AD8                          1176  DONE:
00001AD8                          1177     
00001AD8  4241                    1178          clr     D1
00001ADA  4242                    1179          clr     D2
00001ADC  4244                    1180          clr     D4
00001ADE                          1181      
00001ADE  43F8 014F               1182          lea     ASCIItoHexMsg,A1
00001AE2  103C 000E               1183          move.b  #14,D0
00001AE6  4E4F                    1184          trap    #15
00001AE8                          1185  
00001AE8  4E75                    1186          rts
00001AEA                          1187          
00001AEA                          1188  
00001AEA                          1189          
00001AEA                          1190  * -- End of Hex to ASCII & ASCII to HEX --*
00001AEA                          1191  
00001AEA                          1192  * Put program code here
00001AEA                          1193  
00001AEA  FFFF FFFF               1194      SIMHALT             ; halt simulator
00001AEE                          1195  
00001AEE                          1196  * Put variables and constants here
00001AEE                          1197  
00001AEE                          1198      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  17F8
ADDA_INS            42F
ADDA_SIZE           1308
ADDQ_INS            434
ADDR                171A
ADD_A               12E6
ADD_INDIRECT        1798
ADD_INS             42B
ADD_REG             1780
ADD_REG_SR          18B6
ANDQ_INS            45B
AND_INS             43C
ASCII2HEX_INIT      1A7E
ASCIITOHEX          1A70
ASCIITOHEXMSG       14F
AS_INS              447
A_LOOP1             18E4
A_LOOP1_DONE        18EE
A_LOOP2             1902
A_LOOP2_DONE        1916
A_LOOP3             19B8
A_LOOP3_DONE        19C2
A_LOOP4             19D6
A_LOOP4_DONE        19EA
A_REG               476
BEQ_INS             468
BGT_INS             460
BLE_INS             464
BRA_INS             46C
BYTE                407
CHECKADDRESS        10B8
CHECK_WORD          15CE
CLEAR_REGISTERS     102A
CLOSE_PARAN         47B
COMMA               486
CONT                1726
CONTINUEORNOTMSG    1CC
CONTINUE_INSTRUCTION_LS_AS_RO  145C
CONVERSION_LOOP     1A84
CR                  D
CREATORS            1F
DASH                48B
DATA                492
DATA_REG            1768
DATA_REG_SR         189E
DESTINATION         175E
DOLLAR              499
DONE                1AD8
D_LOOP1             1950
D_LOOP1_DONE        195A
D_LOOP2             196E
D_LOOP2_DONE        1980
D_LOOP3             1A20
D_LOOP3_DONE        1A2A
D_LOOP4             1A3E
D_LOOP4_DONE        1A50
D_REG               474
EA_DEST_ADD         12CC
EA_DEST_SUB_AND_OR  13AE
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             1328
END_ADDR_BUFFER     2FF
END_BRA_BCC         15F0
END_MOVEM           165C
END_MOVEM_POSTINC   1A6E
END_MOVEM_PREDEC    199E
ENTER               11DC
ERROR               1AC8
ERRORMSG            11E
EXITMSG             1EF
FLUSHSCREEN         1114
GETENDADDRESS       109E
GETSTARTADDRESS     1084
HELPMSG             190
HEXTOASCIIMSG       12D
IMMEDIATE           1816
IMM_COMPLETE        1854
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             11AC
JSR_INS             451
LEA_INS             456
LEFT                472
LETTERS_CAP         1AA4
LF                  A
LONG                3FF
LS_AS_RO_MEM        1472
LS_AS_RO_REG        1454
LS_INS              444
L_IMM               1874
MEMSEARCH           10BC
MEMSEARCHLOOP       10C4
MEMSEARCH_DONE      10F2
MEM_TO_REG          1648
MENU                1066
MOVEA_INS           425
MOVEM_DIRECTION     1622
MOVEM_INS           41F
MOVEM_LONG          161A
MOVEM_POSTINC       19A0
MOVEM_PREDEC        18CE
MOVEQ_INS           418
MOVE_A              1258
MOVE_INS            413
MOVE_MOVEA          183C
MOVE_SIZE           16B8
MUL_DIV             13CC
MUL_DIV_LONG        13EE
M_SIZE              1260
NEXT_ADD            1314
NEXT_BRA_BCC        159C
NEXT_LS_AS_RO       14A0
NOP_INS             40B
NOT_INS             44D
NUMBERS             1AB6
OPCODE_DECODE       1114
OPEN_PARAN          478
OR_INS              439
OUT                 11C8
POSTINC_NO_DASH     1A08
POSTINC_SKIP_TO_D   1A18
POST_INC            47D
POST_INCREMENT      17B8
POUND               489
PREDEC_NO_DASH      1934
PREDEC_SKIP_TO_D    1946
PRE_DEC             480
PRE_DECREMENT       17D8
PRINT               11CA
PRINTLN             11D4
PRINT_ADDQ          150C
PRINT_ADD_ADDA      1288
PRINT_AS            16A6
PRINT_B             16DA
PRINT_BEQ           157C
PRINT_BGT           1594
PRINT_BLE           1588
PRINT_BRA           1570
PRINT_BRA_BCC       1546
PRINT_CORRECT_SHIFT_ROTATION  1686
PRINT_DIRECTION     1664
PRINT_INSTRUCTION   137C
PRINT_IT            16B2
PRINT_JSR           14D2
PRINT_L             16F2
PRINT_LEA           14E8
PRINT_LEFT          167C
PRINT_LS            16AE
PRINT_LS_AS_RO      13F4
PRINT_MOVEM         15F8
PRINT_MOVEQ         11FA
PRINT_MOVE_MOVEA    123E
PRINT_NOP           11E6
PRINT_NOT           14A8
PRINT_OR            1378
PRINT_RTS           11F0
PRINT_SUB           1362
PRINT_SUB_AND_OR    1330
PRINT_W             16E6
RETURN              48F
RIGHT               470
RO_INS              44A
RTS_INS             40F
SCREENFLUSH         110A
SIZE                16FE
SLASH               48D
SPACE               484
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   1FF
SUB_INS             440
TAB                 9
TERMINATEORCONT     10FE
WORD                403
W_IMM               1858
XN                  1892
