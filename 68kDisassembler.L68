00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 3:58:22 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 46 69 6E ...     22  EndOfMemLoop        dc.b    '---Finished Reading Instructions---',CR,LF,0
00000199= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to continue with the next set of instructions',0
000001D3= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
0000020F= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
00000245= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000255                            27  
00000255                            28  *START_ADDR_BUFFER  DS.B    256
00000255                            29  *END_ADDR_BUFFER    DS.B    256
00000255                            30  
00000255                            31  *size
00000255= 2E 4C 20 00               32  long                DC.B    '.L ',0
00000259= 2E 57 20 00               33  word                DC.B    '.W ',0
0000025D= 2E 42 20 00               34  byte                DC.B    '.B ',0
00000261                            35  
00000261                            36  *instructions
00000261= 4E 4F 50 00               37  nop_ins             DC.B    'NOP',0
00000265= 52 54 53 00               38  rts_ins             DC.B    'RTS',0
00000269= 4D 4F 56 45 00            39  move_ins            DC.B    'MOVE',0
0000026E= 4D 4F 56 45 51 20 00      40  moveq_ins           DC.B    'MOVEQ ',0
00000275= 4D 4F 56 45 4D 00         41  movem_ins           DC.B    'MOVEM',0
0000027B= 4D 4F 56 45 41 00         42  movea_ins           DC.B    'MOVEA',0
00000281= 41 44 44 00               43  add_ins             DC.B    'ADD',0
00000285= 41 44 44 41 00            44  adda_ins            DC.B    'ADDA',0
0000028A= 41 44 44 51 00            45  addq_ins            DC.B    'ADDQ',0
0000028F= 4F 52 00                  46  or_ins              DC.B    'OR',0
00000292= 41 4E 44 00               47  and_ins             DC.B    'AND',0
00000296= 53 55 42 00               48  sub_ins             DC.B    'SUB',0
0000029A= 4C 53 00                  49  ls_ins              DC.B    'LS',0
0000029D= 41 53 00                  50  as_ins              DC.B    'AS',0
000002A0= 52 4F 00                  51  ro_ins              DC.B    'RO',0
000002A3= 4E 4F 54 00               52  not_ins             DC.B    'NOT',0
000002A7= 4A 53 52 20 00            53  jsr_ins             DC.B    'JSR ',0
000002AC= 4C 45 41 20 00            54  lea_ins             DC.B    'LEA ',0
000002B1= 41 44 44 51 00            55  andq_ins            DC.B    'ADDQ',0
000002B6= 42 47 54 00               56  bgt_ins             DC.B    'BGT',0
000002BA= 42 4C 45 00               57  ble_ins             DC.B    'BLE',0
000002BE= 42 45 51 00               58  beq_ins             DC.B    'BEQ',0
000002C2= 42 52 41 00               59  bra_ins             DC.B    'BRA',0
000002C6                            60  
000002C6                            61  *direction
000002C6= 52 00                     62  right               DC.B    'R',0
000002C8= 4C 00                     63  left                DC.B    'L',0
000002CA                            64  
000002CA                            65  *EA
000002CA= 44 00                     66  D_reg               DC.B    'D',0
000002CC= 41 00                     67  A_reg               DC.B    'A',0
000002CE= 28 41 00                  68  open_paran          DC.B    '(A',0
000002D1= 29 00                     69  close_paran         DC.B    ')',0
000002D3= 29 2B 00                  70  post_inc            DC.B    ')+',0
000002D6= 2D 28 41 00               71  pre_dec             DC.B    '-(A',0
000002DA                            72  
000002DA                            73  *extra
000002DA= 20 00                     74  space               DC.B    ' ',0
000002DC= 2C 20 00                  75  comma               DC.B    ', ',0
000002DF= 23 00                     76  pound               DC.B    '#',0
000002E1= 2D 00                     77  dash                DC.B    '-',0
000002E3= 2F 00                     78  slash               DC.B    '/',0
000002E5  =00000009                 79  tab                 EQU     $9
000002E5= 0D 0A 00                  80  return              DC.B    CR,LF,0
000002E8= 44 41 54 41 20 24 00      81  data                DC.B    'DATA $',0
000002EF= 24 00                     82  dollar              DC.B    '$',0
00001000                            83      ORG    $1000    *Start at address $1000
00001000                            84  START:                  ; first instruction of program
00001000                            85  
00001000                            86  *---------- Test value, will remove in final build ----------*
00001000                            87  
00001000                            88  *   Move.W #$4E75,$00009234 *RTS
00001000                            89  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            90  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            91  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            92  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            93  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            94  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            95  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            96  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            97  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            98  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            99  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                           100  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           101  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           102  *   MOVE.W #$000C,$00009250
00001000                           103  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           104  *   MOVE.L #$12345678,$00009254
00001000                           105  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           106  *   MOVE.W #$0012,$0000925A
00001000                           107  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           108  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           109  *   MOVE.L #$00009208,$00009260
00001000                           110  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           111  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           112  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           113  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           114  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           115  *    MOVE.W #$FE7A,$0000926E
00001000                           116  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           117  *    MOVE.W #$FE60,$00009272
00001000                           118  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           119  *    MOVE.L #$00009208,$000009276
00001000                           120  *    MOVE.W #$48A1,$0000927A
00001000                           121  *    MOVE.W #$011F,$0000927C
00001000                           122  *    MOVE.W #$4C91,$0000927E
00001000                           123  *    MOVE.W #$FE00,$00009280
00001000                           124  *   MOVE.W #$C2BC, $00009000
00001000                           125  *   MOVE.L #$12345678, $00009002
00001000  33FC 48B9 00009000       126      MOVE.W #$48B9, $00009000
00001008  33FC 0280 00009002       127      MOVE.W #$0280, $00009002 
00001010  23FC 12345678 00009004   128      MOVE.L #$12345678, $00009004
0000101A                           129  *   MOVE.W #$9441, $00009006
0000101A                           130  *   Move.w #$C27C, $00009008
0000101A                           131  *   move.w #$1234, $0000900A
0000101A                           132  *   MOVE.L #$12345678, $00009002
0000101A                           133  *---------- END Test ----------*
0000101A                           134  
0000101A                           135  
0000101A                           136  
0000101A                           137  *---------- Beginning Messages ----------*
0000101A                           138      
0000101A  103C 000E                139      move.b      #14,D0
0000101E  43F8 0000                140      lea         StartingMsg,A1 
00001022  4E4F                     141      trap        #15
00001024                           142      
00001024  103C 000E                143      move.b      #14,D0
00001028  43F8 001F                144      lea         Creators,A1
0000102C  4E4F                     145      trap        #15
0000102E                           146      
0000102E  4EB9 00001080            147      jsr         MENU
00001034                           148      
00001034                           149      
00001034                           150  * ---------- END OF PROGRAM -------------*
00001034                           151  
00001034  103C 000E                152      move.b      #14,D0
00001038  43F8 0245                153      lea         ExitMsg,A1 
0000103C  4E4F                     154      trap        #15
0000103E                           155      
0000103E  103C 0009                156      move.b      #9,D0
00001042  4E4F                     157      trap        #15
00001044                           158  * ---------------------------------------*
00001044                           159      
00001044                           160  *-- End of Opening and Ending Messages --*
00001044                           161  
00001044                           162  *--------- Start of I/O Section ---------*
00001044                           163  
00001044                           164  Clear_Registers:
00001044  4280                     165      clr.l     D0
00001046  4281                     166      clr.l     D1
00001048  4282                     167      clr.l     D2
0000104A  4283                     168      clr.l     D3
0000104C  4284                     169      clr.l     D4
0000104E  4285                     170      clr.l     D5
00001050  4286                     171      clr.l     D6
00001052  4287                     172      clr.l     D7
00001054                           173      
00001054  207C 00000000            174      movea.l   #0,A0
0000105A  227C 00000000            175      movea.l   #0,A1
00001060  247C 00000000            176      movea.l   #0,A2
00001066  267C 00000000            177      movea.l   #0,A3
0000106C  287C 00000000            178      movea.l   #0,A4
00001072  2A7C 00000000            179      movea.l   #0,A5
00001078  2C7C 00000000            180      movea.l   #0,A6
0000107E  4E75                     181      rts
00001080                           182  
00001080                           183  MENU:
00001080  4EB8 1044                184      jsr         Clear_Registers
00001084  4EB9 00001098            185      jsr         GetStartAddress
0000108A  4EB9 000010B8            186      jsr         GetEndAddress
00001090                           187      
00001090  4EB9 00001108            188      jsr         MemSearch
00001096  4E75                     189      rts
00001098                           190      
00001098                           191  GetStartAddress:         *Display input message
00001098  103C 000E                192      move.b  #14, D0
0000109C  43F8 004E                193      lea         InputMsg1,A1
000010A0  4E4F                     194      trap #15
000010A2  227C 00000000            195      MOVEA.L #0, A1
000010A8  103C 0002                196      move.b      #2,D0
000010AC  4E4F                     197      trap        #15
000010AE                           198          
000010AE  4EB9 00001B0C            199      jsr ASCIItoHex              *conversion to Hex
000010B4                           200      * Address Located in D6
000010B4  2846                     201      movea.l     D6,A4           *move into address register 4
000010B6  4E75                     202      rts
000010B8                           203      
000010B8                           204      
000010B8                           205  GetEndAddress:
000010B8  103C 000E                206      move.b      #14,D0          *Display input message
000010BC  43F8 008F                207      lea         InputMsg2,A1
000010C0  4E4F                     208      trap        #15
000010C2  227C 00000000            209      MOVEA.L #0, A1
000010C8  103C 0002                210      move.b      #2,D0
000010CC  4E4F                     211      trap        #15
000010CE                           212      
000010CE  4EB9 00001B0C            213      jsr         ASCIItoHex      *conversion to hex
000010D4                           214      * Address Located in D6 (overwrite)
000010D4  2A46                     215      movea.l     D6,A5           *move into address register 5
000010D6  4E75                     216      rts
000010D8                           217  
000010D8                           218  
000010D8                           219  ClearScreen:
000010D8  43F8 02E5                220      lea     return,A1
000010DC  103C 000E                221      move.b  #14,D0
000010E0  4E4F                     222      trap    #15
000010E2                           223      
000010E2                           224      *move.b  #9,D0
000010E2                           225      *trap    #15
000010E2                           226      
000010E2  B27C 0028                227      cmp.w   #40,D1
000010E6  6700 001E                228      beq     ClearDone
000010EA  5241                     229      add.w   #1,D1
000010EC  60EA                     230      bra     ClearScreen
000010EE                           231  
000010EE                           232  
000010EE                           233  ClearScreen_40:
000010EE  43F8 02E5                234      lea     return,A1
000010F2  103C 000E                235      move.b  #14,D0
000010F6  4E4F                     236      trap    #15
000010F8                           237      
000010F8  B2BC 00000028            238      cmp.l   #40,D1
000010FE  6700 0006                239      beq     ClearDone
00001102  5281                     240      add.l   #1,D1
00001104  60E8                     241      bra     ClearScreen_40
00001106                           242      
00001106                           243  ClearDone:
00001106  4E75                     244      rts
00001108                           245      
00001108                           246  MemSearch:
00001108  7200                     247      move.l      #0,D1
0000110A  4EB8 10D8                248      jsr         ClearScreen
0000110E                           249      * Set up instruction counter and place onto stack
0000110E  303C 0000                250      move.w      #0,D0
00001112  3F00                     251      move.w      D0,-(SP)
00001114                           252      
00001114  4EB9 0000111C            253      jsr MemSearchLoop
0000111A  4E75                     254      rts
0000111C                           255      
0000111C                           256  MemSearchLoop:
0000111C                           257      
0000111C                           258      * Check if we reached the end address
0000111C  BBCC                     259      cmp.l       A4,A5
0000111E  6700 0036                260      beq         MemSearch_Done
00001122                           261      
00001122                           262      * Get data from memory
00001122  4241                     263      CLR D1
00001124  3414                     264      move.w     (A4),D2
00001126  3602                     265      move.w      D2, D3  mutable copy in D3
00001128                           266      * OPCODE Word Located in D2, mutable copy in D3
00001128  220C                     267      MOVE.L      A4, D1
0000112A  143C 0010                268      MOVE.B      #16, D2
0000112E  103C 000F                269      MOVE.B      #15, D0     print address of instruction
00001132  4E4F                     270      TRAP        #15
00001134  3403                     271      MOVE.W      D3,D2
00001136  43F8 02DA                272      LEA         space,A1
0000113A  4EB9 00001282            273      JSR         print
00001140  4EB9 000011CC            274      jsr         OPCODE_DECODE    
00001146                           275      
00001146  544C                     276      adda.w      #2,A4
00001148                           277      
00001148                           278      * Call back counter from the stack
00001148  301F                     279      move.w      (SP)+,D0
0000114A  5200                     280      add.b       #1,D0
0000114C  4EB9 0000119C            281      jsr         ScreenFlush_Check
00001152  3F00                     282      move.w      D0,-(SP)
00001154                           283      
00001154  60C6                     284      bra         MemSearchLoop
00001156                           285      
00001156                           286      
00001156                           287  MemSearch_Done
00001156  43F8 0173                288      lea         EndOfMemLoop,A1 
0000115A  4EB9 00001282            289      jsr print
00001160  43F8 02E5                290      lea     return, A1
00001164  4EB9 00001282            291      jsr print
0000116A  43F8 020F                292      lea ContinueOrNotMsg, A1
0000116E  4EB9 00001282            293      jsr print
00001174  103C 0005                294      MOVE.B #5, D0
00001178  4E4F                     295      TRAP #15
0000117A  43F8 02E5                296      lea return, A1
0000117E  4EB9 00001282            297      jsr print
00001184  B23C 0079                298      CMP.B #121, D1    
00001188  6700 FEF6                299      beq MENU
0000118C  103C 000E                300      move.b      #14,D0
00001190  43F8 0245                301      lea         ExitMsg,A1 
00001194  4E4F                     302      trap        #15
00001196                           303      
00001196  103C 0009                304      move.b      #9,D0
0000119A  4E4F                     305      trap        #15
0000119C                           306  
0000119C                           307  ScreenFlush_Check:
0000119C  B03C 001F                308      cmp.b       #31,D0 * 31
000011A0  6700 0004                309      beq         FlushScreen
000011A4  4E75                     310      rts 
000011A6                           311  
000011A6                           312  FlushScreen:
000011A6  43F8 0199                313      lea         FlushScreenMsg,A1
000011AA  103C 000E                314      move.b      #14,D0
000011AE  4E4F                     315      trap        #15
000011B0  4EB9 000011B8            316      jsr         FlushScreen_Input
000011B6                           317      *move.l      #0,D1
000011B6                           318      *jsr         ClearScreen_40
000011B6  4E75                     319      rts
000011B8                           320  
000011B8                           321  FlushScreen_Input:
000011B8                           322  
000011B8  4241                     323      clr     D1
000011BA                           324  
000011BA  103C 0005                325      move.b  #5,D0
000011BE  4E4F                     326      trap    #15
000011C0                           327      
000011C0  B23C 000D                328      cmp.b   #13,D1
000011C4  6700 0004                329      beq     Enter_Press_True    
000011C8                           330      
000011C8  60EE                     331      bra     FlushScreen_Input
000011CA                           332      
000011CA                           333  Enter_Press_True:
000011CA  4E75                     334      rts
000011CC                           335      
000011CC                           336  
000011CC                           337      
000011CC                           338  
000011CC                           339  * -------- Start of Opcode Section -------*    
000011CC                           340  
000011CC                           341  OPCODE_DECODE:
000011CC                           342      * Begin OPCODE Decoding here
000011CC                           343      * Check first four bits and begin
000011CC                           344      * if-branch breakdown
000011CC  4284                     345      CLR.L D4
000011CE  4285                     346      CLR.L D5
000011D0  4286                     347      CLR.L D6
000011D2  4287                     348      CLR.L D7
000011D4                           349      
000011D4  B47C 4E71                350      CMP.W #$4E71, D2        
000011D8  6700 00C4                351      BEQ print_nop           *check if value is NOP
000011DC                           352      
000011DC  B47C 4E75                353      CMP.W #$4E75, D2        
000011E0  6700 00C6                354      BEQ print_rts           *check if value is RTS
000011E4                           355      
000011E4                           356      * Mask out only the first 4 bits
000011E4  C67C F000                357      AND.W #$F000,D3
000011E8                           358      
000011E8  B67C 9000                359      CMP.W #$9000,D3
000011EC  6700 01FA                360      BEQ print_sub_and_or    *check if value is SUB
000011F0                           361      
000011F0  B67C 6000                362      CMP.W #$6000,D3
000011F4  6700 0408                363      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011F8                           364      
000011F8  B67C 8000                365      CMP.W #$8000, D3
000011FC  6700 01EA                366      BEQ print_sub_and_or    *check if value is OR
00001200                           367  
00001200  B67C C000                368      CMP.W #$C000,D3
00001204  6700 01E2                369      BEQ print_sub_and_or    *check if value is AND
00001208                           370      
00001208  B67C D000                371      CMP.W #$D000,D3
0000120C  6700 0132                372      BEQ print_add_adda      *check if value is ADD or ADDA
00001210                           373      
00001210  B67C E000                374      CMP.W #$E000,D3
00001214  6700 0296                375      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001218                           376      
00001218  B67C 7000                377      CMP.W #$7000,D3
0000121C  6700 0094                378      BEQ print_moveq     *check if value is MOVEQ
00001220                           379      
00001220  B47C 1000                380      CMP.W #$1000,D2
00001224  6D00 003E                381      BLT invalid
00001228  B47C 4000                382      CMP.W #$4000,D2
0000122C  6D00 00C8                383      BLT print_move_movea    *check if value is MOVE or MOVEA
00001230                           384      
00001230                           385      * Mask out only the first 8 bits
00001230  3602                     386      MOVE.W D2, D3
00001232  C67C FF00                387      AND.W #$FF00,D3
00001236                           388      
00001236  B67C 4600                389      CMP.W #$4600,D3
0000123A  6700 0324                390      BEQ print_not           *check if value is NOT
0000123E                           391      
0000123E  B67C 4E00                392      CMP.W #$4E00,D3
00001242  6700 0346                393      BEQ print_jsr           *check if value is JSR
00001246                           394      
00001246                           395      * Mask out only the first 4 bits and the 8th bit
00001246  3602                     396      MOVE.W D2,D3
00001248  C67C F100                397      AND.W #$F100, D3
0000124C                           398      
0000124C  B67C 4000                399      CMP.W #$4000, D3
00001250  6700 045E                400      BEQ print_movem         *check if value is MOVEM
00001254                           401      
00001254  B67C 4100                402      CMP.W #$4100, D3
00001258  6700 0346                403      BEQ print_lea           *check if value is LEA
0000125C                           404      
0000125C  B67C 5000                405      CMP.W #$5000,D3
00001260  6700 0362                406      BEQ print_addq          *check if value is ANDQ     
00001264                           407      
00001264                           408      
00001264                           409  invalid 
00001264  43F8 02E8                410      LEA data, A1
00001268  4EB9 00001282            411      JSR print
0000126E  2202                     412      MOVE.L D2, D1
00001270  143C 0010                413      MOVE.B #16, D2
00001274  103C 000F                414      MOVE.B  #15, D0     
00001278  4E4F                     415      TRAP #15
0000127A  4EB9 00001294            416      JSR enter
00001280  4E75                     417  out rts
00001282                           418  
00001282                           419      
00001282                           420  * -------- End of Opcode Section --------*   
00001282                           421  
00001282                           422  * --------- Print Instructions ----------*
00001282                           423  
00001282                           424  
00001282                           425  print:
00001282  4240                     426      CLR D0 
00001284  103C 000E                427      MOVE.B #14,D0
00001288  4E4F                     428      TRAP #15
0000128A  4E75                     429      RTS
0000128C                           430  
0000128C                           431  println:
0000128C  103C 000D                432      MOVE.B #13, D0
00001290  4E4F                     433      TRAP #15
00001292  4E75                     434      RTS
00001294                           435      
00001294                           436  enter: 
00001294  43F8 02E5                437      LEA return, A1
00001298  4EB8 1282                438      JSR print
0000129C  4E75                     439      RTS
0000129E                           440      
0000129E                           441  print_nop
0000129E  43F8 0261                442      LEA nop_ins, A1
000012A2  4EB8 128C                443      JSR println
000012A6  60D8                     444      BRA out
000012A8                           445  
000012A8                           446  print_rts
000012A8  43F8 0265                447      LEA rts_ins, A1
000012AC  4EB8 128C                448      JSR println
000012B0  60CE                     449      BRA out
000012B2                           450      
000012B2                           451  print_moveq
000012B2  43F8 026E                452      lea moveq_ins, A1   *print MOVEQ
000012B6  4EB8 1282                453      jsr print
000012BA  3602                     454      move.w  D2,D3
000012BC  C67C 00FF                455      and.w   #$00FF,D3   * Figure out the immediate address value
000012C0  43F8 02DF                456      lea pound,A1        *print '#'
000012C4  4EB8 1282                457      jsr print
000012C8  43F8 02EF                458      LEA dollar, A1
000012CC  4EB8 1282                459      JSR print
000012D0  3203                     460      move.w  D3,D1
000012D2  3602                     461      MOVE.W D2,D3
000012D4  343C 0010                462      MOVE.W #16, D2
000012D8  103C 000F                463      move.b  #15,D0
000012DC  4E4F                     464      trap    #15         *print immediate address value
000012DE  43F8 02DC                465      lea comma,A1        *print comma
000012E2  4EB8 1282                466      jsr print
000012E6  3403                     467      MOVE.W D3, D2
000012E8  3A02                     468      MOVE.W D2, D5
000012EA  4EB9 0000197A            469      JSR data_reg_sr     *figure out data address
000012F0  4EB8 1294                470      jsr enter           *print out enter
000012F4  608A                     471      bra out
000012F6                           472      
000012F6                           473  print_move_movea
000012F6  3602                     474      MOVE.W D2, D3       
000012F8  C67C 01C0                475      AND.W #$01C0, D3
000012FC  B67C 0040                476      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001300  6700 000E                477      BEQ move_a
00001304  43F8 0269                478      LEA move_ins, A1 *print Instruction 
00001308  4EB8 1282                479      JSR print
0000130C  6000 000A                480      BRA m_size
00001310                           481  move_a          *if instruction is MOVEA
00001310  43F8 027B                482      LEA movea_ins, A1
00001314  4EB8 1282                483      JSR print
00001318                           484  m_size              *determine instruction size
00001318  4EB9 00001794            485      JSR move_size
0000131E  4EB9 000017F6            486      JSR addr        *determine the source address
00001324  43F8 02DC                487      LEA comma, A1   *print comma
00001328  4EB8 1282                488      JSR print
0000132C  4207                     489      CLR.B D7
0000132E  1E3C 0001                490      MOVE.B #1, D7   *determine destination address
00001332  4EB9 000017F6            491      JSR addr
00001338  4EB8 1294                492      JSR enter       *print enter
0000133C  6000 FF42                493      BRA out
00001340                           494      
00001340                           495  print_add_adda
00001340  3602                     496      MOVE.W D2, D3   
00001342  C63C 00C0                497      AND.B #$C0, D3
00001346  B63C 00C0                498      CMP.B #$C0, D3      *determine if ADD or ADDA
0000134A  6700 0052                499      BEQ add_a
0000134E                           500      *if just ADD then print instruction
0000134E  43F8 0281                501      LEA add_ins, A1
00001352  4EB8 1282                502      JSR print
00001356                           503      *print instruction size for ADD
00001356  4EB9 000017DA            504      JSR size
0000135C                           505      *determine direction of ADD, Dn -> EA or EA -> Dn
0000135C  3602                     506      MOVE.W D2,D3
0000135E  C67C 0100                507      AND.W #$0100, D3
00001362  B67C 0100                508      CMP.W #$0100, D3
00001366  6700 001C                509      BEQ ea_dest_add 
0000136A  4EB9 000017F6            510      JSR addr            *if Direction bit is 0
00001370  43F8 02DC                511      LEA comma, A1
00001374  4EB8 1282                512      JSR print
00001378  3A02                     513      MOVE.W D2,D5
0000137A  4EB9 0000197A            514      JSR data_reg_sr
00001380  6000 005E                515      BRA end_add
00001384                           516  ea_dest_add             *if Direction bit is 1
00001384  3A02                     517      MOVE.W D2,D5
00001386  4EB9 0000197A            518      JSR data_reg_sr
0000138C  43F8 02DC                519      LEA comma, A1
00001390  4EB8 1282                520      JSR print
00001394  4EB9 000017F6            521      JSR addr
0000139A  6000 0044                522      BRA end_add
0000139E                           523  add_a                   *if instruction is ADDA
0000139E  43F8 0285                524      LEA adda_ins, A1
000013A2  4EB8 1282                525      JSR print
000013A6                           526      *print instruction size for ADDA (either W or L)
000013A6  3602                     527      MOVE.W D2,D3
000013A8  C67C 0100                528      AND.W #$0100, D3
000013AC  B67C 0100                529      CMP.W #$0100, D3
000013B0  6700 000E                530      BEQ adda_size
000013B4  43F8 0259                531      LEA word, A1
000013B8  4EB8 1282                532      JSR print
000013BC  6000 000E                533      BRA next_add
000013C0                           534  adda_size
000013C0  43F8 0255                535      LEA long,A1
000013C4  4EB8 1282                536      JSR print
000013C8  183C 0080                537      MOVE.B #$80, D4
000013CC                           538  next_add                *print effective address for ADDA
000013CC  4EB9 000017F6            539      JSR addr            
000013D2  43F8 02DC                540      LEA comma, A1
000013D6  4EB8 1282                541      JSR print
000013DA  4EB9 00001992            542      JSR add_reg_sr
000013E0                           543  end_add                 *complete instruction printing by printing enter
000013E0  4EB8 1294                544      JSR enter
000013E4  6000 FE9A                545      BRA out
000013E8                           546  
000013E8                           547  print_sub_and_or
000013E8                           548      *determine if instruction is SUB, AND, or OR.
000013E8  3602                     549      MOVE.W D2, D3
000013EA  C67C F0C0                550      AND.W #$F0C0, D3
000013EE  B67C C0C0                551      CMP.W #$C0C0, D3
000013F2  6700 0090                552      BEQ mul_div
000013F6  B67C 80C0                553      CMP.W #$80C0, D3
000013FA  6700 0088                554      BEQ mul_div
000013FE  C67C F000                555      AND.W #$F000,D3
00001402  B67C 8000                556      CMP.W #$8000, D3
00001406  6700 0028                557      BEQ print_or
0000140A  B67C 9000                558      CMP.W #$9000, D3
0000140E  6700 000A                559      BEQ print_sub
00001412  43F8 0292                560      LEA and_ins, A1
00001416  6000 001C                561      BRA print_instruction
0000141A                           562  print_sub
0000141A  3602                     563      MOVE.W D2, D3
0000141C  C67C 00C0                564      AND.W #$00C0, D3
00001420  B63C 00C0                565      CMP.B #$C0, D3
00001424  6700 FE3E                566      BEQ invalid
00001428  43F8 0296                567      LEA sub_ins, A1
0000142C  6000 0006                568      BRA print_instruction
00001430                           569  print_or
00001430  43F8 028F                570      LEA or_ins, A1
00001434                           571  print_instruction       *print correct instruction
00001434  4EB8 1282                572      JSR print
00001438  4EB9 000017DA            573      JSR size            *print instruction size
0000143E  3602                     574      MOVE.W D2,D3
00001440                           575  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001440  C67C 0100                576      AND.W #$0100, D3
00001444  B67C 0100                577      CMP.W #$0100, D3
00001448  6700 001C                578      BEQ ea_dest_sub_and_or
0000144C  4EB9 000017F6            579      JSR addr            *if Direction bit is 0
00001452  43F8 02DC                580      LEA comma, A1
00001456  4EB8 1282                581      JSR print
0000145A  3A02                     582      MOVE.W D2,D5
0000145C  4EB9 0000197A            583      JSR data_reg_sr
00001462  6000 FF7C                584      BRA end_add
00001466                           585  ea_dest_sub_and_or      *if Direction bit is 1
00001466  3A02                     586      MOVE.W D2,D5
00001468  4EB9 0000197A            587      JSR data_reg_sr
0000146E  43F8 02DC                588      LEA comma, A1
00001472  4EB8 1282                589      JSR print
00001476  4EB9 000017F6            590      JSR addr
0000147C                           591      *complete instruction printing by printing enter
0000147C  4EB8 1294                592      JSR enter
00001480  6000 FDFE                593      BRA out
00001484                           594      
00001484                           595  mul_div             *deal with MULU and DIVU cases
00001484  4283                     596      CLR.L D3
00001486  3602                     597      MOVE.W D2,D3
00001488  C67C 00FF                598      AND.W #$00FF, D3
0000148C  B6BC 000000F8            599      CMP.L #$00F8, D3
00001492  6D00 FDD0                600      BLT invalid
00001496  B6BC 000000F9            601      CMP.L #$00F9, D3
0000149C  6700 0008                602      BEQ mul_div_long
000014A0  544C                     603      ADDA.W #2,A4
000014A2  6000 FDC0                604      BRA invalid
000014A6                           605  mul_div_long
000014A6  584C                     606      ADDA.W #4,A4
000014A8  6000 FDBA                607      BRA invalid
000014AC                           608      
000014AC                           609  print_ls_as_ro
000014AC                           610      *figure out if shift or rotation are memory or register based               
000014AC  3602                     611      MOVE.W D2, D3
000014AE  C63C 00C0                612      AND.B #$C0, D3
000014B2  B63C 00C0                613      CMP.B #$C0, D3
000014B6  6700 0072                614      BEQ ls_as_ro_mem
000014BA  3602                     615      MOVE.W D2, D3
000014BC  E60B                     616      LSR.B #3, D3
000014BE                           617      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000014BE  4EB9 00001762            618      JSR print_correct_shift_rotation
000014C4  4EB9 00001740            619      JSR print_direction     *print direction
000014CA  4EB9 000017DA            620      JSR size                *print size
000014D0  3602                     621      MOVE.W D2, D3
000014D2  C63C 0020                622      AND.B #$20,D3
000014D6  B63C 0020                623      CMP.B #$20, D3
000014DA                           624      *determine if instruction is using immediate address or register
000014DA  6700 0030                625      BEQ ls_as_ro_reg     
000014DE  43F8 02DF                626      LEA pound, A1        *if immediate address print '#'
000014E2  4EB8 1282                627      JSR print
000014E6                           628      *print immediate address rotation value
000014E6  3C02                     629      MOVE.W D2,D6
000014E8  EF5E                     630      ROL.W #7,D6
000014EA  CC7C 0007                631      AND.W #$0007, D6
000014EE  43F8 02EF                632      LEA dollar, A1
000014F2  4EB8 1282                633      JSR print
000014F6  4281                     634      CLR.L D1
000014F8  3206                     635      MOVE.W D6, D1
000014FA  3602                     636      MOVE.W D2, D3
000014FC  143C 0010                637      MOVE.B #16, D2
00001500  103C 000F                638      MOVE.B #15, D0
00001504  4E4F                     639      TRAP #15
00001506  3403                     640      MOVE.W D3,D2
00001508  6000 000A                641      BRA continue_instruction_ls_as_ro
0000150C                           642  ls_as_ro_reg            *if instruction is using register to shift values in another register
0000150C  3A02                     643      MOVE.W D2,D5
0000150E  4EB9 0000197A            644      JSR data_reg_sr
00001514                           645  continue_instruction_ls_as_ro *complete instrcuction
00001514  43F8 02DC                646      LEA comma, A1       *print comma
00001518  4EB8 1282                647      JSR print
0000151C  3A02                     648      MOVE.W D2,D5
0000151E  EE5D                     649      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001520  4EB9 0000197A            650      JSR data_reg_sr     *determine destination data register to perform instruction on
00001526  6000 0030                651      BRA next_ls_as_ro   *finish printing instruction
0000152A                           652  ls_as_ro_mem            *check if immediate address is being shifted or rotated
0000152A  3602                     653      MOVE.W D2, D3
0000152C  C63C 003F                654      AND.B #$3F, D3
00001530  B63C 003C                655      CMP.B #$3C, D3
00001534  6700 FD2E                656      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001538                           657      *if not immediate adress print normally 
00001538  3602                     658      MOVE.W D2, D3
0000153A  EF5B                     659      ROL.W #7, D3    
0000153C  4EB9 00001762            660      JSR print_correct_shift_rotation
00001542  3602                     661      MOVE.W D2,D3
00001544  4EB9 00001740            662      JSR print_direction
0000154A  43F8 0259                663      LEA word, A1
0000154E  4EB8 1282                664      JSR print
00001552  4EB9 000017F6            665      JSR addr
00001558                           666  next_ls_as_ro
00001558  4EB8 1294                667      JSR enter
0000155C  6000 FD22                668      BRA out
00001560                           669      
00001560                           670  print_not
00001560  43F8 02A3                671      LEA not_ins, A1 *print instruction
00001564  4EB8 1282                672      JSR print
00001568  4EB9 000017DA            673      JSR size
0000156E  3602                     674      MOVE.W D2, D3
00001570  C63C 003F                675      AND.B #$3F, D3
00001574  B63C 003C                676      CMP.B #$3C, D3
00001578  6700 FCEA                677      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
0000157C  4EB9 000017F6            678      JSR addr
00001582  4EB8 1294                679      JSR enter
00001586  6000 FCF8                680      BRA out
0000158A                           681  
0000158A                           682  print_jsr
0000158A  43F8 02A7                683      LEA jsr_ins, A1 *print instruction
0000158E  4EB8 1282                684      JSR print
00001592  4EB9 000017F6            685      JSR addr    *print address
00001598  4EB8 1294                686      JSR enter   *print enter (next line)
0000159C  6000 FCE2                687      BRA out
000015A0                           688  
000015A0                           689  print_lea
000015A0  43F8 02AC                690      LEA lea_ins, A1 *print instruction
000015A4  4EB8 1282                691      JSR print   
000015A8  4EB9 000017F6            692      JSR addr    *print address
000015AE  43F8 02DC                693      LEA comma, A1   *print comma
000015B2  4EB8 1282                694      JSR print
000015B6  4EB9 00001992            695      JSR add_reg_sr *print destination address register
000015BC  4EB8 1294                696      JSR enter
000015C0  6000 FCBE                697      BRA out
000015C4                           698  
000015C4                           699  print_addq
000015C4  43F8 028A                700      LEA addq_ins, A1    *print instruction
000015C8  4EB8 1282                701      JSR print
000015CC  4EB9 000017DA            702      JSR size            *print instruction size
000015D2  43F8 02DF                703      LEA pound, A1
000015D6  4EB8 1282                704      JSR print           *print '#' for immediate addressing
000015DA  3C02                     705      MOVE.W D2,D6
000015DC  EF5E                     706      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015DE  CC7C 0007                707      AND.W #$0007, D6
000015E2  4EB9 0000196E            708      JSR Xn
000015E8  43F8 02DC                709      LEA comma, A1       *print comma
000015EC  4EB8 1282                710      JSR print
000015F0  4EB9 000017F6            711      JSR addr            *print destination address
000015F6  4EB8 1294                712      JSR enter
000015FA  6000 FC84                713      BRA out
000015FE                           714  
000015FE                           715  print_bra_bcc           *needs comments
000015FE  3602                     716      MOVE.W D2,D3
00001600  C67C 0F00                717      AND.W #$0F00, D3
00001604  B67C 0000                718      CMP.W #$0000, D3
00001608  6700 001E                719      BEQ print_bra
0000160C  B67C 0700                720      CMP.W #$0700, D3
00001610  6700 0022                721      BEQ print_beq
00001614  B67C 0E00                722      CMP.W #$0E00, D3
00001618  6700 0032                723      BEQ print_bgt
0000161C  B67C 0F00                724      CMP.W #$0F00, D3
00001620  6700 001E                725      BEQ print_ble
00001624  6000 FC3E                726      BRA invalid
00001628                           727  print_bra
00001628  43F8 02C2                728      LEA bra_ins, A1
0000162C  4EB8 1282                729      JSR print
00001630  6000 0022                730      BRA next_bra_bcc
00001634                           731  print_beq
00001634  43F8 02BE                732      LEA beq_ins, A1
00001638  4EB8 1282                733      JSR print
0000163C  6000 0016                734      BRA next_bra_bcc
00001640                           735  print_ble
00001640  43F8 02BA                736      LEA ble_ins, A1
00001644  4EB8 1282                737      JSR print
00001648  6000 000A                738      BRA next_bra_bcc
0000164C                           739  print_bgt
0000164C  43F8 02B6                740      LEA bgt_ins, A1
00001650  4EB8 1282                741      JSR print
00001654                           742  next_bra_bcc
00001654  3602                     743      MOVE.W D2, D3
00001656  C67C 00FF                744      AND.W #$00FF, D3
0000165A  B67C 0000                745      CMP.W #$0000, D3
0000165E  6700 0026                746      BEQ check_word
00001662  43F8 025D                747      LEA byte, A1
00001666  4EB8 1282                748      JSR print
0000166A  43F8 02EF                749      LEA dollar, A1
0000166E  4EB8 1282                750      JSR print
00001672  3203                     751      MOVE.W D3, D1
00001674  3602                     752      MOVE.W D2, D3
00001676  343C 0010                753      MOVE.W #16, D2
0000167A  303C 000F                754      MOVE.W #15,D0
0000167E  4E4F                     755      trap #15            *print immediate address value
00001680  3403                     756      MOVE.W D3, D2
00001682  6000 0024                757      BRA end_bra_bcc
00001686                           758  check_word
00001686  43F8 0259                759      LEA word, A1
0000168A  4EB8 1282                760      JSR print
0000168E  43F8 02EF                761      LEA dollar, A1
00001692  4EB8 1282                762      JSR print
00001696  544C                     763      ADDA.W #2,A4        *update current address
00001698  3214                     764      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000169A  3602                     765      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000169C  343C 0010                766      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
000016A0  103C 000F                767      MOVE.B #15, D0      *use trap instruction that allows use of base 16
000016A4  4E4F                     768      TRAP #15
000016A6  3403                     769      MOVE.W D3,D2        *copy opcode back to register D2
000016A8                           770  end_bra_bcc
000016A8  4EB8 1294                771      JSR enter
000016AC  6000 FBD2                772      BRA out
000016B0                           773  
000016B0                           774  print_movem         *needs comments
000016B0  43F8 0275                775      LEA movem_ins, A1
000016B4  4EB8 1282                776      JSR print
000016B8  3602                     777      MOVE.W D2,D3
000016BA  C67C 0040                778      AND.W #$0040,D3
000016BE  B67C 0040                779      CMP.W #$0040,D3
000016C2  6700 000E                780      BEQ movem_long
000016C6  43F8 0259                781      LEA word, A1
000016CA  4EB8 1282                782      JSR print
000016CE  6000 000A                783      BRA movem_direction
000016D2                           784  movem_long
000016D2  43F8 0255                785      LEA long, A1
000016D6  4EB8 1282                786      JSR print
000016DA                           787  movem_direction
000016DA  3602                     788      MOVE.W D2,D3
000016DC  C67C 0400                789      AND.W #$0400,D3
000016E0  B67C 0400                790      CMP.W #$0400,D3
000016E4  6700 001A                791      BEQ mem_to_reg
000016E8  4EB9 0000171C            792      JSR movem_check_pre_post
000016EE  43F8 02DC                793      LEA comma, A1
000016F2  4EB8 1282                794      JSR print
000016F6  4EB9 000017F6            795      JSR addr
000016FC  6000 0016                796      BRA end_movem
00001700                           797  mem_to_reg
00001700  4EB9 000017F6            798      JSR addr
00001706  43F8 02DC                799      LEA comma, A1
0000170A  4EB8 1282                800      JSR print
0000170E  4EB9 0000171C            801      JSR movem_check_pre_post
00001714                           802  end_movem
00001714  4EB8 1294                803      JSR enter
00001718  6000 FB66                804      BRA out
0000171C                           805      
0000171C                           806  movem_check_pre_post:
0000171C  3602                     807      MOVE.W D2, D3
0000171E  C67C 0038                808      AND.W #$0038, D3
00001722  B67C 0020                809      CMP.W #$0020, D3
00001726  6700 000C                810      BEQ movem_check_pre
0000172A  4EB9 00001A5A            811      JSR movem_postinc
00001730  6000 0008                812      BRA movem_check_done
00001734                           813  movem_check_pre
00001734  4EB9 000019AA            814      JSR movem_predec
0000173A                           815  movem_check_done
0000173A  4287                     816      CLR.L D7
0000173C  4281                     817      CLR.L D1
0000173E  4E75                     818      RTS
00001740                           819  
00001740                           820  print_direction:
00001740                           821  *print correct direction given direction bit
00001740  C67C 0100                822      AND.W #$0100, D3
00001744  B67C 0100                823      CMP.W #$0100, D3
00001748  6700 000E                824      BEQ print_left  *print left
0000174C  43F8 02C6                825      LEA right, A1
00001750  4EB8 1282                826      JSR print
00001754  6000 FB2A                827      BRA out
00001758                           828  print_left
00001758  43F8 02C8                829      LEA left, A1
0000175C  4EB8 1282                830      JSR print *print right
00001760  4E75                     831      RTS
00001762                           832      
00001762                           833  print_correct_shift_rotation:
00001762                           834  *determine if instruction is logical, arithmetic, or rotation 
00001762  C63C 0003                835      AND.B #$03, D3
00001766  B63C 0000                836      CMP.B #$00, D3
0000176A  6700 0016                837      BEQ print_as
0000176E  B63C 0001                838      CMP.B #$01, D3
00001772  6700 0016                839      BEQ print_ls
00001776  B63C 0003                840      CMP.B #$03, D3
0000177A  43F8 02A0                841      LEA ro_ins, A1  print rotation
0000177E  6000 000E                842      BRA print_it
00001782                           843  print_as
00001782  43F8 029D                844      LEA as_ins, A1  print arithmetic shift
00001786  6000 0006                845      BRA print_it
0000178A                           846  print_ls
0000178A  43F8 029A                847      LEA ls_ins, A1 print logical shift
0000178E                           848  print_it
0000178E  4EB8 1282                849      JSR print
00001792  4E75                     850      RTS
00001794                           851  * --------- End Print Instruction ----------*
00001794                           852  
00001794                           853  * ------- Instruction sizes ---------*
00001794                           854  
00001794                           855  move_size:  *print size for MOVE and MOVEA instruction
00001794  4284                     856      CLR.L D4
00001796  3802                     857      MOVE.W D2, D4
00001798  C87C 3000                858      AND.W #$3000, D4
0000179C  B87C 1000                859      CMP.W #$1000, D4
000017A0  6700 0014                860      BEQ print_b
000017A4  B87C 3000                861      CMP.W #$3000, D4
000017A8  6700 0018                862      BEQ print_w
000017AC  B87C 2000                863      CMP.W #$2000, D4
000017B0  6700 001C                864      BEQ print_l
000017B4  4E75                     865      RTS
000017B6                           866      
000017B6                           867  print_b     *print '.B'
000017B6  43F8 025D                868      LEA byte, A1
000017BA  4EB8 1282                869      JSR print
000017BE  6000 FAC0                870      BRA out
000017C2                           871      
000017C2                           872  print_w     *print '.W'
000017C2  43F8 0259                873      LEA word, A1
000017C6  4EB8 1282                874      JSR print
000017CA  6000 FAB4                875      BRA out
000017CE                           876      
000017CE                           877  print_l:    *print '.L'
000017CE  43F8 0255                878      LEA long, A1
000017D2  4EB8 1282                879      JSR print
000017D6  6000 FAA8                880      BRA out
000017DA                           881  
000017DA                           882  size:       *print size for non "move" instructions
000017DA  4284                     883      CLR.L D4
000017DC  1802                     884      MOVE.B D2,D4
000017DE  C83C 00C0                885      AND.B #$C0, D4
000017E2  B83C 0000                886      CMP.B #$00, D4
000017E6  67CE                     887      BEQ print_b
000017E8  B83C 0040                888      CMP.B #$40,D4
000017EC  67D4                     889      BEQ print_w
000017EE  B83C 0080                890      CMP.B #$80, D4
000017F2  67DA                     891      BEQ print_l
000017F4  4E75                     892      RTS
000017F6                           893      
000017F6                           894  * ------- End Instruction sizes ---------*
000017F6                           895  
000017F6                           896  * ------- Effective Address -------*
000017F6                           897  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000017F6  3A02                     898      MOVE.W D2, D5
000017F8  3C02                     899      MOVE.W D2, D6               
000017FA  BE3C 0001                900      CMP.B #1, D7
000017FE  6700 003A                901      BEQ destination *check if evaluating destination address (used for MOVE)
00001802                           902  cont
00001802  CC3C 0038                903      AND.B #$38, D6
00001806  BC3C 0000                904      CMP.B #0, D6
0000180A  6700 0038                905      BEQ data_reg        *check if EA mode is data register
0000180E  BC3C 0008                906      CMP.B #$08, D6
00001812  6700 0048                907      BEQ add_reg         *check if EA mode is address register
00001816  BC3C 0010                908      CMP.B #$10, D6
0000181A  6700 0058                909      BEQ add_indirect    *check if EA mode is address indirect
0000181E  BC3C 0018                910      CMP.B #$18, D6
00001822  6700 0070                911      BEQ post_increment  *check if EA mode is post increment
00001826  BC3C 0020                912      CMP.B #$20, D6
0000182A  6700 0088                913      BEQ pre_decrement   *check if EA mode is pre_decrement
0000182E  BC3C 0038                914      CMP.B #$38, D6
00001832  6700 00A0                915      BEQ absolute_or_immediate
00001836  6000 FA48                916      BRA out *needs Immediate, Abs Long, and Abs Word
0000183A                           917  destination     *perform correct rotation to retrieve destination address
0000183A  3C05                     918      MOVE.W D5,D6
0000183C  EF5D                     919      ROL.W #7,D5
0000183E  E64E                     920      LSR.W #3,D6
00001840  60C0                     921      BRA cont
00001842  4E75                     922      RTS
00001844                           923  
00001844                           924  data_reg    *used with addr sub routine
00001844  3C05                     925      MOVE.W D5,D6    
00001846  CC3C 0007                926      AND.B #$07, D6  
0000184A  43F8 02CA                927      LEA D_reg, A1   
0000184E  4EB8 1282                928      JSR print
00001852  4EB9 0000196E            929      JSR Xn
00001858  6000 FA26                930      BRA out
0000185C                           931  
0000185C                           932  add_reg     *used with addr sub routine
0000185C  3C05                     933      MOVE.W D5,D6    
0000185E  CC3C 0007                934      AND.B #$07, D6
00001862  43F8 02CC                935      LEA A_reg, A1   
00001866  4EB8 1282                936      JSR print
0000186A  4EB9 0000196E            937      JSR Xn
00001870  6000 FA0E                938      BRA out
00001874                           939      
00001874                           940  add_indirect    *used with addr sub routine
00001874  3C05                     941      MOVE.W D5,D6    
00001876  CC3C 0007                942      AND.B #$07, D6
0000187A  43F8 02CE                943      LEA open_paran, A1  
0000187E  4EB8 1282                944      JSR print
00001882  4EB9 0000196E            945      JSR Xn
00001888  43F8 02D1                946      LEA close_paran, A1 
0000188C  4EB8 1282                947      JSR print
00001890  6000 F9EE                948      BRA out
00001894                           949      
00001894                           950  post_increment  *used with addr sub routine
00001894  3C05                     951      MOVE.W D5,D6    
00001896  CC3C 0007                952      AND.B #$07, D6
0000189A  43F8 02CE                953      LEA open_paran, A1  
0000189E  4EB8 1282                954      JSR print
000018A2  4EB9 0000196E            955      JSR Xn
000018A8  43F8 02D3                956      LEA post_inc, A1    
000018AC  4EB8 1282                957      JSR print
000018B0  6000 F9CE                958      BRA out
000018B4                           959      
000018B4                           960  pre_decrement   *used with addr sub routine
000018B4  3C05                     961      MOVE.W D5,D6    
000018B6  CC3C 0007                962      AND.B #$07, D6
000018BA  43F8 02D6                963      LEA pre_dec, A1 
000018BE  4EB8 1282                964      JSR print
000018C2  4EB9 0000196E            965      JSR Xn
000018C8  43F8 02D1                966      LEA close_paran, A1 
000018CC  4EB8 1282                967      JSR print
000018D0  6000 F9AE                968      BRA out
000018D4                           969  
000018D4                           970  absolute_or_immediate *check if EA is immediate or absolute address
000018D4  3C05                     971      MOVE.W D5,D6    
000018D6  CC3C 0007                972      AND.B #$07, D6
000018DA  BC3C 0000                973      CMP.B #$00, D6
000018DE  6700 0054                974      BEQ w_imm
000018E2  BC3C 0001                975      CMP.B #$01, D6
000018E6  6700 0068                976      BEQ l_imm
000018EA  BC3C 0004                977      CMP.B #04, D6
000018EE  6700 0002                978      BEQ immediate
000018F2                           979      
000018F2                           980  immediate
000018F2  43F8 02DF                981      LEA pound, A1
000018F6  4EB8 1282                982      JSR print
000018FA  B4BC 00004000            983      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
00001900  6D00 0016                984      BLT move_movea      *check if instruction is move or movea
00001904  B8BC 00000040            985      CMP.L #$0040, D4        *if not move or movea
0000190A  6F00 0028                986      BLE w_imm           *byte and word check the next 2 addresses in mem
0000190E  B8BC 00000080            987      CMP.L #$0080, D4
00001914  6700 003A                988      BEQ l_imm           *long checks the next 4 addresses in mem
00001918                           989  move_movea              *similar comparisons, but for different bits in OPCODE
00001918  B87C 1000                990      CMP.W #$1000, D4
0000191C  6700 0016                991      BEQ w_imm
00001920  B87C 3000                992      CMP.W #$3000, D4
00001924  6700 000E                993      BEQ w_imm
00001928  B87C 2000                994      CMP.W #$2000, D4
0000192C  6700 0022                995      BEQ l_imm
00001930                           996  imm_complete
00001930  6000 F94E                997      BRA out
00001934                           998      
00001934                           999  w_imm
00001934  43F8 02EF               1000      LEA dollar, A1      *print '$'
00001938  4EB8 1282               1001      JSR print
0000193C  544C                    1002      ADDA.W #2,A4        *update current address
0000193E  3214                    1003      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001940  3602                    1004      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001942  343C 0010               1005      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001946  103C 000F               1006      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000194A  4E4F                    1007      TRAP #15
0000194C  3403                    1008      MOVE.W D3,D2        *copy opcode back to register D2
0000194E  60E0                    1009      BRA imm_complete    *exit addr subroutine
00001950                          1010      
00001950                          1011  l_imm
00001950  43F8 02EF               1012      LEA dollar, A1      *print '$'
00001954  4EB8 1282               1013      JSR print
00001958  544C                    1014      ADDA.W  #2,A4       *update current address
0000195A  2214                    1015      MOVE.L (A4),D1      *retrieve long data stored in the new current address
0000195C  3602                    1016      MOVE.W D2, D3
0000195E  343C 0010               1017      MOVE.W #16, D2
00001962  103C 000F               1018      MOVE.B #15, D0
00001966  4E4F                    1019      TRAP #15
00001968  3403                    1020      MOVE.W D3,D2
0000196A  544C                    1021      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
0000196C  60C2                    1022      BRA imm_complete    *exit addr subroutine
0000196E                          1023  
0000196E                          1024  Xn:                     *retieve signed decimal value of data stored in register D6
0000196E  4281                    1025      CLR.L D1
00001970  1206                    1026      MOVE.B D6,D1
00001972  103C 0003               1027      MOVE.B #3, D0
00001976  4E4F                    1028      TRAP #15
00001978  4E75                    1029      RTS
0000197A                          1030  
0000197A                          1031  data_reg_sr:    *use if dealing with Dn only
0000197A  4286                    1032      CLR.L D6
0000197C  3C05                    1033      MOVE.W D5,D6
0000197E  EF5E                    1034      ROL.W #7,D6
00001980  CC3C 0007               1035      AND.B #$07, D6  
00001984  43F8 02CA               1036      LEA D_reg, A1   
00001988  4EB8 1282               1037      JSR print
0000198C  4EB8 196E               1038      JSR Xn
00001990  4E75                    1039      RTS
00001992                          1040      
00001992                          1041  add_reg_sr:     *use if dealing with An only
00001992  4286                    1042      CLR.L D6
00001994  3C02                    1043      MOVE.W D2,D6
00001996  EF5E                    1044      ROL.W #7,D6
00001998  CC3C 0007               1045      AND.B #$07, D6  
0000199C  43F8 02CC               1046      LEA A_reg, A1   
000019A0  4EB8 1282               1047      JSR print
000019A4  4EB8 196E               1048      JSR Xn
000019A8  4E75                    1049      RTS
000019AA                          1050      
000019AA                          1051  movem_predec:           *needs to be worked on
000019AA  4285                    1052      CLR.L D5
000019AC  544C                    1053      ADDA.W  #2,A4       *update current address
000019AE  3A14                    1054      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019B0  3C05                    1055      MOVE.W D5,D6
000019B2  4281                    1056      CLR.L D1
000019B4  4287                    1057      CLR.L D7
000019B6  BA3C 0000               1058      CMP.B #$00, D5
000019BA  6700 005E               1059      BEQ predec_skip_to_d
000019BE  E14E                    1060      LSL #8, D6
000019C0                          1061  predec_loop_a   
000019C0  E34E                    1062      LSL #1, D6
000019C2  6400 0006               1063      BCC predec_inc_loop_a
000019C6  6000 000E               1064      BRA predec_check_first_a
000019CA                          1065  predec_inc_loop_a
000019CA  5201                    1066      ADD.B #1, D1
000019CC  B23C 0008               1067      CMP.B #8, D1
000019D0  66EE                    1068      BNE predec_loop_a
000019D2  6000 0038               1069      BRA predec_loop_a_done  
000019D6                          1070  predec_check_first_a
000019D6  BE3C 0000               1071      CMP.B #0, D7
000019DA  6700 000A               1072      BEQ predec_first_a
000019DE  43F8 02E3               1073      LEA slash, A1
000019E2  4EB8 1282               1074      JSR print
000019E6                          1075  predec_first_a
000019E6  43F8 02CC               1076      LEA A_reg, A1
000019EA  4EB8 1282               1077      JSR print
000019EE  103C 0003               1078      MOVE.B #3, D0
000019F2  4E4F                    1079      TRAP #15
000019F4  5201                    1080      ADD.B #1, D1
000019F6  5207                    1081      ADD.B #1, D7
000019F8  B23C 0008               1082      CMP.B #8, D1
000019FC  66C2                    1083      BNE predec_loop_a
000019FE  3C05                    1084      MOVE.W D5,D6
00001A00  CC7C FF00               1085      AND.W #$FF00, D6
00001A04  BC7C 0000               1086      CMP.W #$00, D6
00001A08  6700 004E               1087      BEQ end_movem_predec
00001A0C                          1088  predec_loop_a_done
00001A0C  3C05                    1089      MOVE.W D5,D6
00001A0E  43F8 02E3               1090      LEA slash, A1
00001A12  4EB8 1282               1091      JSR print
00001A16  4281                    1092      CLR.L D1
00001A18  4287                    1093      CLR.L D7
00001A1A                          1094  predec_skip_to_d
00001A1A                          1095  predec_loop_d   
00001A1A  E34E                    1096      LSL #1, D6
00001A1C  6400 0006               1097      BCC predec_inc_loop_d
00001A20  6000 000E               1098      BRA predec_check_first_d
00001A24                          1099  predec_inc_loop_d
00001A24  5201                    1100      ADD.B #1, D1
00001A26  B23C 0008               1101      CMP.B #8, D1
00001A2A  66EE                    1102      BNE predec_loop_d   
00001A2C  6000 002A               1103      BRA end_movem_predec
00001A30                          1104  predec_check_first_d
00001A30  BE3C 0000               1105      CMP.B #0, D7
00001A34  6700 000A               1106      BEQ predec_first_d
00001A38  43F8 02E3               1107      LEA slash, A1
00001A3C  4EB8 1282               1108      JSR print
00001A40                          1109  predec_first_d
00001A40  43F8 02CA               1110      LEA D_reg, A1
00001A44  4EB8 1282               1111      JSR print
00001A48  103C 0003               1112      MOVE.B #3, D0
00001A4C  4E4F                    1113      TRAP #15
00001A4E  5201                    1114      ADD.B #1, D1
00001A50  5207                    1115      ADD.B #1, D7
00001A52  B23C 0008               1116      CMP.B #8, D1
00001A56  66C2                    1117      BNE predec_loop_d
00001A58                          1118  end_movem_predec
00001A58  4E75                    1119      RTS
00001A5A                          1120      
00001A5A                          1121  movem_postinc:          *needs to be worked on
00001A5A  4285                    1122      CLR.L D5
00001A5C  544C                    1123      ADDA.W  #2,A4       *update current address
00001A5E  3A14                    1124      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A60  3C05                    1125      MOVE.W D5,D6
00001A62  4281                    1126      CLR.L D1
00001A64  4287                    1127      CLR.L D7
00001A66  3C05                    1128      MOVE.W D5,D6
00001A68  CC7C FF00               1129      AND.W #$FF00, D6
00001A6C  BC7C 0000               1130      CMP.W #$00, D6
00001A70  6700 0058               1131      BEQ postinc_skip_to_d
00001A74  E04E                    1132      LSR #8, D6
00001A76                          1133  postinc_loop_a  
00001A76  E24E                    1134      LSR #1, D6
00001A78  6400 0006               1135      BCC postinc_inc_loop_a
00001A7C  6000 000E               1136      BRA postinc_check_first_a
00001A80                          1137  postinc_inc_loop_a
00001A80  5201                    1138      ADD.B #1, D1
00001A82  B23C 0008               1139      CMP.B #8, D1
00001A86  66EE                    1140      BNE postinc_loop_a
00001A88  6000 0032               1141      BRA postinc_loop_a_done 
00001A8C                          1142  postinc_check_first_a
00001A8C  BE3C 0000               1143      CMP.B #0, D7
00001A90  6700 000A               1144      BEQ postinc_first_a
00001A94  43F8 02E3               1145      LEA slash, A1
00001A98  4EB8 1282               1146      JSR print
00001A9C                          1147  postinc_first_a
00001A9C  43F8 02CC               1148      LEA A_reg, A1
00001AA0  4EB8 1282               1149      JSR print
00001AA4  103C 0003               1150      MOVE.B #3, D0
00001AA8  4E4F                    1151      TRAP #15
00001AAA  5201                    1152      ADD.B #1, D1
00001AAC  5207                    1153      ADD.B #1, D7
00001AAE  B23C 0008               1154      CMP.B #8, D1
00001AB2  66C2                    1155      BNE postinc_loop_a
00001AB4  BA3C 0000               1156      CMP.B #$00, D5
00001AB8  6700 0050               1157      BEQ end_movem_postinc
00001ABC                          1158  postinc_loop_a_done
00001ABC  3C05                    1159      MOVE.W D5,D6
00001ABE  43F8 02E3               1160      LEA slash, A1
00001AC2  4EB8 1282               1161      JSR print
00001AC6  4281                    1162      CLR.L D1
00001AC8  4287                    1163      CLR.L D7
00001ACA                          1164  postinc_skip_to_d
00001ACA  3C05                    1165      MOVE.W D5,D6
00001ACC                          1166  postinc_loop_d  
00001ACC  E24E                    1167      LSR #1, D6
00001ACE  6400 0006               1168      BCC postinc_inc_loop_d
00001AD2  6000 000E               1169      BRA postinc_check_first_d
00001AD6                          1170  postinc_inc_loop_d
00001AD6  5201                    1171      ADD.B #1, D1
00001AD8  B23C 0008               1172      CMP.B #8, D1
00001ADC  66EE                    1173      BNE postinc_loop_d  
00001ADE  6000 002A               1174      BRA end_movem_postinc
00001AE2                          1175  postinc_check_first_d
00001AE2  BE3C 0000               1176      CMP.B #0, D7
00001AE6  6700 000A               1177      BEQ postinc_first_d
00001AEA  43F8 02E3               1178      LEA slash, A1
00001AEE  4EB8 1282               1179      JSR print
00001AF2                          1180  postinc_first_d
00001AF2  43F8 02CA               1181      LEA D_reg, A1
00001AF6  4EB8 1282               1182      JSR print
00001AFA  103C 0003               1183      MOVE.B #3, D0
00001AFE  4E4F                    1184      TRAP #15
00001B00  5201                    1185      ADD.B #1, D1
00001B02  5207                    1186      ADD.B #1, D7
00001B04  B23C 0008               1187      CMP.B #8, D1
00001B08  66C2                    1188      BNE postinc_loop_d
00001B0A                          1189  end_movem_postinc
00001B0A  4E75                    1190      RTS
00001B0C                          1191  
00001B0C                          1192  
00001B0C                          1193  * ------- End Effective Address -------*
00001B0C                          1194  
00001B0C                          1195  * ----- Hex to ASCII & ASCII to HEX -----*
00001B0C                          1196  
00001B0C                          1197  ASCIItoHex:
00001B0C  4EB9 00001B1A           1198          jsr     ASCII2Hex_init  
00001B12  4EB9 00001B20           1199          jsr     conversion_loop
00001B18  4E75                    1200          rts                    
00001B1A                          1201  
00001B1A                          1202  ASCII2Hex_init:   
00001B1A  143C 0000               1203          move.b  #0,D2       *set up counter    
00001B1E  4E75                    1204          rts         
00001B20                          1205          
00001B20                          1206  conversion_loop:            
00001B20  5282                    1207          add.l   #1,D2       *increment counter
00001B22  B4BC 00000009           1208          cmp.l   #9,D2       *ends at 9
00001B28  6700 004A               1209          BEQ     DONE        *branch when compare is true
00001B2C  1819                    1210          move.b  (A1)+,D4    *Get first num
00001B2E                          1211          
00001B2E  B83C 0040               1212          cmp.b   #$40,D4        
00001B32  6E00 000C               1213          bgt     Letters_Cap  
00001B36                          1214          
00001B36  B83C 0039               1215          cmp.b   #$39,D4
00001B3A  6F00 0016               1216          BLE     Numbers      
00001B3E  4E75                    1217          rts
00001B40                          1218          
00001B40                          1219  Letters_Cap:      
00001B40  B83C 0046               1220          cmp.b   #$46,D4          
00001B44  6E00 001E               1221          bgt     ERROR  
00001B48  0404 0037               1222          sub.b   #$37,D4     
00001B4C  E986                    1223          asl.l   #4,D6       
00001B4E  DC84                    1224          add.l   D4,D6     
00001B50  60CE                    1225          bra     conversion_loop 
00001B52                          1226  Numbers:
00001B52  B83C 0030               1227          cmp.b   #$30,D4         
00001B56  6D00 000C               1228          blt     ERROR        
00001B5A  0404 0030               1229          sub.b   #$30,D4      
00001B5E  E986                    1230          asl.l   #4,D6        
00001B60  DC84                    1231          add.l   D4,D6     
00001B62  60BC                    1232          bra     conversion_loop
00001B64                          1233          
00001B64                          1234  ERROR:
00001B64  43F8 011E               1235          lea     ErrorMsg,A1    
00001B68  103C 000E               1236          move.b  #14,D0
00001B6C  4E4F                    1237          trap    #15
00001B6E                          1238      
00001B6E  103C 0009               1239          move.b  #9,D0
00001B72  4E4F                    1240          trap    #15
00001B74                          1241          
00001B74                          1242  DONE:
00001B74                          1243     
00001B74  4241                    1244          clr     D1
00001B76  4242                    1245          clr     D2
00001B78  4244                    1246          clr     D4
00001B7A                          1247      
00001B7A  43F8 014F               1248          lea     ASCIItoHexMsg,A1
00001B7E  103C 000E               1249          move.b  #14,D0
00001B82  4E4F                    1250          trap    #15
00001B84                          1251  
00001B84  4E75                    1252          rts
00001B86                          1253          
00001B86                          1254  
00001B86                          1255          
00001B86                          1256  * -- End of Hex to ASCII & ASCII to HEX --*
00001B86                          1257  
00001B86                          1258  * Put program code here
00001B86                          1259  
00001B86  FFFF FFFF               1260      SIMHALT             ; halt simulator
00001B8A                          1261  
00001B8A                          1262  * Put variables and constants here
00001B8A                          1263  
00001B8A                          1264      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  18D4
ADDA_INS            285
ADDA_SIZE           13C0
ADDQ_INS            28A
ADDR                17F6
ADD_A               139E
ADD_INDIRECT        1874
ADD_INS             281
ADD_REG             185C
ADD_REG_SR          1992
ANDQ_INS            2B1
AND_INS             292
ASCII2HEX_INIT      1B1A
ASCIITOHEX          1B0C
ASCIITOHEXMSG       14F
AS_INS              29D
A_REG               2CC
BEQ_INS             2BE
BGT_INS             2B6
BLE_INS             2BA
BRA_INS             2C2
BYTE                25D
CHECK_WORD          1686
CLEARDONE           1106
CLEARSCREEN         10D8
CLEARSCREEN_40      10EE
CLEAR_REGISTERS     1044
CLOSE_PARAN         2D1
COMMA               2DC
CONT                1802
CONTINUEORNOTMSG    20F
CONTINUE_INSTRUCTION_LS_AS_RO  1514
CONVERSION_LOOP     1B20
CR                  D
CREATORS            1F
DASH                2E1
DATA                2E8
DATA_REG            1844
DATA_REG_SR         197A
DESTINATION         183A
DOLLAR              2EF
DONE                1B74
D_REG               2CA
EA_DEST_ADD         1384
EA_DEST_SUB_AND_OR  1466
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13E0
END_BRA_BCC         16A8
END_MOVEM           1714
END_MOVEM_POSTINC   1B0A
END_MOVEM_PREDEC    1A58
ENTER               1294
ENTER_PRESS_TRUE    11CA
ERROR               1B64
ERRORMSG            11E
EXITMSG             245
FLUSHSCREEN         11A6
FLUSHSCREENMSG      199
FLUSHSCREEN_INPUT   11B8
GETENDADDRESS       10B8
GETSTARTADDRESS     1098
HELPMSG             1D3
HEXTOASCIIMSG       12D
IMMEDIATE           18F2
IMM_COMPLETE        1930
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             1264
JSR_INS             2A7
LEA_INS             2AC
LEFT                2C8
LETTERS_CAP         1B40
LF                  A
LONG                255
LS_AS_RO_MEM        152A
LS_AS_RO_REG        150C
LS_INS              29A
L_IMM               1950
MEMSEARCH           1108
MEMSEARCHLOOP       111C
MEMSEARCH_DONE      1156
MEM_TO_REG          1700
MENU                1080
MOVEA_INS           27B
MOVEM_CHECK_DONE    173A
MOVEM_CHECK_PRE     1734
MOVEM_CHECK_PRE_POST  171C
MOVEM_DIRECTION     16DA
MOVEM_INS           275
MOVEM_LONG          16D2
MOVEM_POSTINC       1A5A
MOVEM_PREDEC        19AA
MOVEQ_INS           26E
MOVE_A              1310
MOVE_INS            269
MOVE_MOVEA          1918
MOVE_SIZE           1794
MUL_DIV             1484
MUL_DIV_LONG        14A6
M_SIZE              1318
NEXT_ADD            13CC
NEXT_BRA_BCC        1654
NEXT_LS_AS_RO       1558
NOP_INS             261
NOT_INS             2A3
NUMBERS             1B52
OPCODE_DECODE       11CC
OPEN_PARAN          2CE
OR_INS              28F
OUT                 1280
POSTINC_CHECK_FIRST_A  1A8C
POSTINC_CHECK_FIRST_D  1AE2
POSTINC_FIRST_A     1A9C
POSTINC_FIRST_D     1AF2
POSTINC_INC_LOOP_A  1A80
POSTINC_INC_LOOP_D  1AD6
POSTINC_LOOP_A      1A76
POSTINC_LOOP_A_DONE  1ABC
POSTINC_LOOP_D      1ACC
POSTINC_SKIP_TO_D   1ACA
POST_INC            2D3
POST_INCREMENT      1894
POUND               2DF
PREDEC_CHECK_FIRST_A  19D6
PREDEC_CHECK_FIRST_D  1A30
PREDEC_FIRST_A      19E6
PREDEC_FIRST_D      1A40
PREDEC_INC_LOOP_A   19CA
PREDEC_INC_LOOP_D   1A24
PREDEC_LOOP_A       19C0
PREDEC_LOOP_A_DONE  1A0C
PREDEC_LOOP_D       1A1A
PREDEC_SKIP_TO_D    1A1A
PRE_DEC             2D6
PRE_DECREMENT       18B4
PRINT               1282
PRINTLN             128C
PRINT_ADDQ          15C4
PRINT_ADD_ADDA      1340
PRINT_AS            1782
PRINT_B             17B6
PRINT_BEQ           1634
PRINT_BGT           164C
PRINT_BLE           1640
PRINT_BRA           1628
PRINT_BRA_BCC       15FE
PRINT_CORRECT_SHIFT_ROTATION  1762
PRINT_DIRECTION     1740
PRINT_INSTRUCTION   1434
PRINT_IT            178E
PRINT_JSR           158A
PRINT_L             17CE
PRINT_LEA           15A0
PRINT_LEFT          1758
PRINT_LS            178A
PRINT_LS_AS_RO      14AC
PRINT_MOVEM         16B0
PRINT_MOVEQ         12B2
PRINT_MOVE_MOVEA    12F6
PRINT_NOP           129E
PRINT_NOT           1560
PRINT_OR            1430
PRINT_RTS           12A8
PRINT_SUB           141A
PRINT_SUB_AND_OR    13E8
PRINT_W             17C2
RETURN              2E5
RIGHT               2C6
RO_INS              2A0
RTS_INS             265
SCREENFLUSH_CHECK   119C
SIZE                17DA
SLASH               2E3
SPACE               2DA
START               1000
STARTINGMSG         0
SUB_INS             296
TAB                 9
WORD                259
W_IMM               1934
XN                  196E
