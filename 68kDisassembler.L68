00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/29/2020 9:54:44 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 49 6E 70 75 74 73 ...     23  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
000001CC= 57 6F 75 6C 64 20 ...     24  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
000001EF= 45 78 69 74 69 6E ...     25  ExitMsg             dc.b    'Exiting Program',0
000001FF                            26  
000001FF                            27  START_ADDR_BUFFER  DS.B    256
000002FF                            28  END_ADDR_BUFFER    DS.B    256
000003FF                            29  
000003FF                            30  *size
000003FF= 2E 4C 20 00               31  long                DC.B    '.L ',0
00000403= 2E 57 20 00               32  word                DC.B    '.W ',0
00000407= 2E 42 20 00               33  byte                DC.B    '.B ',0
0000040B                            34  
0000040B                            35  *instructions
0000040B= 4E 4F 50 00               36  nop_ins             DC.B    'NOP',0
0000040F= 52 54 53 00               37  rts_ins             DC.B    'RTS',0
00000413= 4D 4F 56 45 00            38  move_ins            DC.B    'MOVE',0
00000418= 4D 4F 56 45 51 20 00      39  moveq_ins           DC.B    'MOVEQ ',0
0000041F= 4D 4F 56 45 4D 00         40  movem_ins           DC.B    'MOVEM',0
00000425= 4D 4F 56 45 41 00         41  movea_ins           DC.B    'MOVEA',0
0000042B= 41 44 44 00               42  add_ins             DC.B    'ADD',0
0000042F= 41 44 44 41 00            43  adda_ins            DC.B    'ADDA',0
00000434= 41 44 44 51 00            44  addq_ins            DC.B    'ADDQ',0
00000439= 4F 52 00                  45  or_ins              DC.B    'OR',0
0000043C= 41 4E 44 00               46  and_ins             DC.B    'AND',0
00000440= 53 55 42 00               47  sub_ins             DC.B    'SUB',0
00000444= 4C 53 00                  48  ls_ins              DC.B    'LS',0
00000447= 41 53 00                  49  as_ins              DC.B    'AS',0
0000044A= 52 4F 00                  50  ro_ins              DC.B    'RO',0
0000044D= 4E 4F 54 00               51  not_ins             DC.B    'NOT',0
00000451= 4A 53 52 20 00            52  jsr_ins             DC.B    'JSR ',0
00000456= 4C 45 41 20 00            53  lea_ins             DC.B    'LEA ',0
0000045B= 41 44 44 51 00            54  andq_ins            DC.B    'ADDQ',0
00000460                            55  
00000460                            56  *direction
00000460= 52 00                     57  right               DC.B    'R',0
00000462= 4C 00                     58  left                DC.B    'L',0
00000464                            59  
00000464                            60  *EA
00000464= 44 00                     61  D_reg               DC.B    'D',0
00000466= 41 00                     62  A_reg               DC.B    'A',0
00000468= 28 41 00                  63  open_paran          DC.B    '(A',0
0000046B= 29 00                     64  close_paran         DC.B    ')',0
0000046D= 29 2B 00                  65  post_inc            DC.B    ')+',0
00000470= 2D 28 41 00               66  pre_dec             DC.B    '-(A',0
00000474                            67  
00000474                            68  *extra
00000474= 20 00                     69  space               DC.B    ' ',0
00000476= 2C 20 00                  70  comma               DC.B    ', ',0
00000479= 23 00                     71  pound               DC.B    '#',0
0000047B  =00000009                 72  tab                 EQU     $9
0000047B= 0D 0A 00                  73  return              DC.B    CR,LF,0
0000047E= 44 41 54 41 20 24 00      74  data                DC.B    'DATA $',0
00000485= 24 00                     75  dollar              DC.B    '$',0
00001000                            76      ORG    $1000    *Start at address $1000
00001000                            77  START:                  ; first instruction of program
00001000                            78  
00001000                            79  *---------- Test value, will remove in final build ----------*
00001000                            80  
00001000  33FC 4E75 00009234        81      Move.W #$4E75,$00009234 *RTS
00001008  33FC 3C05 00009236        82      MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001010  33FC 2447 00009238        83      MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001018  33FC 4E71 0000923A        84      MOVE.W #$4E71,$0000923A *NOP
00001020  33FC D95C 0000923C        85      MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001028  33FC D3C2 0000923E        86      MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001030  33FC 9822 00009240        87      MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001038  33FC C246 00009242        88      MOVE.W #$C246,$00009242 *AND.W D6,D1
00001040  33FC 8593 00009244        89      MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001048  33FC E0C7 00009246        90      MOVE.W #$E0C7,$00009246 *ASR D7
00001050  33FC ED4C 00009248        91      MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001058  33FC E4BB 0000924A        92      MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001060  33FC 7404 0000924C        93      MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001068  33FC C23C 0000924E        94      MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001070  33FC 000C 00009250        95      MOVE.W #$000C,$00009250
00001078  33FC 2C3C 00009252        96      MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001080  23FC 12345678 00009254    97      MOVE.L #$12345678,$00009254
0000108A  33FC D4F8 00009258        98      MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001092  33FC 0012 0000925A        99      MOVE.W #$0012,$0000925A
0000109A  33FC 4607 0000925C       100      MOVE.W #$4607,$0000925C *NOT.B D7
000010A2  33FC 4EB9 0000925E       101      MOVE.W #$4EB9,$0000925E *JSR $9208
000010AA  23FC 00009208 00009260   102      MOVE.L #$00009208,$00009260
000010B4  33FC 4E90 00009264       103      MOVE.W #$4E90,$00009264 *JSR (A0)
000010BC  33FC 41D0 00009266       104      MOVE.W #$41D0,$00009266 *LEA (A0), A0 
000010C4  33FC 5E14 00009268       105      MOVE.W #$5E14,$00009268 *ADDq.B #7, (A4)        
000010CC                           106  *---------- END Test ----------*
000010CC                           107  
000010CC                           108  
000010CC                           109  
000010CC                           110  *---------- Beginning Messages ----------*
000010CC                           111      
000010CC  103C 000E                112      move.b      #14,D0
000010D0  43F8 0000                113      lea         StartingMsg,A1 
000010D4  4E4F                     114      trap        #15
000010D6                           115      
000010D6  103C 000E                116      move.b      #14,D0
000010DA  43F8 001F                117      lea         Creators,A1
000010DE  4E4F                     118      trap        #15
000010E0                           119      
000010E0  4EB9 00001132            120      jsr         MENU
000010E6                           121      
000010E6                           122      
000010E6                           123  * ---------- END OF PROGRAM -------------*
000010E6                           124  
000010E6  103C 000E                125      move.b      #14,D0
000010EA  43F8 01EF                126      lea         ExitMsg,A1 
000010EE  4E4F                     127      trap        #15
000010F0                           128      
000010F0  103C 0009                129      move.b      #9,D0
000010F4  4E4F                     130      trap        #15
000010F6                           131  * ---------------------------------------*
000010F6                           132      
000010F6                           133  *-- End of Opening and Ending Messages --*
000010F6                           134  
000010F6                           135  *--------- Start of I/O Section ---------*
000010F6                           136  
000010F6                           137  Clear_Registers:
000010F6  4280                     138      clr.l     D0
000010F8  4281                     139      clr.l     D1
000010FA  4282                     140      clr.l     D2
000010FC  4283                     141      clr.l     D3
000010FE  4284                     142      clr.l     D4
00001100  4285                     143      clr.l     D5
00001102  4286                     144      clr.l     D6
00001104  4287                     145      clr.l     D7
00001106                           146      
00001106  207C 00000000            147      movea.l   #0,A0
0000110C  227C 00000000            148      movea.l   #0,A1
00001112  247C 00000000            149      movea.l   #0,A2
00001118  267C 00000000            150      movea.l   #0,A3
0000111E  287C 00000000            151      movea.l   #0,A4
00001124  2A7C 00000000            152      movea.l   #0,A5
0000112A  2C7C 00000000            153      movea.l   #0,A6
00001130  4E75                     154      rts
00001132                           155  
00001132                           156  MENU:
00001132  4EB8 10F6                157      jsr         Clear_Registers
00001136  4EB9 00001150            158      jsr         GetStartAddress
0000113C  4EB9 0000116A            159      jsr         GetEndAddress
00001142  4EB9 00001184            160      jsr         CheckAddress
00001148                           161      
00001148  4EB9 00001188            162      jsr         MemSearch
0000114E  4E75                     163      rts
00001150                           164      
00001150                           165  GetStartAddress:
00001150                           166      
00001150  103C 000E                167      move.b      #14, D0         *Display input message
00001154  43F8 004E                168      lea         InputMsg1,A1
00001158  4E4F                     169      trap        #15
0000115A                           170      
0000115A  103C 0002                171      move.b      #2,D0
0000115E  4E4F                     172      trap        #15
00001160                           173          
00001160  4EB9 000017EA            174      jsr ASCIItoHex              *conversion to Hex
00001166                           175      * Address Located in D6
00001166  2846                     176      movea.l     D6,A4           *move into address register 4
00001168  4E75                     177      rts
0000116A                           178      
0000116A                           179      
0000116A                           180  GetEndAddress:
0000116A  103C 000E                181      move.b      #14,D0          *Display input message
0000116E  43F8 008F                182      lea         InputMsg2,A1
00001172  4E4F                     183      trap        #15
00001174                           184      
00001174  103C 0002                185      move.b      #2,D0
00001178  4E4F                     186      trap        #15
0000117A                           187      
0000117A  4EB9 000017EA            188      jsr         ASCIItoHex      *conversion to hex
00001180                           189      * Address Located in D6 (overwrite)
00001180  2A46                     190      movea.l     D6,A5           *move into address register 5
00001182  4E75                     191      rts
00001184                           192      
00001184                           193  CheckAddress:
00001184  BBCC                     194      cmp.l       A4,A5
00001186  67AA                     195      beq         Menu
00001188                           196  
00001188                           197      
00001188                           198  MemSearch:
00001188  4EB9 00001190            199      jsr MemSearchLoop
0000118E  4E75                     200      rts
00001190                           201      
00001190                           202  MemSearchLoop:
00001190                           203      
00001190                           204      * Check if we reached the end address
00001190  BBCC                     205      cmp.l       A4,A5
00001192  6700 002A                206      beq         MemSearch_Done
00001196                           207      
00001196                           208      * Get data from memory
00001196  4241                     209      CLR D1
00001198  3414                     210      move.w     (A4),D2
0000119A  3602                     211      move.w      D2, D3  mutable copy in D3
0000119C                           212      * OPCODE Word Located in D2, mutable copy in D3
0000119C  220C                     213      MOVE.L      A4, D1
0000119E  143C 0010                214      MOVE.B      #16, D2
000011A2  103C 000F                215      MOVE.B      #15, D0     print address of instruction
000011A6  4E4F                     216      TRAP        #15
000011A8  3403                     217      MOVE.W      D3,D2
000011AA  43F8 0474                218      LEA         space,A1
000011AE  4EB9 000012B8            219      JSR         print
000011B4  4EB9 000011D6            220      jsr         OPCODE_DECODE    
000011BA                           221      
000011BA  544C                     222      adda.w      #2,A4
000011BC  60D2                     223      bra         MemSearchLoop
000011BE                           224      
000011BE                           225      
000011BE                           226  MemSearch_Done:
000011BE  103C 000E                227      move.b      #14,D0
000011C2  43F8 0173                228      lea         EndOfMemLoop,A1 
000011C6  4E4F                     229      trap        #15
000011C8  4E75                     230      rts
000011CA                           231      
000011CA                           232  TerminateOrCont:
000011CA                           233      * Used to check if user would like to terminate the program or continue to disassemble more data
000011CA  103C 000E                234      move.b      #14,D0
000011CE  43F8 01CC                235      lea         ContinueOrNotMsg,A1 
000011D2  4E4F                     236      trap        #15
000011D4                           237      
000011D4  4E75                     238      rts 
000011D6                           239  
000011D6                           240  * -------- Start of Opcode Section -------*    
000011D6                           241  
000011D6                           242  OPCODE_DECODE:
000011D6                           243      * Begin OPCODE Decoding here
000011D6                           244      * Check first four bits and begin
000011D6                           245      * if-branch breakdown
000011D6  4284                     246      CLR.L D4
000011D8  4285                     247      CLR.L D5
000011DA  4286                     248      CLR.L D6
000011DC  4287                     249      CLR.L D7
000011DE                           250      
000011DE  B47C 4E71                251      CMP.W #$4E71, D2        
000011E2  6700 00F0                252      BEQ print_nop           *check if value is NOP
000011E6                           253      
000011E6  B47C 4E75                254      CMP.W #$4E75, D2        
000011EA  6700 00F2                255      BEQ print_rts           *check if value is RTS
000011EE                           256      
000011EE                           257      * Mask out only the first 4 bits
000011EE  C67C F000                258      AND.W #$F000,D3
000011F2                           259      
000011F2  B67C 9000                260      CMP.W #$9000,D3
000011F6  6700 01DC                261      BEQ print_sub_and_or    *check if value is SUB
000011FA                           262      
000011FA  B67C 8000                263      CMP.W #$8000, D3
000011FE  6700 01D4                264      BEQ print_sub_and_or    *check if value is OR
00001202                           265  
00001202  B67C C000                266      CMP.W #$C000,D3
00001206  6700 01CC                267      BEQ print_sub_and_or    *check if value is AND
0000120A                           268      
0000120A  B67C D000                269      CMP.W #$D000,D3
0000120E  6700 0120                270      BEQ print_add_adda      *check if value is ADD or ADDA
00001212                           271      
00001212  B67C E000                272      CMP.W #$E000,D3
00001216  6700 022E                273      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
0000121A                           274      
0000121A  B67C 7000                275      CMP.W   #$7000,D3
0000121E  6700 005C                276      BEQ     print_moveq     *check if value is MOVEQ
00001222                           277      
00001222  B47C 1000                278      CMP.W #$1000,D2
00001226  6D00 0036                279      BLT invalid
0000122A  B47C 4000                280      CMP.W #$4000,D2
0000122E  6D00 00B8                281      BLT print_move_movea    *check if value is MOVE or MOVEA
00001232                           282      
00001232                           283      * Mask out only the first 8 bits
00001232  3602                     284      MOVE.W D2, D3
00001234  C67C FF00                285      AND.W #$FF00,D3
00001238                           286      
00001238  B67C 4600                287      CMP.W #$4600,D3
0000123C  6700 02A8                288      BEQ print_not           *check if value is NOT
00001240                           289      
00001240  B67C 4E00                290      CMP.W #$4E00,D3
00001244  6700 02CA                291      BEQ print_jsr           *check if value is JSR
00001248                           292      
00001248                           293      * Mask out only the first 4 bits and the 8th bit
00001248  3602                     294      MOVE.W D2,D3
0000124A  C67C F100                295      AND.W #$F100, D3
0000124E                           296      
0000124E  B67C 4100                297      CMP.W #$4100, D3
00001252  6700 02D2                298      BEQ print_lea           *check if value is LEA
00001256                           299      
00001256  B67C 5000                300      CMP.W #$5000,D3
0000125A  6700 02EE                301      BEQ print_addq          *check if value is ANDQ     
0000125E                           302      
0000125E                           303      
0000125E                           304  invalid 
0000125E  43F8 047E                305      LEA data, A1
00001262  4EB9 000012B8            306      JSR print
00001268  2202                     307      MOVE.L D2, D1
0000126A  143C 0010                308      MOVE.B #16, D2
0000126E  103C 000F                309      MOVE.B  #15, D0     
00001272  4E4F                     310      TRAP #15
00001274  4EB9 000012CA            311      JSR enter
0000127A  4E75                     312  out rts
0000127C                           313  
0000127C                           314      
0000127C                           315  * -------- End of Opcode Section --------*   
0000127C                           316  
0000127C                           317  * --------- Print Instruction ----------*
0000127C                           318  
0000127C                           319  print_moveq
0000127C  43F8 0418                320      lea moveq_ins, A1   *print MOVEQ
00001280  4EB9 000012B8            321      jsr print
00001286  3602                     322      move.w  D2,D3
00001288  C67C 00FF                323      and.w   #$00FF,D3   * Figure out the immediate address value
0000128C  43F8 0479                324      lea pound,A1        *print '#'
00001290  4EB9 000012B8            325      jsr print
00001296  103C 0003                326      move.b  #3,D0
0000129A  3203                     327      move.w  D3,D1
0000129C  4E4F                     328      trap    #15         *print immediate address value
0000129E  43F8 0476                329      lea comma,A1        *print comma
000012A2  4EB9 000012B8            330      jsr print
000012A8  3A02                     331      MOVE.W D2, D5
000012AA  4EB9 000017BA            332      JSR data_reg_sr     *figure out data address
000012B0  4EB9 000012CA            333      jsr enter           *print out enter
000012B6  60C2                     334      bra out
000012B8                           335  
000012B8                           336  print:
000012B8  4240                     337      CLR D0 
000012BA  103C 000E                338      MOVE.B #14,D0
000012BE  4E4F                     339      TRAP #15
000012C0  4E75                     340      RTS
000012C2                           341  
000012C2                           342  println:
000012C2  103C 000D                343      MOVE.B #13, D0
000012C6  4E4F                     344      TRAP #15
000012C8  4E75                     345      RTS
000012CA                           346      
000012CA                           347  enter: 
000012CA  43F8 047B                348      LEA return, A1
000012CE  4EB8 12B8                349      JSR print
000012D2  4E75                     350      RTS
000012D4                           351      
000012D4                           352  print_nop
000012D4  43F8 040B                353      LEA nop_ins, A1
000012D8  4EB8 12C2                354      JSR println
000012DC  609C                     355      BRA out
000012DE                           356  
000012DE                           357  print_rts
000012DE  43F8 040F                358      LEA rts_ins, A1
000012E2  4EB8 12C2                359      JSR println
000012E6  6092                     360      BRA out
000012E8                           361  
000012E8                           362  print_move_movea
000012E8  3602                     363      MOVE.W D2, D3       
000012EA  C67C 01C0                364      AND.W #$01C0, D3
000012EE  B67C 0040                365      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000012F2  6700 000E                366      BEQ move_a
000012F6  43F8 0413                367      LEA move_ins, A1 *print Instruction 
000012FA  4EB8 12B8                368      JSR print
000012FE  6000 000A                369      BRA m_size
00001302                           370  move_a          *if instruction is MOVEA
00001302  43F8 0425                371      LEA movea_ins, A1
00001306  4EB8 12B8                372      JSR print
0000130A                           373  m_size              *determine instruction size
0000130A  4EB9 000015D8            374      JSR move_size
00001310  4EB9 0000163A            375      JSR addr        *determine the source address
00001316  43F8 0476                376      LEA comma, A1   *print comma
0000131A  4EB8 12B8                377      JSR print
0000131E  1E3C 0001                378      MOVE.B #1, D7   *determine destination address
00001322  4EB9 0000163A            379      JSR addr
00001328  4EB8 12CA                380      JSR enter       *print enter
0000132C  6000 FF4C                381      BRA out
00001330                           382      
00001330                           383  print_add_adda
00001330  3602                     384      MOVE.W D2, D3   
00001332  C63C 00C0                385      AND.B #$C0, D3
00001336  B63C 00C0                386      CMP.B #$C0, D3      *determine if ADD or ADDA
0000133A  6700 0052                387      BEQ add_a
0000133E                           388      *if just ADD then print instruction
0000133E  43F8 042B                389      LEA add_ins, A1
00001342  4EB8 12B8                390      JSR print
00001346                           391      *print instruction size for ADD
00001346  4EB9 0000161E            392      JSR size
0000134C                           393      *determine direction of ADD, Dn -> EA or EA -> Dn
0000134C  3602                     394      MOVE.W D2,D3
0000134E  C67C 0100                395      AND.W #$0100, D3
00001352  B67C 0100                396      CMP.W #$0100, D3
00001356  6700 001C                397      BEQ ea_dest_add 
0000135A  4EB9 0000163A            398      JSR addr            *if Direction bit is 0
00001360  43F8 0476                399      LEA comma, A1
00001364  4EB8 12B8                400      JSR print
00001368  3A02                     401      MOVE.W D2,D5
0000136A  4EB9 000017BA            402      JSR data_reg_sr
00001370  6000 005A                403      BRA end_add
00001374                           404  ea_dest_add             *if Direction bit is 1
00001374  3A02                     405      MOVE.W D2,D5
00001376  4EB9 000017BA            406      JSR data_reg_sr
0000137C  43F8 0476                407      LEA comma, A1
00001380  4EB8 12B8                408      JSR print
00001384  4EB9 0000163A            409      JSR addr
0000138A  6000 0040                410      BRA end_add
0000138E                           411  add_a                   *if instruction is ADDA
0000138E  43F8 042F                412      LEA adda_ins, A1
00001392  4EB8 12B8                413      JSR print
00001396                           414      *print instruction size for ADDA (either W or L)
00001396  3602                     415      MOVE.W D2,D3
00001398  C67C 0100                416      AND.W #$0100, D3
0000139C  B67C 0100                417      CMP.W #$0100, D3
000013A0  6700 000E                418      BEQ adda_size
000013A4  43F8 0403                419      LEA word, A1
000013A8  4EB8 12B8                420      JSR print
000013AC  6000 000A                421      BRA next_add
000013B0                           422  adda_size
000013B0  43F8 03FF                423      LEA long,A1
000013B4  4EB8 12B8                424      JSR print
000013B8                           425  next_add                *print effective address for ADDA
000013B8  4EB9 0000163A            426      JSR addr            
000013BE  43F8 0476                427      LEA comma, A1
000013C2  4EB8 12B8                428      JSR print
000013C6  4EB9 000017D2            429      JSR add_reg_sr
000013CC                           430  end_add                 *complete instruction printing by printing enter
000013CC  4EB8 12CA                431      JSR enter
000013D0  6000 FEA8                432      BRA out
000013D4                           433  
000013D4                           434  print_sub_and_or
000013D4                           435      *determine if instruction is SUB, AND, or OR.
000013D4  B67C 8000                436      CMP.W #$8000, D3
000013D8  6700 001A                437      BEQ print_or
000013DC  B67C 9000                438      CMP.W #$9000, D3
000013E0  6700 000A                439      BEQ print_sub
000013E4  43F8 043C                440      LEA and_ins, A1
000013E8  6000 000E                441      BRA print_instruction
000013EC                           442  print_sub
000013EC  43F8 0440                443      LEA sub_ins, A1
000013F0  6000 0006                444      BRA print_instruction
000013F4                           445  print_or
000013F4  43F8 0439                446      LEA or_ins, A1
000013F8                           447  print_instruction       *print correct instruction
000013F8  4EB8 12B8                448      JSR print
000013FC  4EB9 0000161E            449      JSR size            *print instruction size
00001402  3602                     450      MOVE.W D2,D3
00001404                           451  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001404  C67C 0100                452      AND.W #$0100, D3
00001408  B67C 0100                453      CMP.W #$0100, D3
0000140C  6700 001A                454      BEQ ea_dest_sub_and_or
00001410  4EB9 0000163A            455      JSR addr            *if Direction bit is 0
00001416  43F8 0476                456      LEA comma, A1
0000141A  4EB8 12B8                457      JSR print
0000141E  3A02                     458      MOVE.W D2,D5
00001420  4EB9 000017BA            459      JSR data_reg_sr
00001426  60A4                     460      BRA end_add
00001428                           461  ea_dest_sub_and_or      *if Direction bit is 1
00001428  3A02                     462      MOVE.W D2,D5
0000142A  4EB9 000017BA            463      JSR data_reg_sr
00001430  43F8 0476                464      LEA comma, A1
00001434  4EB8 12B8                465      JSR print
00001438  4EB9 0000163A            466      JSR addr
0000143E                           467      *complete instruction printing by printing enter
0000143E  4EB8 12CA                468      JSR enter
00001442  6000 FE36                469      BRA out
00001446                           470  
00001446                           471  print_ls_as_ro
00001446                           472      *figure out if shift or rotation are memory or register based               
00001446  3602                     473      MOVE.W D2, D3
00001448  C63C 00C0                474      AND.B #$C0, D3
0000144C  B63C 00C0                475      CMP.B #$C0, D3
00001450  6700 005E                476      BEQ ls_as_ro_mem
00001454  3602                     477      MOVE.W D2, D3
00001456  E60B                     478      LSR.B #3, D3
00001458                           479      *print correct instruction type (logical shift, arithmetic shift, or rotation)
00001458  4EB9 000015A6            480      JSR print_correct_shift_rotation
0000145E  4EB9 00001584            481      JSR print_direction     *print direction
00001464  4EB9 0000161E            482      JSR size                *print size
0000146A  3602                     483      MOVE.W D2, D3
0000146C  C63C 0020                484      AND.B #$20,D3
00001470  B63C 0020                485      CMP.B #$20, D3
00001474                           486      *determine if instruction is using immediate address or register
00001474  6700 001C                487      BEQ ls_as_ro_reg     
00001478  43F8 0479                488      LEA pound, A1        *if immediate address print '#'
0000147C  4EB8 12B8                489      JSR print
00001480                           490      *print immediate address rotation value
00001480  3C02                     491      MOVE.W D2,D6
00001482  EF5E                     492      ROL.W #7,D6
00001484  CC7C 0007                493      AND.W #$0007, D6
00001488  4EB9 000017AE            494      JSR Xn
0000148E  6000 000A                495      BRA continue_instruction_ls_as_ro
00001492                           496  ls_as_ro_reg            *if instruction is using register to shift values in another register
00001492  3A02                     497      MOVE.W D2,D5
00001494  4EB9 000017BA            498      JSR data_reg_sr
0000149A                           499  continue_instruction_ls_as_ro *complete instrcuction
0000149A  43F8 0476                500      LEA comma, A1       *print comma
0000149E  4EB8 12B8                501      JSR print
000014A2  3A02                     502      MOVE.W D2,D5
000014A4  EE5D                     503      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
000014A6  4EB9 000017BA            504      JSR data_reg_sr     *determine destination data register to perform instruction on
000014AC  6000 0030                505      BRA next_ls_as_ro   *finish printing instruction
000014B0                           506  ls_as_ro_mem            *check if immediate address is being shifted or rotated
000014B0  3602                     507      MOVE.W D2, D3
000014B2  C63C 003F                508      AND.B #$3F, D3
000014B6  B63C 003C                509      CMP.B #$3C, D3
000014BA  6700 FDA2                510      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
000014BE                           511      *if not immediate adress print normally 
000014BE  3602                     512      MOVE.W D2, D3
000014C0  EF5B                     513      ROL.W #7, D3    
000014C2  4EB9 000015A6            514      JSR print_correct_shift_rotation
000014C8  3602                     515      MOVE.W D2,D3
000014CA  4EB9 00001584            516      JSR print_direction
000014D0  43F8 0474                517      LEA space, A1
000014D4  4EB8 12B8                518      JSR print
000014D8  4EB9 0000163A            519      JSR addr
000014DE                           520  next_ls_as_ro
000014DE  4EB8 12CA                521      JSR enter
000014E2  6000 FD96                522      BRA out
000014E6                           523      
000014E6                           524  print_not
000014E6  43F8 044D                525      LEA not_ins, A1
000014EA  4EB8 12B8                526      JSR print
000014EE  4EB9 0000161E            527      JSR size
000014F4  3602                     528      MOVE.W D2, D3
000014F6  C63C 003F                529      AND.B #$3F, D3
000014FA  B63C 003C                530      CMP.B #$3C, D3
000014FE  6700 FD5E                531      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
00001502  4EB9 0000163A            532      JSR addr
00001508  4EB8 12CA                533      JSR enter
0000150C  6000 FD6C                534      BRA out
00001510                           535  
00001510                           536  print_jsr
00001510  43F8 0451                537      LEA jsr_ins, A1
00001514  4EB8 12B8                538      JSR print
00001518  4EB9 0000163A            539      JSR addr
0000151E  4EB8 12CA                540      JSR enter
00001522  6000 FD56                541      BRA out
00001526                           542  
00001526                           543  print_lea
00001526  43F8 0456                544      LEA lea_ins, A1
0000152A  4EB8 12B8                545      JSR print
0000152E  4EB9 0000163A            546      JSR addr
00001534  43F8 0476                547      LEA comma, A1
00001538  4EB8 12B8                548      JSR print
0000153C  4EB9 000017D2            549      JSR add_reg_sr
00001542  4EB8 12CA                550      JSR enter
00001546  6000 FD32                551      BRA out
0000154A                           552  
0000154A                           553  print_addq
0000154A  43F8 0434                554      LEA addq_ins, A1
0000154E  4EB8 12B8                555      JSR print
00001552  4EB9 0000161E            556      JSR size
00001558  43F8 0479                557      LEA pound, A1
0000155C  4EB8 12B8                558      JSR print
00001560  3C02                     559      MOVE.W D2,D6
00001562  EF5E                     560      ROL.W #7,D6
00001564  CC7C 0007                561      AND.W #$0007, D6
00001568  4EB9 000017AE            562      JSR Xn
0000156E  43F8 0476                563      LEA comma, A1
00001572  4EB8 12B8                564      JSR print
00001576  4EB9 0000163A            565      JSR addr
0000157C  4EB8 12CA                566      JSR enter
00001580  6000 FCF8                567      BRA out
00001584                           568  
00001584                           569  print_direction:
00001584                           570  *print correct direction given direction bit
00001584  C67C 0100                571      AND.W #$0100, D3
00001588  B67C 0100                572      CMP.W #$0100, D3
0000158C  6700 000E                573      BEQ print_left  *print left
00001590  43F8 0460                574      LEA right, A1
00001594  4EB8 12B8                575      JSR print
00001598  6000 FCE0                576      BRA out
0000159C                           577  print_left
0000159C  43F8 0462                578      LEA left, A1
000015A0  4EB8 12B8                579      JSR print *print right
000015A4  4E75                     580      RTS
000015A6                           581      
000015A6                           582  print_correct_shift_rotation:
000015A6                           583  *determine if instruction is logical, arithmetic, or rotation 
000015A6  C63C 0003                584      AND.B #$03, D3
000015AA  B63C 0000                585      CMP.B #$00, D3
000015AE  6700 0016                586      BEQ print_as
000015B2  B63C 0001                587      CMP.B #$01, D3
000015B6  6700 0016                588      BEQ print_ls
000015BA  B63C 0003                589      CMP.B #$03, D3
000015BE  43F8 044A                590      LEA ro_ins, A1  print rotation
000015C2  6000 000E                591      BRA print_it
000015C6                           592  print_as
000015C6  43F8 0447                593      LEA as_ins, A1  print arithmetic shift
000015CA  6000 0006                594      BRA print_it
000015CE                           595  print_ls
000015CE  43F8 0444                596      LEA ls_ins, A1 print logical shift
000015D2                           597  print_it
000015D2  4EB8 12B8                598      JSR print
000015D6  4E75                     599      RTS
000015D8                           600  * --------- End Print Instruction ----------*
000015D8                           601  
000015D8                           602  * ------- Instruction sizes ---------*
000015D8                           603  
000015D8                           604  move_size: *print size for MOVE and MOVEA instruction
000015D8  4284                     605      CLR.L D4
000015DA  3802                     606      MOVE.W D2, D4
000015DC  C87C 3000                607      AND.W #$3000, D4
000015E0  B87C 1000                608      CMP.W #$1000, D4
000015E4  6700 0014                609      BEQ print_b
000015E8  B87C 3000                610      CMP.W #$3000, D4
000015EC  6700 0018                611      BEQ print_w
000015F0  B87C 2000                612      CMP.W #$2000, D4
000015F4  6700 001C                613      BEQ print_l
000015F8  4E75                     614      RTS
000015FA                           615      
000015FA                           616  print_b
000015FA  43F8 0407                617      LEA byte, A1
000015FE  4EB8 12B8                618      JSR print
00001602  6000 FC76                619      BRA out
00001606                           620      
00001606                           621  print_w
00001606  43F8 0403                622      LEA word, A1
0000160A  4EB8 12B8                623      JSR print
0000160E  6000 FC6A                624      BRA out
00001612                           625      
00001612                           626  print_l:
00001612  43F8 03FF                627      LEA long, A1
00001616  4EB8 12B8                628      JSR print
0000161A  6000 FC5E                629      BRA out
0000161E                           630  
0000161E                           631  size: *print size for pretty much any other instruction
0000161E  4284                     632      CLR.L D4
00001620  1802                     633      MOVE.B D2,D4
00001622  C83C 00C0                634      AND.B #$C0, D4
00001626  B83C 0000                635      CMP.B #$00, D4
0000162A  67CE                     636      BEQ print_b
0000162C  B83C 0040                637      CMP.B #$40,D4
00001630  67D4                     638      BEQ print_w
00001632  B83C 0080                639      CMP.B #$80, D4
00001636  67DA                     640      BEQ print_l
00001638  4E75                     641      RTS
0000163A                           642      
0000163A                           643  * ------- End Instruction sizes ---------*
0000163A                           644  
0000163A                           645  * ------- Effective Address -------*
0000163A                           646  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
0000163A  3A02                     647      MOVE.W D2, D5
0000163C  3C02                     648      MOVE.W D2, D6               
0000163E  BE3C 0001                649      CMP.B #1, D7
00001642  6700 003A                650      BEQ destination *check if evaluating destination address (used for MOVE)
00001646                           651  cont
00001646  CC3C 0038                652      AND.B #$38, D6
0000164A  BC3C 0000                653      CMP.B #0, D6
0000164E  6700 0038                654      BEQ data_reg
00001652  BC3C 0008                655      CMP.B #$08, D6
00001656  6700 0048                656      BEQ add_reg
0000165A  BC3C 0010                657      CMP.B #$10, D6
0000165E  6700 0058                658      BEQ add_indirect
00001662  BC3C 0018                659      CMP.B #$18, D6
00001666  6700 0070                660      BEQ post_increment
0000166A  BC3C 0020                661      CMP.B #$20, D6
0000166E  6700 0088                662      BEQ pre_decrement
00001672  BC3C 0038                663      CMP.B #$38, D6
00001676  6700 00A0                664      BEQ absolute_or_immediate
0000167A  6000 FBFE                665      BRA out *needs Immediate, Abs Long, and Abs Word
0000167E                           666  destination     *perform correct rotation to retrieve destination address
0000167E  3C05                     667      MOVE.W D5,D6
00001680  EF5D                     668      ROL.W #7,D5
00001682  E64E                     669      LSR.W #3,D6
00001684  60C0                     670      BRA cont
00001686  4E75                     671      RTS
00001688                           672  
00001688                           673  data_reg    *used with addr sub routine
00001688  3C05                     674      MOVE.W D5,D6    
0000168A  CC3C 0007                675      AND.B #$07, D6  
0000168E  43F8 0464                676      LEA D_reg, A1   
00001692  4EB8 12B8                677      JSR print
00001696  4EB9 000017AE            678      JSR Xn
0000169C  6000 FBDC                679      BRA out
000016A0                           680  
000016A0                           681  add_reg     *used with addr sub routine
000016A0  3C05                     682      MOVE.W D5,D6    
000016A2  CC3C 0007                683      AND.B #$07, D6
000016A6  43F8 0466                684      LEA A_reg, A1   
000016AA  4EB8 12B8                685      JSR print
000016AE  4EB9 000017AE            686      JSR Xn
000016B4  6000 FBC4                687      BRA out
000016B8                           688      
000016B8                           689  add_indirect    *used with addr sub routine
000016B8  3C05                     690      MOVE.W D5,D6    
000016BA  CC3C 0007                691      AND.B #$07, D6
000016BE  43F8 0468                692      LEA open_paran, A1  
000016C2  4EB8 12B8                693      JSR print
000016C6  4EB9 000017AE            694      JSR Xn
000016CC  43F8 046B                695      LEA close_paran, A1 
000016D0  4EB8 12B8                696      JSR print
000016D4  6000 FBA4                697      BRA out
000016D8                           698      
000016D8                           699  post_increment  *used with addr sub routine
000016D8  3C05                     700      MOVE.W D5,D6    
000016DA  CC3C 0007                701      AND.B #$07, D6
000016DE  43F8 0468                702      LEA open_paran, A1  
000016E2  4EB8 12B8                703      JSR print
000016E6  4EB9 000017AE            704      JSR Xn
000016EC  43F8 046D                705      LEA post_inc, A1    
000016F0  4EB8 12B8                706      JSR print
000016F4  6000 FB84                707      BRA out
000016F8                           708      
000016F8                           709  pre_decrement   *used with addr sub routine
000016F8  3C05                     710      MOVE.W D5,D6    
000016FA  CC3C 0007                711      AND.B #$07, D6
000016FE  43F8 0470                712      LEA pre_dec, A1 
00001702  4EB8 12B8                713      JSR print
00001706  4EB9 000017AE            714      JSR Xn
0000170C  43F8 046B                715      LEA close_paran, A1 
00001710  4EB8 12B8                716      JSR print
00001714  6000 FB64                717      BRA out
00001718                           718  
00001718                           719  absolute_or_immediate *check if EA is immediate or absolute address
00001718  3C05                     720      MOVE.W D5,D6    
0000171A  CC3C 0007                721      AND.B #$07, D6
0000171E  BC3C 0000                722      CMP.B #$00, D6
00001722  6700 0050                723      BEQ w_imm
00001726  BC3C 0001                724      CMP.B #$01, D6
0000172A  6700 0064                725      BEQ l_imm
0000172E  BC3C 0004                726      CMP.B #04, D6
00001732  6700 0002                727      BEQ immediate
00001736                           728      
00001736                           729  immediate
00001736  43F8 0479                730      LEA pound, A1
0000173A  4EB8 12B8                731      JSR print
0000173E  B4BC 00004000            732      CMP.L #$4000, D2
00001744  6D00 0012                733      BLT move_movea      *check if instruction is move or movea
00001748  B83C 0040                734      CMP.B #$40, D4      *if not move or movea
0000174C  6D00 0026                735      BLT w_imm           *byte and word check the next 2 addresses in mem
00001750  B83C 0080                736      CMP.B #$80, D4
00001754  6700 003A                737      BEQ l_imm           *long checks the next 4 addresses in mem
00001758                           738  move_movea
00001758  B87C 1000                739      CMP.W #$1000, D4
0000175C  6700 0016                740      BEQ w_imm
00001760  B87C 3000                741      CMP.W #$3000, D4
00001764  6700 000E                742      BEQ w_imm
00001768  B87C 2000                743      CMP.W #$2000, D4
0000176C  6700 0022                744      BEQ l_imm
00001770                           745  imm_complete
00001770  6000 FB08                746      BRA out
00001774                           747      
00001774                           748  w_imm
00001774  43F8 0485                749      LEA dollar, A1
00001778  4EB8 12B8                750      JSR print
0000177C  544C                     751      ADDA.W #2,A4
0000177E  3214                     752      MOVE.W (A4),D1
00001780  3602                     753      MOVE.W D2, D3
00001782  343C 0010                754      MOVE.W #16, D2
00001786  103C 000F                755      MOVE.B #15, D0
0000178A  4E4F                     756      TRAP #15
0000178C  3403                     757      MOVE.W D3,D2
0000178E  60E0                     758      BRA imm_complete
00001790                           759      
00001790                           760  l_imm
00001790  43F8 0485                761      LEA dollar, A1
00001794  4EB8 12B8                762      JSR print
00001798  544C                     763      ADDA.W  #2,A4
0000179A  2214                     764      MOVE.L (A4),D1
0000179C  3602                     765      MOVE.W D2, D3
0000179E  343C 0010                766      MOVE.W #16, D2
000017A2  103C 000F                767      MOVE.B #15, D0
000017A6  4E4F                     768      TRAP #15
000017A8  3403                     769      MOVE.W D3,D2
000017AA  544C                     770      ADD.W  #2,A4
000017AC  60C2                     771      BRA imm_complete
000017AE                           772  
000017AE                           773  Xn:
000017AE  4281                     774      CLR.L D1
000017B0  1206                     775      MOVE.B D6,D1
000017B2  103C 0003                776      MOVE.B #3, D0
000017B6  4E4F                     777      TRAP #15
000017B8  4E75                     778      RTS
000017BA                           779  
000017BA                           780  data_reg_sr:    *use if dealing with Dn only
000017BA  4286                     781      CLR.L D6
000017BC  3C05                     782      MOVE.W D5,D6
000017BE  EF5E                     783      ROL.W #7,D6
000017C0  CC3C 0007                784      AND.B #$07, D6  
000017C4  43F8 0464                785      LEA D_reg, A1   
000017C8  4EB8 12B8                786      JSR print
000017CC  4EB8 17AE                787      JSR Xn
000017D0  4E75                     788      RTS
000017D2                           789      
000017D2                           790  add_reg_sr:     *use if dealing with An only
000017D2  4286                     791      CLR.L D6
000017D4  3C02                     792      MOVE.W D2,D6
000017D6  EF5E                     793      ROL.W #7,D6
000017D8  CC3C 0007                794      AND.B #$07, D6  
000017DC  43F8 0466                795      LEA A_reg, A1   
000017E0  4EB8 12B8                796      JSR print
000017E4  4EB8 17AE                797      JSR Xn
000017E8  4E75                     798      RTS
000017EA                           799  
000017EA                           800  * ------- End Effective Address -------*
000017EA                           801  
000017EA                           802  * ----- Hex to ASCII & ASCII to HEX -----*
000017EA                           803  
000017EA                           804  ASCIItoHex:
000017EA  4EB9 000017F8            805          jsr     ASCII2Hex_init  
000017F0  4EB9 000017FE            806          jsr     conversion_loop
000017F6  4E75                     807          rts                    
000017F8                           808  
000017F8                           809  ASCII2Hex_init:   
000017F8  143C 0000                810          move.b  #0,D2       *set up counter    
000017FC  4E75                     811          rts         
000017FE                           812          
000017FE                           813  conversion_loop:            
000017FE  5282                     814          add.l   #1,D2       *increment counter
00001800  B4BC 00000009            815          cmp.l   #9,D2       *ends at 9
00001806  6700 004A                816          BEQ     DONE        *branch when compare is true
0000180A  1819                     817          move.b  (A1)+,D4    *Get first num
0000180C                           818          
0000180C  B83C 0040                819          cmp.b   #$40,D4        
00001810  6E00 000C                820          bgt     Letters_Cap  
00001814                           821          
00001814  B83C 0039                822          cmp.b   #$39,D4
00001818  6F00 0016                823          BLE     Numbers      
0000181C  4E75                     824          rts
0000181E                           825          
0000181E                           826  Letters_Cap:      
0000181E  B83C 0046                827          cmp.b   #$46,D4          
00001822  6E00 001E                828          bgt     ERROR  
00001826  0404 0037                829          sub.b   #$37,D4     
0000182A  E986                     830          asl.l   #4,D6       
0000182C  DC84                     831          add.l   D4,D6     
0000182E  60CE                     832          bra     conversion_loop 
00001830                           833  Numbers:
00001830  B83C 0030                834          cmp.b   #$30,D4         
00001834  6D00 000C                835          blt     ERROR        
00001838  0404 0030                836          sub.b   #$30,D4      
0000183C  E986                     837          asl.l   #4,D6        
0000183E  DC84                     838          add.l   D4,D6     
00001840  60BC                     839          bra     conversion_loop
00001842                           840          
00001842                           841  ERROR:
00001842  43F8 011E                842          lea     ErrorMsg,A1    
00001846  103C 000E                843          move.b  #14,D0
0000184A  4E4F                     844          trap    #15
0000184C                           845      
0000184C  103C 0009                846          move.b  #9,D0
00001850  4E4F                     847          trap    #15
00001852                           848          
00001852                           849  DONE:
00001852                           850     
00001852  4241                     851          clr     D1
00001854  4242                     852          clr     D2
00001856  4244                     853          clr     D4
00001858                           854      
00001858  43F8 014F                855          lea     ASCIItoHexMsg,A1
0000185C  103C 000E                856          move.b  #14,D0
00001860  4E4F                     857          trap    #15
00001862                           858  
00001862  4E75                     859          rts
00001864                           860          
00001864                           861  
00001864                           862          
00001864                           863  * -- End of Hex to ASCII & ASCII to HEX --*
00001864                           864  
00001864                           865  * Put program code here
00001864                           866  
00001864  FFFF FFFF                867      SIMHALT             ; halt simulator
00001868                           868  
00001868                           869  * Put variables and constants here
00001868                           870  
00001868                           871      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  1718
ADDA_INS            42F
ADDA_SIZE           13B0
ADDQ_INS            434
ADDR                163A
ADD_A               138E
ADD_INDIRECT        16B8
ADD_INS             42B
ADD_REG             16A0
ADD_REG_SR          17D2
ANDQ_INS            45B
AND_INS             43C
ASCII2HEX_INIT      17F8
ASCIITOHEX          17EA
ASCIITOHEXMSG       14F
AS_INS              447
A_REG               466
BYTE                407
CHECKADDRESS        1184
CLEAR_REGISTERS     10F6
CLOSE_PARAN         46B
COMMA               476
CONT                1646
CONTINUEORNOTMSG    1CC
CONTINUE_INSTRUCTION_LS_AS_RO  149A
CONVERSION_LOOP     17FE
CR                  D
CREATORS            1F
DATA                47E
DATA_REG            1688
DATA_REG_SR         17BA
DESTINATION         167E
DOLLAR              485
DONE                1852
D_REG               464
EA_DEST_ADD         1374
EA_DEST_SUB_AND_OR  1428
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13CC
END_ADDR_BUFFER     2FF
ENTER               12CA
ERROR               1842
ERRORMSG            11E
EXITMSG             1EF
GETENDADDRESS       116A
GETSTARTADDRESS     1150
HELPMSG             190
HEXTOASCIIMSG       12D
IMMEDIATE           1736
IMM_COMPLETE        1770
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             125E
JSR_INS             451
LEA_INS             456
LEFT                462
LETTERS_CAP         181E
LF                  A
LONG                3FF
LS_AS_RO_MEM        14B0
LS_AS_RO_REG        1492
LS_INS              444
L_IMM               1790
MEMSEARCH           1188
MEMSEARCHLOOP       1190
MEMSEARCH_DONE      11BE
MENU                1132
MOVEA_INS           425
MOVEM_INS           41F
MOVEQ_INS           418
MOVE_A              1302
MOVE_INS            413
MOVE_MOVEA          1758
MOVE_SIZE           15D8
M_SIZE              130A
NEXT_ADD            13B8
NEXT_LS_AS_RO       14DE
NOP_INS             40B
NOT_INS             44D
NUMBERS             1830
OPCODE_DECODE       11D6
OPEN_PARAN          468
OR_INS              439
OUT                 127A
POST_INC            46D
POST_INCREMENT      16D8
POUND               479
PRE_DEC             470
PRE_DECREMENT       16F8
PRINT               12B8
PRINTLN             12C2
PRINT_ADDQ          154A
PRINT_ADD_ADDA      1330
PRINT_AS            15C6
PRINT_B             15FA
PRINT_CORRECT_SHIFT_ROTATION  15A6
PRINT_DIRECTION     1584
PRINT_INSTRUCTION   13F8
PRINT_IT            15D2
PRINT_JSR           1510
PRINT_L             1612
PRINT_LEA           1526
PRINT_LEFT          159C
PRINT_LS            15CE
PRINT_LS_AS_RO      1446
PRINT_MOVEQ         127C
PRINT_MOVE_MOVEA    12E8
PRINT_NOP           12D4
PRINT_NOT           14E6
PRINT_OR            13F4
PRINT_RTS           12DE
PRINT_SUB           13EC
PRINT_SUB_AND_OR    13D4
PRINT_W             1606
RETURN              47B
RIGHT               460
RO_INS              44A
RTS_INS             40F
SIZE                161E
SPACE               474
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   1FF
SUB_INS             440
TAB                 9
TERMINATEORCONT     11CA
WORD                403
W_IMM               1774
XN                  17AE
