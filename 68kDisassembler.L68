00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 5:14:22 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to continue with the next set of instructions',0
000001CA= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
00000206= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
0000023C= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
0000024C                            27  
0000024C                            28  START_ADDR_BUFFER  DS.B    256
0000034C                            29  END_ADDR_BUFFER    DS.B    256
0000044C                            30  
0000044C                            31  *size
0000044C= 2E 4C 20 00               32  long                DC.B    '.L ',0
00000450= 2E 57 20 00               33  word                DC.B    '.W ',0
00000454= 2E 42 20 00               34  byte                DC.B    '.B ',0
00000458                            35  
00000458                            36  *instructions
00000458= 4E 4F 50 00               37  nop_ins             DC.B    'NOP',0
0000045C= 52 54 53 00               38  rts_ins             DC.B    'RTS',0
00000460= 4D 4F 56 45 00            39  move_ins            DC.B    'MOVE',0
00000465= 4D 4F 56 45 51 20 00      40  moveq_ins           DC.B    'MOVEQ ',0
0000046C= 4D 4F 56 45 4D 00         41  movem_ins           DC.B    'MOVEM',0
00000472= 4D 4F 56 45 41 00         42  movea_ins           DC.B    'MOVEA',0
00000478= 41 44 44 00               43  add_ins             DC.B    'ADD',0
0000047C= 41 44 44 41 00            44  adda_ins            DC.B    'ADDA',0
00000481= 41 44 44 51 00            45  addq_ins            DC.B    'ADDQ',0
00000486= 4F 52 00                  46  or_ins              DC.B    'OR',0
00000489= 41 4E 44 00               47  and_ins             DC.B    'AND',0
0000048D= 53 55 42 00               48  sub_ins             DC.B    'SUB',0
00000491= 4C 53 00                  49  ls_ins              DC.B    'LS',0
00000494= 41 53 00                  50  as_ins              DC.B    'AS',0
00000497= 52 4F 00                  51  ro_ins              DC.B    'RO',0
0000049A= 4E 4F 54 00               52  not_ins             DC.B    'NOT',0
0000049E= 4A 53 52 20 00            53  jsr_ins             DC.B    'JSR ',0
000004A3= 4C 45 41 20 00            54  lea_ins             DC.B    'LEA ',0
000004A8= 41 44 44 51 00            55  andq_ins            DC.B    'ADDQ',0
000004AD= 42 47 54 00               56  bgt_ins             DC.B    'BGT',0
000004B1= 42 4C 45 00               57  ble_ins             DC.B    'BLE',0
000004B5= 42 45 51 00               58  beq_ins             DC.B    'BEQ',0
000004B9= 42 52 41 00               59  bra_ins             DC.B    'BRA',0
000004BD                            60  
000004BD                            61  *direction
000004BD= 52 00                     62  right               DC.B    'R',0
000004BF= 4C 00                     63  left                DC.B    'L',0
000004C1                            64  
000004C1                            65  *EA
000004C1= 44 00                     66  D_reg               DC.B    'D',0
000004C3= 41 00                     67  A_reg               DC.B    'A',0
000004C5= 28 41 00                  68  open_paran          DC.B    '(A',0
000004C8= 29 00                     69  close_paran         DC.B    ')',0
000004CA= 29 2B 00                  70  post_inc            DC.B    ')+',0
000004CD= 2D 28 41 00               71  pre_dec             DC.B    '-(A',0
000004D1                            72  
000004D1                            73  *extra
000004D1= 20 00                     74  space               DC.B    ' ',0
000004D3= 2C 20 00                  75  comma               DC.B    ', ',0
000004D6= 23 00                     76  pound               DC.B    '#',0
000004D8= 2D 00                     77  dash                DC.B    '-',0
000004DA= 2F 00                     78  slash               DC.B    '/',0
000004DC  =00000009                 79  tab                 EQU     $9
000004DC= 0D 0A 00                  80  return              DC.B    CR,LF,0
000004DF= 44 41 54 41 20 24 00      81  data                DC.B    'DATA $',0
000004E6= 24 00                     82  dollar              DC.B    '$',0
00001000                            83      ORG    $1000    *Start at address $1000
00001000                            84  START:                  ; first instruction of program
00001000                            85  
00001000                            86  *---------- Test value, will remove in final build ----------*
00001000                            87  
00001000                            88  *   Move.W #$4E75,$00009234 *RTS
00001000                            89  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            90  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            91  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            92  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            93  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            94  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            95  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            96  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            97  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            98  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            99  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                           100  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           101  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           102  *   MOVE.W #$000C,$00009250
00001000                           103  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           104  *   MOVE.L #$12345678,$00009254
00001000                           105  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           106  *   MOVE.W #$0012,$0000925A
00001000                           107  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           108  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           109  *   MOVE.L #$00009208,$00009260
00001000                           110  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           111  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           112  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           113  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           114  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           115  *    MOVE.W #$FE7A,$0000926E
00001000                           116  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           117  *    MOVE.W #$FE60,$00009272
00001000                           118  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           119  *    MOVE.L #$00009208,$000009276
00001000                           120  *    MOVE.W #$48A1,$0000927A
00001000                           121  *    MOVE.W #$011F,$0000927C
00001000                           122  *    MOVE.W #$4C91,$0000927E
00001000                           123  *    MOVE.W #$FE00,$00009280
00001000                           124  *   MOVE.W #$C2BC, $00009000
00001000                           125  *   MOVE.L #$12345678, $00009002
00001000  33FC 82F9 00009000       126      MOVE.W #$82F9 , $00009000
00001008  23FC 12345678 00009002   127      MOVE.L #$12345678, $00009002 
00001012  33FC 9441 00009006       128      MOVE.W #$9441, $00009006
0000101A  33FC C27C 00009008       129      Move.w #$C27C, $00009008
00001022  33FC 1234 0000900A       130      move.w #$1234, $0000900A
0000102A                           131  *   MOVE.L #$12345678, $00009002
0000102A                           132  *---------- END Test ----------*
0000102A                           133  
0000102A                           134  
0000102A                           135  
0000102A                           136  *---------- Beginning Messages ----------*
0000102A                           137      
0000102A  103C 000E                138      move.b      #14,D0
0000102E  43F8 0000                139      lea         StartingMsg,A1 
00001032  4E4F                     140      trap        #15
00001034                           141      
00001034  103C 000E                142      move.b      #14,D0
00001038  43F8 001F                143      lea         Creators,A1
0000103C  4E4F                     144      trap        #15
0000103E                           145      
0000103E  4EB9 00001090            146      jsr         MENU
00001044                           147      
00001044                           148      
00001044                           149  * ---------- END OF PROGRAM -------------*
00001044                           150  
00001044  103C 000E                151      move.b      #14,D0
00001048  43F8 023C                152      lea         ExitMsg,A1 
0000104C  4E4F                     153      trap        #15
0000104E                           154      
0000104E  103C 0009                155      move.b      #9,D0
00001052  4E4F                     156      trap        #15
00001054                           157  * ---------------------------------------*
00001054                           158      
00001054                           159  *-- End of Opening and Ending Messages --*
00001054                           160  
00001054                           161  *--------- Start of I/O Section ---------*
00001054                           162  
00001054                           163  Clear_Registers:
00001054  4280                     164      clr.l     D0
00001056  4281                     165      clr.l     D1
00001058  4282                     166      clr.l     D2
0000105A  4283                     167      clr.l     D3
0000105C  4284                     168      clr.l     D4
0000105E  4285                     169      clr.l     D5
00001060  4286                     170      clr.l     D6
00001062  4287                     171      clr.l     D7
00001064                           172      
00001064  207C 00000000            173      movea.l   #0,A0
0000106A  227C 00000000            174      movea.l   #0,A1
00001070  247C 00000000            175      movea.l   #0,A2
00001076  267C 00000000            176      movea.l   #0,A3
0000107C  287C 00000000            177      movea.l   #0,A4
00001082  2A7C 00000000            178      movea.l   #0,A5
00001088  2C7C 00000000            179      movea.l   #0,A6
0000108E  4E75                     180      rts
00001090                           181  
00001090                           182  MENU:
00001090  4EB8 1054                183      jsr         Clear_Registers
00001094  4EB9 000010B4            184      jsr         GetStartAddress
0000109A  4EB9 000010CE            185      jsr         GetEndAddress
000010A0  4EB9 000010E8            186      jsr         CheckAddress
000010A6                           187      
000010A6  4EB9 00001126            188      jsr         MemSearch
000010AC  4EB9 00001180            189      jsr         TerminateOrCont
000010B2  4E75                     190      rts
000010B4                           191      
000010B4                           192  GetStartAddress:
000010B4                           193      
000010B4  103C 000E                194      move.b      #14, D0         *Display input message
000010B8  43F8 004E                195      lea         InputMsg1,A1
000010BC  4E4F                     196      trap        #15
000010BE                           197      
000010BE  103C 0002                198      move.b      #2,D0
000010C2  4E4F                     199      trap        #15
000010C4                           200          
000010C4  4EB9 00001B1C            201      jsr ASCIItoHex              *conversion to Hex
000010CA                           202      * Address Located in D6
000010CA  2846                     203      movea.l     D6,A4           *move into address register 4
000010CC  4E75                     204      rts
000010CE                           205      
000010CE                           206      
000010CE                           207  GetEndAddress:
000010CE  103C 000E                208      move.b      #14,D0          *Display input message
000010D2  43F8 008F                209      lea         InputMsg2,A1
000010D6  4E4F                     210      trap        #15
000010D8                           211      
000010D8  103C 0002                212      move.b      #2,D0
000010DC  4E4F                     213      trap        #15
000010DE                           214      
000010DE  4EB9 00001B1C            215      jsr         ASCIItoHex      *conversion to hex
000010E4                           216      * Address Located in D6 (overwrite)
000010E4  2A46                     217      movea.l     D6,A5           *move into address register 5
000010E6  4E75                     218      rts
000010E8                           219      
000010E8                           220  CheckAddress:
000010E8                           221      
000010E8  200C                     222      move.l     A4,D0
000010EA  220D                     223      move.l     A5,D1
000010EC                           224  
000010EC  B280                     225      cmp.l      D0,D1
000010EE  67A0                     226      beq        MENU
000010F0                           227      
000010F0  B081                     228      cmp.l      D1,D0
000010F2  609C                     229      bra        MENU
000010F4  4E75                     230      rts
000010F6                           231  
000010F6                           232  
000010F6                           233  ClearScreen:
000010F6  43F8 04DC                234      lea     return,A1
000010FA  103C 000E                235      move.b  #14,D0
000010FE  4E4F                     236      trap    #15
00001100                           237      
00001100                           238      *move.b  #9,D0
00001100                           239      *trap    #15
00001100                           240      
00001100  B27C 0028                241      cmp.w   #40,D1
00001104  6700 001E                242      beq     ClearDone
00001108  5241                     243      add.w   #1,D1
0000110A  60EA                     244      bra     ClearScreen
0000110C                           245  
0000110C                           246  
0000110C                           247  ClearScreen_40:
0000110C  43F8 04DC                248      lea     return,A1
00001110  103C 000E                249      move.b  #14,D0
00001114  4E4F                     250      trap    #15
00001116                           251      
00001116  B2BC 00000028            252      cmp.l   #40,D1
0000111C  6700 0006                253      beq     ClearDone
00001120  5281                     254      add.l   #1,D1
00001122  60E8                     255      bra     ClearScreen_40
00001124                           256      
00001124                           257  ClearDone:
00001124  4E75                     258      rts
00001126                           259      
00001126                           260  MemSearch:
00001126  7200                     261      move.l      #0,D1
00001128  4EB8 10F6                262      jsr         ClearScreen
0000112C                           263      * Set up instruction counter and place onto stack
0000112C  303C 0000                264      move.w      #0,D0
00001130  3F00                     265      move.w      D0,-(SP)
00001132                           266      
00001132  4EB9 0000113A            267      jsr MemSearchLoop
00001138  4E75                     268      rts
0000113A                           269      
0000113A                           270  MemSearchLoop:
0000113A                           271      
0000113A                           272      * Check if we reached the end address
0000113A  BBCC                     273      cmp.l       A4,A5
0000113C  6700 0036                274      beq         MemSearch_Done
00001140                           275      
00001140                           276      * Get data from memory
00001140  4241                     277      CLR D1
00001142  3414                     278      move.w     (A4),D2
00001144  3602                     279      move.w      D2, D3  mutable copy in D3
00001146                           280      * OPCODE Word Located in D2, mutable copy in D3
00001146  220C                     281      MOVE.L      A4, D1
00001148  143C 0010                282      MOVE.B      #16, D2
0000114C  103C 000F                283      MOVE.B      #15, D0     print address of instruction
00001150  4E4F                     284      TRAP        #15
00001152  3403                     285      MOVE.W      D3,D2
00001154  43F8 04D1                286      LEA         space,A1
00001158  4EB9 00001276            287      JSR         print
0000115E  4EB9 000011C0            288      jsr         OPCODE_DECODE    
00001164                           289      
00001164  544C                     290      adda.w      #2,A4
00001166                           291      
00001166                           292      * Call back counter from the stack
00001166  301F                     293      move.w      (SP)+,D0
00001168  5200                     294      add.b       #1,D0
0000116A  4EB9 00001190            295      jsr         ScreenFlush_Check
00001170  3F00                     296      move.w      D0,-(SP)
00001172                           297      
00001172  60C6                     298      bra         MemSearchLoop
00001174                           299      
00001174                           300      
00001174                           301  MemSearch_Done:
00001174  103C 000E                302      move.b      #14,D0
00001178  43F8 0173                303      lea         EndOfMemLoop,A1 
0000117C  4E4F                     304      trap        #15
0000117E  4E75                     305      rts
00001180                           306      
00001180                           307  TerminateOrCont:
00001180  4EB8 1054                308      jsr         Clear_Registers
00001184  103C 000E                309      move.b      #14,D0
00001188  43F8 0206                310      lea         ContinueOrNotMsg,A1 
0000118C  4E4F                     311      trap        #15
0000118E                           312      
0000118E  4E75                     313      rts
00001190                           314  
00001190                           315  ScreenFlush_Check:
00001190  B03C 001F                316      cmp.b       #31,D0 * 31
00001194  6700 0004                317      beq         FlushScreen
00001198  4E75                     318      rts 
0000119A                           319  
0000119A                           320  FlushScreen:
0000119A  43F8 0190                321      lea         FlushScreenMsg,A1
0000119E  103C 000E                322      move.b      #14,D0
000011A2  4E4F                     323      trap        #15
000011A4  4EB9 000011AC            324      jsr         FlushScreen_Input
000011AA                           325      *move.l      #0,D1
000011AA                           326      *jsr         ClearScreen_40
000011AA  4E75                     327      rts
000011AC                           328  
000011AC                           329  FlushScreen_Input:
000011AC                           330  
000011AC  4241                     331      clr     D1
000011AE                           332  
000011AE  103C 0005                333      move.b  #5,D0
000011B2  4E4F                     334      trap    #15
000011B4                           335      
000011B4  B23C 000D                336      cmp.b   #13,D1
000011B8  6700 0004                337      beq     Enter_Press_True    
000011BC                           338      
000011BC  60EE                     339      bra     FlushScreen_Input
000011BE                           340      
000011BE                           341  Enter_Press_True:
000011BE  4E75                     342      rts
000011C0                           343      
000011C0                           344  
000011C0                           345      
000011C0                           346  
000011C0                           347  * -------- Start of Opcode Section -------*    
000011C0                           348  
000011C0                           349  OPCODE_DECODE:
000011C0                           350      * Begin OPCODE Decoding here
000011C0                           351      * Check first four bits and begin
000011C0                           352      * if-branch breakdown
000011C0  4284                     353      CLR.L D4
000011C2  4285                     354      CLR.L D5
000011C4  4286                     355      CLR.L D6
000011C6  4287                     356      CLR.L D7
000011C8                           357      
000011C8  B47C 4E71                358      CMP.W #$4E71, D2        
000011CC  6700 00C4                359      BEQ print_nop           *check if value is NOP
000011D0                           360      
000011D0  B47C 4E75                361      CMP.W #$4E75, D2        
000011D4  6700 00C6                362      BEQ print_rts           *check if value is RTS
000011D8                           363      
000011D8                           364      * Mask out only the first 4 bits
000011D8  C67C F000                365      AND.W #$F000,D3
000011DC                           366      
000011DC  B67C 9000                367      CMP.W #$9000,D3
000011E0  6700 01FA                368      BEQ print_sub_and_or    *check if value is SUB
000011E4                           369      
000011E4  B67C 6000                370      CMP.W #$6000,D3
000011E8  6700 0408                371      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011EC                           372      
000011EC  B67C 8000                373      CMP.W #$8000, D3
000011F0  6700 01EA                374      BEQ print_sub_and_or    *check if value is OR
000011F4                           375  
000011F4  B67C C000                376      CMP.W #$C000,D3
000011F8  6700 01E2                377      BEQ print_sub_and_or    *check if value is AND
000011FC                           378      
000011FC  B67C D000                379      CMP.W #$D000,D3
00001200  6700 0132                380      BEQ print_add_adda      *check if value is ADD or ADDA
00001204                           381      
00001204  B67C E000                382      CMP.W #$E000,D3
00001208  6700 0296                383      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
0000120C                           384      
0000120C  B67C 7000                385      CMP.W #$7000,D3
00001210  6700 0094                386      BEQ print_moveq     *check if value is MOVEQ
00001214                           387      
00001214  B47C 1000                388      CMP.W #$1000,D2
00001218  6D00 003E                389      BLT invalid
0000121C  B47C 4000                390      CMP.W #$4000,D2
00001220  6D00 00C8                391      BLT print_move_movea    *check if value is MOVE or MOVEA
00001224                           392      
00001224                           393      * Mask out only the first 8 bits
00001224  3602                     394      MOVE.W D2, D3
00001226  C67C FF00                395      AND.W #$FF00,D3
0000122A                           396      
0000122A  B67C 4600                397      CMP.W #$4600,D3
0000122E  6700 0324                398      BEQ print_not           *check if value is NOT
00001232                           399      
00001232  B67C 4E00                400      CMP.W #$4E00,D3
00001236  6700 0346                401      BEQ print_jsr           *check if value is JSR
0000123A                           402      
0000123A                           403      * Mask out only the first 4 bits and the 8th bit
0000123A  3602                     404      MOVE.W D2,D3
0000123C  C67C F100                405      AND.W #$F100, D3
00001240                           406      
00001240  B67C 4000                407      CMP.W #$4000, D3
00001244  6700 045E                408      BEQ print_movem         *check if value is MOVEM
00001248                           409      
00001248  B67C 4100                410      CMP.W #$4100, D3
0000124C  6700 0346                411      BEQ print_lea           *check if value is LEA
00001250                           412      
00001250  B67C 5000                413      CMP.W #$5000,D3
00001254  6700 0362                414      BEQ print_addq          *check if value is ANDQ     
00001258                           415      
00001258                           416      
00001258                           417  invalid 
00001258  43F8 04DF                418      LEA data, A1
0000125C  4EB9 00001276            419      JSR print
00001262  2202                     420      MOVE.L D2, D1
00001264  143C 0010                421      MOVE.B #16, D2
00001268  103C 000F                422      MOVE.B  #15, D0     
0000126C  4E4F                     423      TRAP #15
0000126E  4EB9 00001288            424      JSR enter
00001274  4E75                     425  out rts
00001276                           426  
00001276                           427      
00001276                           428  * -------- End of Opcode Section --------*   
00001276                           429  
00001276                           430  * --------- Print Instructions ----------*
00001276                           431  
00001276                           432  
00001276                           433  print:
00001276  4240                     434      CLR D0 
00001278  103C 000E                435      MOVE.B #14,D0
0000127C  4E4F                     436      TRAP #15
0000127E  4E75                     437      RTS
00001280                           438  
00001280                           439  println:
00001280  103C 000D                440      MOVE.B #13, D0
00001284  4E4F                     441      TRAP #15
00001286  4E75                     442      RTS
00001288                           443      
00001288                           444  enter: 
00001288  43F8 04DC                445      LEA return, A1
0000128C  4EB8 1276                446      JSR print
00001290  4E75                     447      RTS
00001292                           448      
00001292                           449  print_nop
00001292  43F8 0458                450      LEA nop_ins, A1
00001296  4EB8 1280                451      JSR println
0000129A  60D8                     452      BRA out
0000129C                           453  
0000129C                           454  print_rts
0000129C  43F8 045C                455      LEA rts_ins, A1
000012A0  4EB8 1280                456      JSR println
000012A4  60CE                     457      BRA out
000012A6                           458      
000012A6                           459  print_moveq
000012A6  43F8 0465                460      lea moveq_ins, A1   *print MOVEQ
000012AA  4EB8 1276                461      jsr print
000012AE  3602                     462      move.w  D2,D3
000012B0  C67C 00FF                463      and.w   #$00FF,D3   * Figure out the immediate address value
000012B4  43F8 04D6                464      lea pound,A1        *print '#'
000012B8  4EB8 1276                465      jsr print
000012BC  43F8 04E6                466      LEA dollar, A1
000012C0  4EB8 1276                467      JSR print
000012C4  3203                     468      move.w  D3,D1
000012C6  3602                     469      MOVE.W D2,D3
000012C8  343C 0010                470      MOVE.W #16, D2
000012CC  103C 000F                471      move.b  #15,D0
000012D0  4E4F                     472      trap    #15         *print immediate address value
000012D2  43F8 04D3                473      lea comma,A1        *print comma
000012D6  4EB8 1276                474      jsr print
000012DA  3403                     475      MOVE.W D3, D2
000012DC  3A02                     476      MOVE.W D2, D5
000012DE  4EB9 0000194A            477      JSR data_reg_sr     *figure out data address
000012E4  4EB8 1288                478      jsr enter           *print out enter
000012E8  608A                     479      bra out
000012EA                           480      
000012EA                           481  print_move_movea
000012EA  3602                     482      MOVE.W D2, D3       
000012EC  C67C 01C0                483      AND.W #$01C0, D3
000012F0  B67C 0040                484      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000012F4  6700 000E                485      BEQ move_a
000012F8  43F8 0460                486      LEA move_ins, A1 *print Instruction 
000012FC  4EB8 1276                487      JSR print
00001300  6000 000A                488      BRA m_size
00001304                           489  move_a          *if instruction is MOVEA
00001304  43F8 0472                490      LEA movea_ins, A1
00001308  4EB8 1276                491      JSR print
0000130C                           492  m_size              *determine instruction size
0000130C  4EB9 00001764            493      JSR move_size
00001312  4EB9 000017C6            494      JSR addr        *determine the source address
00001318  43F8 04D3                495      LEA comma, A1   *print comma
0000131C  4EB8 1276                496      JSR print
00001320  4207                     497      CLR.B D7
00001322  1E3C 0001                498      MOVE.B #1, D7   *determine destination address
00001326  4EB9 000017C6            499      JSR addr
0000132C  4EB8 1288                500      JSR enter       *print enter
00001330  6000 FF42                501      BRA out
00001334                           502      
00001334                           503  print_add_adda
00001334  3602                     504      MOVE.W D2, D3   
00001336  C63C 00C0                505      AND.B #$C0, D3
0000133A  B63C 00C0                506      CMP.B #$C0, D3      *determine if ADD or ADDA
0000133E  6700 0052                507      BEQ add_a
00001342                           508      *if just ADD then print instruction
00001342  43F8 0478                509      LEA add_ins, A1
00001346  4EB8 1276                510      JSR print
0000134A                           511      *print instruction size for ADD
0000134A  4EB9 000017AA            512      JSR size
00001350                           513      *determine direction of ADD, Dn -> EA or EA -> Dn
00001350  3602                     514      MOVE.W D2,D3
00001352  C67C 0100                515      AND.W #$0100, D3
00001356  B67C 0100                516      CMP.W #$0100, D3
0000135A  6700 001C                517      BEQ ea_dest_add 
0000135E  4EB9 000017C6            518      JSR addr            *if Direction bit is 0
00001364  43F8 04D3                519      LEA comma, A1
00001368  4EB8 1276                520      JSR print
0000136C  3A02                     521      MOVE.W D2,D5
0000136E  4EB9 0000194A            522      JSR data_reg_sr
00001374  6000 005E                523      BRA end_add
00001378                           524  ea_dest_add             *if Direction bit is 1
00001378  3A02                     525      MOVE.W D2,D5
0000137A  4EB9 0000194A            526      JSR data_reg_sr
00001380  43F8 04D3                527      LEA comma, A1
00001384  4EB8 1276                528      JSR print
00001388  4EB9 000017C6            529      JSR addr
0000138E  6000 0044                530      BRA end_add
00001392                           531  add_a                   *if instruction is ADDA
00001392  43F8 047C                532      LEA adda_ins, A1
00001396  4EB8 1276                533      JSR print
0000139A                           534      *print instruction size for ADDA (either W or L)
0000139A  3602                     535      MOVE.W D2,D3
0000139C  C67C 0100                536      AND.W #$0100, D3
000013A0  B67C 0100                537      CMP.W #$0100, D3
000013A4  6700 000E                538      BEQ adda_size
000013A8  43F8 0450                539      LEA word, A1
000013AC  4EB8 1276                540      JSR print
000013B0  6000 000E                541      BRA next_add
000013B4                           542  adda_size
000013B4  43F8 044C                543      LEA long,A1
000013B8  4EB8 1276                544      JSR print
000013BC  183C 0080                545      MOVE.B #$80, D4
000013C0                           546  next_add                *print effective address for ADDA
000013C0  4EB9 000017C6            547      JSR addr            
000013C6  43F8 04D3                548      LEA comma, A1
000013CA  4EB8 1276                549      JSR print
000013CE  4EB9 00001962            550      JSR add_reg_sr
000013D4                           551  end_add                 *complete instruction printing by printing enter
000013D4  4EB8 1288                552      JSR enter
000013D8  6000 FE9A                553      BRA out
000013DC                           554  
000013DC                           555  print_sub_and_or
000013DC                           556      *determine if instruction is SUB, AND, or OR.
000013DC  3602                     557      MOVE.W D2, D3
000013DE  C67C F0C0                558      AND.W #$F0C0, D3
000013E2  B67C C0C0                559      CMP.W #$C0C0, D3
000013E6  6700 0090                560      BEQ mul_div
000013EA  B67C 80C0                561      CMP.W #$80C0, D3
000013EE  6700 0088                562      BEQ mul_div
000013F2  C67C F000                563      AND.W #$F000,D3
000013F6  B67C 8000                564      CMP.W #$8000, D3
000013FA  6700 0028                565      BEQ print_or
000013FE  B67C 9000                566      CMP.W #$9000, D3
00001402  6700 000A                567      BEQ print_sub
00001406  43F8 0489                568      LEA and_ins, A1
0000140A  6000 001C                569      BRA print_instruction
0000140E                           570  print_sub
0000140E  3602                     571      MOVE.W D2, D3
00001410  C67C 00C0                572      AND.W #$00C0, D3
00001414  B63C 00C0                573      CMP.B #$C0, D3
00001418  6700 FE3E                574      BEQ invalid
0000141C  43F8 048D                575      LEA sub_ins, A1
00001420  6000 0006                576      BRA print_instruction
00001424                           577  print_or
00001424  43F8 0486                578      LEA or_ins, A1
00001428                           579  print_instruction       *print correct instruction
00001428  4EB8 1276                580      JSR print
0000142C  4EB9 000017AA            581      JSR size            *print instruction size
00001432  3602                     582      MOVE.W D2,D3
00001434                           583  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001434  C67C 0100                584      AND.W #$0100, D3
00001438  B67C 0100                585      CMP.W #$0100, D3
0000143C  6700 001C                586      BEQ ea_dest_sub_and_or
00001440  4EB9 000017C6            587      JSR addr            *if Direction bit is 0
00001446  43F8 04D3                588      LEA comma, A1
0000144A  4EB8 1276                589      JSR print
0000144E  3A02                     590      MOVE.W D2,D5
00001450  4EB9 0000194A            591      JSR data_reg_sr
00001456  6000 FF7C                592      BRA end_add
0000145A                           593  ea_dest_sub_and_or      *if Direction bit is 1
0000145A  3A02                     594      MOVE.W D2,D5
0000145C  4EB9 0000194A            595      JSR data_reg_sr
00001462  43F8 04D3                596      LEA comma, A1
00001466  4EB8 1276                597      JSR print
0000146A  4EB9 000017C6            598      JSR addr
00001470                           599      *complete instruction printing by printing enter
00001470  4EB8 1288                600      JSR enter
00001474  6000 FDFE                601      BRA out
00001478                           602      
00001478                           603  mul_div             *deal with MULU and DIVU cases
00001478  4283                     604      CLR.L D3
0000147A  3602                     605      MOVE.W D2,D3
0000147C  C67C 00FF                606      AND.W #$00FF, D3
00001480  B6BC 000000F8            607      CMP.L #$00F8, D3
00001486  6D00 FDD0                608      BLT invalid
0000148A  B6BC 000000F9            609      CMP.L #$00F9, D3
00001490  6700 0008                610      BEQ mul_div_long
00001494  544C                     611      ADDA.W #2,A4
00001496  6000 FDC0                612      BRA invalid
0000149A                           613  mul_div_long
0000149A  584C                     614      ADDA.W #4,A4
0000149C  6000 FDBA                615      BRA invalid
000014A0                           616      
000014A0                           617  print_ls_as_ro
000014A0                           618      *figure out if shift or rotation are memory or register based               
000014A0  3602                     619      MOVE.W D2, D3
000014A2  C63C 00C0                620      AND.B #$C0, D3
000014A6  B63C 00C0                621      CMP.B #$C0, D3
000014AA  6700 0072                622      BEQ ls_as_ro_mem
000014AE  3602                     623      MOVE.W D2, D3
000014B0  E60B                     624      LSR.B #3, D3
000014B2                           625      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000014B2  4EB9 00001732            626      JSR print_correct_shift_rotation
000014B8  4EB9 00001710            627      JSR print_direction     *print direction
000014BE  4EB9 000017AA            628      JSR size                *print size
000014C4  3602                     629      MOVE.W D2, D3
000014C6  C63C 0020                630      AND.B #$20,D3
000014CA  B63C 0020                631      CMP.B #$20, D3
000014CE                           632      *determine if instruction is using immediate address or register
000014CE  6700 0030                633      BEQ ls_as_ro_reg     
000014D2  43F8 04D6                634      LEA pound, A1        *if immediate address print '#'
000014D6  4EB8 1276                635      JSR print
000014DA                           636      *print immediate address rotation value
000014DA  3C02                     637      MOVE.W D2,D6
000014DC  EF5E                     638      ROL.W #7,D6
000014DE  CC7C 0007                639      AND.W #$0007, D6
000014E2  43F8 04E6                640      LEA dollar, A1
000014E6  4EB8 1276                641      JSR print
000014EA  4281                     642      CLR.L D1
000014EC  3206                     643      MOVE.W D6, D1
000014EE  3602                     644      MOVE.W D2, D3
000014F0  143C 0010                645      MOVE.B #16, D2
000014F4  103C 000F                646      MOVE.B #15, D0
000014F8  4E4F                     647      TRAP #15
000014FA  3403                     648      MOVE.W D3,D2
000014FC  6000 000A                649      BRA continue_instruction_ls_as_ro
00001500                           650  ls_as_ro_reg            *if instruction is using register to shift values in another register
00001500  3A02                     651      MOVE.W D2,D5
00001502  4EB9 0000194A            652      JSR data_reg_sr
00001508                           653  continue_instruction_ls_as_ro *complete instrcuction
00001508  43F8 04D3                654      LEA comma, A1       *print comma
0000150C  4EB8 1276                655      JSR print
00001510  3A02                     656      MOVE.W D2,D5
00001512  EE5D                     657      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001514  4EB9 0000194A            658      JSR data_reg_sr     *determine destination data register to perform instruction on
0000151A  6000 0030                659      BRA next_ls_as_ro   *finish printing instruction
0000151E                           660  ls_as_ro_mem            *check if immediate address is being shifted or rotated
0000151E  3602                     661      MOVE.W D2, D3
00001520  C63C 003F                662      AND.B #$3F, D3
00001524  B63C 003C                663      CMP.B #$3C, D3
00001528  6700 FD2E                664      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
0000152C                           665      *if not immediate adress print normally 
0000152C  3602                     666      MOVE.W D2, D3
0000152E  EF5B                     667      ROL.W #7, D3    
00001530  4EB9 00001732            668      JSR print_correct_shift_rotation
00001536  3602                     669      MOVE.W D2,D3
00001538  4EB9 00001710            670      JSR print_direction
0000153E  43F8 0450                671      LEA word, A1
00001542  4EB8 1276                672      JSR print
00001546  4EB9 000017C6            673      JSR addr
0000154C                           674  next_ls_as_ro
0000154C  4EB8 1288                675      JSR enter
00001550  6000 FD22                676      BRA out
00001554                           677      
00001554                           678  print_not
00001554  43F8 049A                679      LEA not_ins, A1 *print instruction
00001558  4EB8 1276                680      JSR print
0000155C  4EB9 000017AA            681      JSR size
00001562  3602                     682      MOVE.W D2, D3
00001564  C63C 003F                683      AND.B #$3F, D3
00001568  B63C 003C                684      CMP.B #$3C, D3
0000156C  6700 FCEA                685      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
00001570  4EB9 000017C6            686      JSR addr
00001576  4EB8 1288                687      JSR enter
0000157A  6000 FCF8                688      BRA out
0000157E                           689  
0000157E                           690  print_jsr
0000157E  43F8 049E                691      LEA jsr_ins, A1 *print instruction
00001582  4EB8 1276                692      JSR print
00001586  4EB9 000017C6            693      JSR addr    *print address
0000158C  4EB8 1288                694      JSR enter   *print enter (next line)
00001590  6000 FCE2                695      BRA out
00001594                           696  
00001594                           697  print_lea
00001594  43F8 04A3                698      LEA lea_ins, A1 *print instruction
00001598  4EB8 1276                699      JSR print   
0000159C  4EB9 000017C6            700      JSR addr    *print address
000015A2  43F8 04D3                701      LEA comma, A1   *print comma
000015A6  4EB8 1276                702      JSR print
000015AA  4EB9 00001962            703      JSR add_reg_sr *print destination address register
000015B0  4EB8 1288                704      JSR enter
000015B4  6000 FCBE                705      BRA out
000015B8                           706  
000015B8                           707  print_addq
000015B8  43F8 0481                708      LEA addq_ins, A1    *print instruction
000015BC  4EB8 1276                709      JSR print
000015C0  4EB9 000017AA            710      JSR size            *print instruction size
000015C6  43F8 04D6                711      LEA pound, A1
000015CA  4EB8 1276                712      JSR print           *print '#' for immediate addressing
000015CE  3C02                     713      MOVE.W D2,D6
000015D0  EF5E                     714      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015D2  CC7C 0007                715      AND.W #$0007, D6
000015D6  4EB9 0000193E            716      JSR Xn
000015DC  43F8 04D3                717      LEA comma, A1       *print comma
000015E0  4EB8 1276                718      JSR print
000015E4  4EB9 000017C6            719      JSR addr            *print destination address
000015EA  4EB8 1288                720      JSR enter
000015EE  6000 FC84                721      BRA out
000015F2                           722  
000015F2                           723  print_bra_bcc           *needs comments
000015F2  3602                     724      MOVE.W D2,D3
000015F4  C67C 0F00                725      AND.W #$0F00, D3
000015F8  B67C 0000                726      CMP.W #$0000, D3
000015FC  6700 001E                727      BEQ print_bra
00001600  B67C 0700                728      CMP.W #$0700, D3
00001604  6700 0022                729      BEQ print_beq
00001608  B67C 0E00                730      CMP.W #$0E00, D3
0000160C  6700 0032                731      BEQ print_bgt
00001610  B67C 0F00                732      CMP.W #$0F00, D3
00001614  6700 001E                733      BEQ print_ble
00001618  6000 FC3E                734      BRA invalid
0000161C                           735  print_bra
0000161C  43F8 04B9                736      LEA bra_ins, A1
00001620  4EB8 1276                737      JSR print
00001624  6000 0022                738      BRA next_bra_bcc
00001628                           739  print_beq
00001628  43F8 04B5                740      LEA beq_ins, A1
0000162C  4EB8 1276                741      JSR print
00001630  6000 0016                742      BRA next_bra_bcc
00001634                           743  print_ble
00001634  43F8 04B1                744      LEA ble_ins, A1
00001638  4EB8 1276                745      JSR print
0000163C  6000 000A                746      BRA next_bra_bcc
00001640                           747  print_bgt
00001640  43F8 04AD                748      LEA bgt_ins, A1
00001644  4EB8 1276                749      JSR print
00001648                           750  next_bra_bcc
00001648  3602                     751      MOVE.W D2, D3
0000164A  C67C 00FF                752      AND.W #$00FF, D3
0000164E  B67C 0000                753      CMP.W #$0000, D3
00001652  6700 0026                754      BEQ check_word
00001656  43F8 0454                755      LEA byte, A1
0000165A  4EB8 1276                756      JSR print
0000165E  43F8 04E6                757      LEA dollar, A1
00001662  4EB8 1276                758      JSR print
00001666  3203                     759      MOVE.W D3, D1
00001668  3602                     760      MOVE.W D2, D3
0000166A  343C 0010                761      MOVE.W #16, D2
0000166E  303C 000F                762      MOVE.W #15,D0
00001672  4E4F                     763      trap #15            *print immediate address value
00001674  3403                     764      MOVE.W D3, D2
00001676  6000 0024                765      BRA end_bra_bcc
0000167A                           766  check_word
0000167A  43F8 0450                767      LEA word, A1
0000167E  4EB8 1276                768      JSR print
00001682  43F8 04E6                769      LEA dollar, A1
00001686  4EB8 1276                770      JSR print
0000168A  544C                     771      ADDA.W #2,A4        *update current address
0000168C  3214                     772      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000168E  3602                     773      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001690  343C 0010                774      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001694  103C 000F                775      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001698  4E4F                     776      TRAP #15
0000169A  3403                     777      MOVE.W D3,D2        *copy opcode back to register D2
0000169C                           778  end_bra_bcc
0000169C  4EB8 1288                779      JSR enter
000016A0  6000 FBD2                780      BRA out
000016A4                           781  
000016A4                           782  print_movem         *needs comments
000016A4  43F8 046C                783      LEA movem_ins, A1
000016A8  4EB8 1276                784      JSR print
000016AC  3602                     785      MOVE.W D2,D3
000016AE  C67C 0040                786      AND.W #$0040,D3
000016B2  B67C 0040                787      CMP.W #$0040,D3
000016B6  6700 000E                788      BEQ movem_long
000016BA  43F8 0450                789      LEA word, A1
000016BE  4EB8 1276                790      JSR print
000016C2  6000 000A                791      BRA movem_direction
000016C6                           792  movem_long
000016C6  43F8 044C                793      LEA long, A1
000016CA  4EB8 1276                794      JSR print
000016CE                           795  movem_direction
000016CE  3602                     796      MOVE.W D2,D3
000016D0  C67C 0400                797      AND.W #$0400,D3
000016D4  B67C 0400                798      CMP.W #$0400,D3
000016D8  6700 001A                799      BEQ mem_to_reg
000016DC  4EB9 0000197A            800      JSR movem_predec
000016E2  43F8 04D3                801      LEA comma, A1
000016E6  4EB8 1276                802      JSR print
000016EA  4EB9 000017C6            803      JSR addr
000016F0  6000 0016                804      BRA end_movem
000016F4                           805  mem_to_reg
000016F4  4EB9 000017C6            806      JSR addr
000016FA  43F8 04D3                807      LEA comma, A1
000016FE  4EB8 1276                808      JSR print
00001702  4EB9 00001A4C            809      JSR movem_postinc
00001708                           810  end_movem
00001708  4EB8 1288                811      JSR enter
0000170C  6000 FB66                812      BRA out
00001710                           813  
00001710                           814  print_direction:
00001710                           815  *print correct direction given direction bit
00001710  C67C 0100                816      AND.W #$0100, D3
00001714  B67C 0100                817      CMP.W #$0100, D3
00001718  6700 000E                818      BEQ print_left  *print left
0000171C  43F8 04BD                819      LEA right, A1
00001720  4EB8 1276                820      JSR print
00001724  6000 FB4E                821      BRA out
00001728                           822  print_left
00001728  43F8 04BF                823      LEA left, A1
0000172C  4EB8 1276                824      JSR print *print right
00001730  4E75                     825      RTS
00001732                           826      
00001732                           827  print_correct_shift_rotation:
00001732                           828  *determine if instruction is logical, arithmetic, or rotation 
00001732  C63C 0003                829      AND.B #$03, D3
00001736  B63C 0000                830      CMP.B #$00, D3
0000173A  6700 0016                831      BEQ print_as
0000173E  B63C 0001                832      CMP.B #$01, D3
00001742  6700 0016                833      BEQ print_ls
00001746  B63C 0003                834      CMP.B #$03, D3
0000174A  43F8 0497                835      LEA ro_ins, A1  print rotation
0000174E  6000 000E                836      BRA print_it
00001752                           837  print_as
00001752  43F8 0494                838      LEA as_ins, A1  print arithmetic shift
00001756  6000 0006                839      BRA print_it
0000175A                           840  print_ls
0000175A  43F8 0491                841      LEA ls_ins, A1 print logical shift
0000175E                           842  print_it
0000175E  4EB8 1276                843      JSR print
00001762  4E75                     844      RTS
00001764                           845  * --------- End Print Instruction ----------*
00001764                           846  
00001764                           847  * ------- Instruction sizes ---------*
00001764                           848  
00001764                           849  move_size:  *print size for MOVE and MOVEA instruction
00001764  4284                     850      CLR.L D4
00001766  3802                     851      MOVE.W D2, D4
00001768  C87C 3000                852      AND.W #$3000, D4
0000176C  B87C 1000                853      CMP.W #$1000, D4
00001770  6700 0014                854      BEQ print_b
00001774  B87C 3000                855      CMP.W #$3000, D4
00001778  6700 0018                856      BEQ print_w
0000177C  B87C 2000                857      CMP.W #$2000, D4
00001780  6700 001C                858      BEQ print_l
00001784  4E75                     859      RTS
00001786                           860      
00001786                           861  print_b     *print '.B'
00001786  43F8 0454                862      LEA byte, A1
0000178A  4EB8 1276                863      JSR print
0000178E  6000 FAE4                864      BRA out
00001792                           865      
00001792                           866  print_w     *print '.W'
00001792  43F8 0450                867      LEA word, A1
00001796  4EB8 1276                868      JSR print
0000179A  6000 FAD8                869      BRA out
0000179E                           870      
0000179E                           871  print_l:    *print '.L'
0000179E  43F8 044C                872      LEA long, A1
000017A2  4EB8 1276                873      JSR print
000017A6  6000 FACC                874      BRA out
000017AA                           875  
000017AA                           876  size:       *print size for non "move" instructions
000017AA  4284                     877      CLR.L D4
000017AC  1802                     878      MOVE.B D2,D4
000017AE  C83C 00C0                879      AND.B #$C0, D4
000017B2  B83C 0000                880      CMP.B #$00, D4
000017B6  67CE                     881      BEQ print_b
000017B8  B83C 0040                882      CMP.B #$40,D4
000017BC  67D4                     883      BEQ print_w
000017BE  B83C 0080                884      CMP.B #$80, D4
000017C2  67DA                     885      BEQ print_l
000017C4  4E75                     886      RTS
000017C6                           887      
000017C6                           888  * ------- End Instruction sizes ---------*
000017C6                           889  
000017C6                           890  * ------- Effective Address -------*
000017C6                           891  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000017C6  3A02                     892      MOVE.W D2, D5
000017C8  3C02                     893      MOVE.W D2, D6               
000017CA  BE3C 0001                894      CMP.B #1, D7
000017CE  6700 003A                895      BEQ destination *check if evaluating destination address (used for MOVE)
000017D2                           896  cont
000017D2  CC3C 0038                897      AND.B #$38, D6
000017D6  BC3C 0000                898      CMP.B #0, D6
000017DA  6700 0038                899      BEQ data_reg        *check if EA mode is data register
000017DE  BC3C 0008                900      CMP.B #$08, D6
000017E2  6700 0048                901      BEQ add_reg         *check if EA mode is address register
000017E6  BC3C 0010                902      CMP.B #$10, D6
000017EA  6700 0058                903      BEQ add_indirect    *check if EA mode is address indirect
000017EE  BC3C 0018                904      CMP.B #$18, D6
000017F2  6700 0070                905      BEQ post_increment  *check if EA mode is post increment
000017F6  BC3C 0020                906      CMP.B #$20, D6
000017FA  6700 0088                907      BEQ pre_decrement   *check if EA mode is pre_decrement
000017FE  BC3C 0038                908      CMP.B #$38, D6
00001802  6700 00A0                909      BEQ absolute_or_immediate
00001806  6000 FA6C                910      BRA out *needs Immediate, Abs Long, and Abs Word
0000180A                           911  destination     *perform correct rotation to retrieve destination address
0000180A  3C05                     912      MOVE.W D5,D6
0000180C  EF5D                     913      ROL.W #7,D5
0000180E  E64E                     914      LSR.W #3,D6
00001810  60C0                     915      BRA cont
00001812  4E75                     916      RTS
00001814                           917  
00001814                           918  data_reg    *used with addr sub routine
00001814  3C05                     919      MOVE.W D5,D6    
00001816  CC3C 0007                920      AND.B #$07, D6  
0000181A  43F8 04C1                921      LEA D_reg, A1   
0000181E  4EB8 1276                922      JSR print
00001822  4EB9 0000193E            923      JSR Xn
00001828  6000 FA4A                924      BRA out
0000182C                           925  
0000182C                           926  add_reg     *used with addr sub routine
0000182C  3C05                     927      MOVE.W D5,D6    
0000182E  CC3C 0007                928      AND.B #$07, D6
00001832  43F8 04C3                929      LEA A_reg, A1   
00001836  4EB8 1276                930      JSR print
0000183A  4EB9 0000193E            931      JSR Xn
00001840  6000 FA32                932      BRA out
00001844                           933      
00001844                           934  add_indirect    *used with addr sub routine
00001844  3C05                     935      MOVE.W D5,D6    
00001846  CC3C 0007                936      AND.B #$07, D6
0000184A  43F8 04C5                937      LEA open_paran, A1  
0000184E  4EB8 1276                938      JSR print
00001852  4EB9 0000193E            939      JSR Xn
00001858  43F8 04C8                940      LEA close_paran, A1 
0000185C  4EB8 1276                941      JSR print
00001860  6000 FA12                942      BRA out
00001864                           943      
00001864                           944  post_increment  *used with addr sub routine
00001864  3C05                     945      MOVE.W D5,D6    
00001866  CC3C 0007                946      AND.B #$07, D6
0000186A  43F8 04C5                947      LEA open_paran, A1  
0000186E  4EB8 1276                948      JSR print
00001872  4EB9 0000193E            949      JSR Xn
00001878  43F8 04CA                950      LEA post_inc, A1    
0000187C  4EB8 1276                951      JSR print
00001880  6000 F9F2                952      BRA out
00001884                           953      
00001884                           954  pre_decrement   *used with addr sub routine
00001884  3C05                     955      MOVE.W D5,D6    
00001886  CC3C 0007                956      AND.B #$07, D6
0000188A  43F8 04CD                957      LEA pre_dec, A1 
0000188E  4EB8 1276                958      JSR print
00001892  4EB9 0000193E            959      JSR Xn
00001898  43F8 04C8                960      LEA close_paran, A1 
0000189C  4EB8 1276                961      JSR print
000018A0  6000 F9D2                962      BRA out
000018A4                           963  
000018A4                           964  absolute_or_immediate *check if EA is immediate or absolute address
000018A4  3C05                     965      MOVE.W D5,D6    
000018A6  CC3C 0007                966      AND.B #$07, D6
000018AA  BC3C 0000                967      CMP.B #$00, D6
000018AE  6700 0054                968      BEQ w_imm
000018B2  BC3C 0001                969      CMP.B #$01, D6
000018B6  6700 0068                970      BEQ l_imm
000018BA  BC3C 0004                971      CMP.B #04, D6
000018BE  6700 0002                972      BEQ immediate
000018C2                           973      
000018C2                           974  immediate
000018C2  43F8 04D6                975      LEA pound, A1
000018C6  4EB8 1276                976      JSR print
000018CA  B4BC 00004000            977      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
000018D0  6D00 0016                978      BLT move_movea      *check if instruction is move or movea
000018D4  B8BC 00000040            979      CMP.L #$0040, D4        *if not move or movea
000018DA  6F00 0028                980      BLE w_imm           *byte and word check the next 2 addresses in mem
000018DE  B8BC 00000080            981      CMP.L #$0080, D4
000018E4  6700 003A                982      BEQ l_imm           *long checks the next 4 addresses in mem
000018E8                           983  move_movea              *similar comparisons, but for different bits in OPCODE
000018E8  B87C 1000                984      CMP.W #$1000, D4
000018EC  6700 0016                985      BEQ w_imm
000018F0  B87C 3000                986      CMP.W #$3000, D4
000018F4  6700 000E                987      BEQ w_imm
000018F8  B87C 2000                988      CMP.W #$2000, D4
000018FC  6700 0022                989      BEQ l_imm
00001900                           990  imm_complete
00001900  6000 F972                991      BRA out
00001904                           992      
00001904                           993  w_imm
00001904  43F8 04E6                994      LEA dollar, A1      *print '$'
00001908  4EB8 1276                995      JSR print
0000190C  544C                     996      ADDA.W #2,A4        *update current address
0000190E  3214                     997      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001910  3602                     998      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001912  343C 0010                999      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001916  103C 000F               1000      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000191A  4E4F                    1001      TRAP #15
0000191C  3403                    1002      MOVE.W D3,D2        *copy opcode back to register D2
0000191E  60E0                    1003      BRA imm_complete    *exit addr subroutine
00001920                          1004      
00001920                          1005  l_imm
00001920  43F8 04E6               1006      LEA dollar, A1      *print '$'
00001924  4EB8 1276               1007      JSR print
00001928  544C                    1008      ADDA.W  #2,A4       *update current address
0000192A  2214                    1009      MOVE.L (A4),D1      *retrieve long data stored in the new current address
0000192C  3602                    1010      MOVE.W D2, D3
0000192E  343C 0010               1011      MOVE.W #16, D2
00001932  103C 000F               1012      MOVE.B #15, D0
00001936  4E4F                    1013      TRAP #15
00001938  3403                    1014      MOVE.W D3,D2
0000193A  544C                    1015      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
0000193C  60C2                    1016      BRA imm_complete    *exit addr subroutine
0000193E                          1017  
0000193E                          1018  Xn:                     *retieve signed decimal value of data stored in register D6
0000193E  4281                    1019      CLR.L D1
00001940  1206                    1020      MOVE.B D6,D1
00001942  103C 0003               1021      MOVE.B #3, D0
00001946  4E4F                    1022      TRAP #15
00001948  4E75                    1023      RTS
0000194A                          1024  
0000194A                          1025  data_reg_sr:    *use if dealing with Dn only
0000194A  4286                    1026      CLR.L D6
0000194C  3C05                    1027      MOVE.W D5,D6
0000194E  EF5E                    1028      ROL.W #7,D6
00001950  CC3C 0007               1029      AND.B #$07, D6  
00001954  43F8 04C1               1030      LEA D_reg, A1   
00001958  4EB8 1276               1031      JSR print
0000195C  4EB8 193E               1032      JSR Xn
00001960  4E75                    1033      RTS
00001962                          1034      
00001962                          1035  add_reg_sr:     *use if dealing with An only
00001962  4286                    1036      CLR.L D6
00001964  3C02                    1037      MOVE.W D2,D6
00001966  EF5E                    1038      ROL.W #7,D6
00001968  CC3C 0007               1039      AND.B #$07, D6  
0000196C  43F8 04C3               1040      LEA A_reg, A1   
00001970  4EB8 1276               1041      JSR print
00001974  4EB8 193E               1042      JSR Xn
00001978  4E75                    1043      RTS
0000197A                          1044      
0000197A                          1045  movem_predec:           *needs to be worked on
0000197A  4285                    1046      CLR.L D5
0000197C  544C                    1047      ADDA.W  #2,A4       *update current address
0000197E  3A14                    1048      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001980  BA3C 0000               1049      CMP.B #$00, D5
00001984  6700 006C               1050      BEQ predec_skip_to_d
00001988  3C05                    1051      MOVE.W D5,D6
0000198A  4281                    1052      CLR.L D1
0000198C  123C 0000               1053      MOVE.B #0, D1
00001990                          1054  a_loop1
00001990  E31E                    1055      ROL.B #1,D6
00001992  6500 0006               1056      BCS a_loop1_done
00001996  5201                    1057      ADD.B #1,D1
00001998  60F6                    1058      BRA a_loop1
0000199A                          1059  a_loop1_done
0000199A  43F8 04C3               1060      LEA A_reg,A1
0000199E  4EB8 1276               1061      JSR print
000019A2  103C 0003               1062      MOVE.B #3,D0
000019A6  4E4F                    1063      TRAP #15
000019A8  4287                    1064      CLR.L D7
000019AA  1E3C 0000               1065      MOVE.B #0, D7
000019AE                          1066  a_loop2
000019AE  E31E                    1067      ROL.B #1,D6
000019B0  6400 0010               1068      BCC a_loop2_done
000019B4  5207                    1069      ADD.B #1,D7
000019B6  5201                    1070      ADD.B #1,D1
000019B8  B23C 0007               1071      CMP.B #7, D1
000019BC  6700 0004               1072      BEQ a_loop2_done
000019C0  60EC                    1073      BRA a_loop2
000019C2                          1074  a_loop2_done
000019C2  BE3C 0000               1075      CMP.B #0, D7
000019C6  6700 0018               1076      BEQ predec_no_dash
000019CA  43F8 04D8               1077      LEA dash, A1
000019CE  4EB8 1276               1078      JSR print
000019D2  43F8 04C3               1079      LEA A_reg,A1
000019D6  4EB8 1276               1080      JSR print
000019DA  103C 0003               1081      MOVE.B #3,D0
000019DE  4E4F                    1082      TRAP #15
000019E0                          1083  predec_no_dash
000019E0  BABC 000000FF           1084      CMP.L #$00FF,D5
000019E6  6F00 0062               1085      BLE end_movem_predec
000019EA  43F8 04DA               1086      LEA slash, A1
000019EE  4EB8 1276               1087      JSR print
000019F2                          1088  predec_skip_to_d    
000019F2  3C05                    1089      MOVE.W D5,D6
000019F4  E04E                    1090      LSR.W #8,D6
000019F6  4281                    1091      CLR.L D1
000019F8  123C 0000               1092      MOVE.B #0, D1
000019FC                          1093  d_loop1
000019FC  E31E                    1094      ROL.B #1,D6
000019FE  6500 0006               1095      BCS d_loop1_done
00001A02  5201                    1096      ADD.B #1,D1
00001A04  60F6                    1097      BRA d_loop1
00001A06                          1098  d_loop1_done
00001A06  43F8 04C1               1099      LEA D_reg,A1
00001A0A  4EB8 1276               1100      JSR print
00001A0E  103C 0003               1101      MOVE.B #3,D0
00001A12  4E4F                    1102      TRAP #15
00001A14  4287                    1103      CLR.L D7
00001A16  1E3C 0000               1104      MOVE.B #0, D7
00001A1A                          1105  d_loop2
00001A1A  E31E                    1106      ROL.B #1,D6
00001A1C  6400 000E               1107      BCC d_loop2_done
00001A20  5201                    1108      ADD.B #1,D1
00001A22  B23C 0007               1109      CMP.B #7, D1
00001A26  6700 0004               1110      BEQ d_loop2_done
00001A2A  60EE                    1111      BRA d_loop2
00001A2C                          1112  d_loop2_done
00001A2C  BE3C 0000               1113      CMP.B #0, D7
00001A30  6F00 0018               1114      BLE end_movem_predec
00001A34  43F8 04D8               1115      LEA dash, A1
00001A38  4EB8 1276               1116      JSR print
00001A3C  43F8 04C1               1117      LEA D_reg,A1
00001A40  4EB8 1276               1118      JSR print
00001A44  103C 0003               1119      MOVE.B #3,D0
00001A48  4E4F                    1120      TRAP #15
00001A4A                          1121  end_movem_predec
00001A4A  4E75                    1122      RTS
00001A4C                          1123      
00001A4C                          1124  movem_postinc:          *needs to be worked on
00001A4C  4285                    1125      CLR.L D5
00001A4E  544C                    1126      ADDA.W  #2,A4       *update current address
00001A50  3A14                    1127      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A52  3C05                    1128      MOVE.W D5,D6
00001A54  E04E                    1129      LSR.W #8,D6
00001A56  BC3C 0000               1130      CMP.B #$00, D6
00001A5A  6700 0068               1131      BEQ postinc_skip_to_d
00001A5E  4281                    1132      CLR.L D1
00001A60  123C 0000               1133      MOVE.B #0, D1
00001A64                          1134  a_loop3
00001A64  E21E                    1135      ROR.B #1,D6
00001A66  6500 0006               1136      BCS a_loop3_done
00001A6A  5201                    1137      ADD.B #1,D1
00001A6C  60F6                    1138      BRA a_loop3
00001A6E                          1139  a_loop3_done
00001A6E  43F8 04C3               1140      LEA A_reg,A1
00001A72  4EB8 1276               1141      JSR print
00001A76  103C 0003               1142      MOVE.B #3,D0
00001A7A  4E4F                    1143      TRAP #15
00001A7C  4287                    1144      CLR.L D7
00001A7E  1E3C 0000               1145      MOVE.B #0, D7
00001A82                          1146  a_loop4
00001A82  E21E                    1147      ROR.B #1,D6
00001A84  6400 0010               1148      BCC a_loop4_done
00001A88  5207                    1149      ADD.B #1,D7
00001A8A  5201                    1150      ADD.B #1,D1
00001A8C  B23C 0007               1151      CMP.B #7, D1
00001A90  6700 0004               1152      BEQ a_loop4_done
00001A94  60EC                    1153      BRA a_loop4
00001A96                          1154  a_loop4_done
00001A96  BE3C 0000               1155      CMP.B #0, D7
00001A9A  6700 0018               1156      BEQ postinc_no_dash
00001A9E  43F8 04D8               1157      LEA dash, A1
00001AA2  4EB8 1276               1158      JSR print
00001AA6  43F8 04C3               1159      LEA A_reg,A1
00001AAA  4EB8 1276               1160      JSR print
00001AAE  103C 0003               1161      MOVE.B #3,D0
00001AB2  4E4F                    1162      TRAP #15
00001AB4                          1163  postinc_no_dash
00001AB4  BA3C 0000               1164      CMP.B #$00, D5
00001AB8  6700 0060               1165      BEQ end_movem_postinc
00001ABC  43F8 04DA               1166      LEA slash, A1
00001AC0  4EB8 1276               1167      JSR print
00001AC4                          1168  postinc_skip_to_d   
00001AC4  3C05                    1169      MOVE.W D5,D6
00001AC6  4281                    1170      CLR.L D1
00001AC8  123C 0000               1171      MOVE.B #0, D1
00001ACC                          1172  d_loop3
00001ACC  E21E                    1173      ROR.B #1,D6
00001ACE  6500 0006               1174      BCS d_loop3_done
00001AD2  5201                    1175      ADD.B #1,D1
00001AD4  60F6                    1176      BRA d_loop3
00001AD6                          1177  d_loop3_done
00001AD6  43F8 04C1               1178      LEA D_reg,A1
00001ADA  4EB8 1276               1179      JSR print
00001ADE  103C 0003               1180      MOVE.B #3,D0
00001AE2  4E4F                    1181      TRAP #15
00001AE4  4287                    1182      CLR.L D7
00001AE6  1E3C 0000               1183      MOVE.B #0, D7
00001AEA                          1184  d_loop4
00001AEA  E21E                    1185      ROR.B #1,D6
00001AEC  6400 000E               1186      BCC d_loop4_done
00001AF0  5201                    1187      ADD.B #1,D1
00001AF2  B23C 0007               1188      CMP.B #7, D1
00001AF6  6700 0004               1189      BEQ d_loop4_done
00001AFA  60EE                    1190      BRA d_loop4
00001AFC                          1191  d_loop4_done
00001AFC  BE3C 0000               1192      CMP.B #0, D7
00001B00  6F00 0018               1193      BLE end_movem_postinc
00001B04  43F8 04D8               1194      LEA dash, A1
00001B08  4EB8 1276               1195      JSR print
00001B0C  43F8 04C1               1196      LEA D_reg,A1
00001B10  4EB8 1276               1197      JSR print
00001B14  103C 0003               1198      MOVE.B #3,D0
00001B18  4E4F                    1199      TRAP #15
00001B1A                          1200  end_movem_postinc
00001B1A  4E75                    1201      RTS
00001B1C                          1202  
00001B1C                          1203  
00001B1C                          1204  * ------- End Effective Address -------*
00001B1C                          1205  
00001B1C                          1206  * ----- Hex to ASCII & ASCII to HEX -----*
00001B1C                          1207  
00001B1C                          1208  ASCIItoHex:
00001B1C  4EB9 00001B2A           1209          jsr     ASCII2Hex_init  
00001B22  4EB9 00001B30           1210          jsr     conversion_loop
00001B28  4E75                    1211          rts                    
00001B2A                          1212  
00001B2A                          1213  ASCII2Hex_init:   
00001B2A  143C 0000               1214          move.b  #0,D2       *set up counter    
00001B2E  4E75                    1215          rts         
00001B30                          1216          
00001B30                          1217  conversion_loop:            
00001B30  5282                    1218          add.l   #1,D2       *increment counter
00001B32  B4BC 00000009           1219          cmp.l   #9,D2       *ends at 9
00001B38  6700 004A               1220          BEQ     DONE        *branch when compare is true
00001B3C  1819                    1221          move.b  (A1)+,D4    *Get first num
00001B3E                          1222          
00001B3E  B83C 0040               1223          cmp.b   #$40,D4        
00001B42  6E00 000C               1224          bgt     Letters_Cap  
00001B46                          1225          
00001B46  B83C 0039               1226          cmp.b   #$39,D4
00001B4A  6F00 0016               1227          BLE     Numbers      
00001B4E  4E75                    1228          rts
00001B50                          1229          
00001B50                          1230  Letters_Cap:      
00001B50  B83C 0046               1231          cmp.b   #$46,D4          
00001B54  6E00 001E               1232          bgt     ERROR  
00001B58  0404 0037               1233          sub.b   #$37,D4     
00001B5C  E986                    1234          asl.l   #4,D6       
00001B5E  DC84                    1235          add.l   D4,D6     
00001B60  60CE                    1236          bra     conversion_loop 
00001B62                          1237  Numbers:
00001B62  B83C 0030               1238          cmp.b   #$30,D4         
00001B66  6D00 000C               1239          blt     ERROR        
00001B6A  0404 0030               1240          sub.b   #$30,D4      
00001B6E  E986                    1241          asl.l   #4,D6        
00001B70  DC84                    1242          add.l   D4,D6     
00001B72  60BC                    1243          bra     conversion_loop
00001B74                          1244          
00001B74                          1245  ERROR:
00001B74  43F8 011E               1246          lea     ErrorMsg,A1    
00001B78  103C 000E               1247          move.b  #14,D0
00001B7C  4E4F                    1248          trap    #15
00001B7E                          1249      
00001B7E  103C 0009               1250          move.b  #9,D0
00001B82  4E4F                    1251          trap    #15
00001B84                          1252          
00001B84                          1253  DONE:
00001B84                          1254     
00001B84  4241                    1255          clr     D1
00001B86  4242                    1256          clr     D2
00001B88  4244                    1257          clr     D4
00001B8A                          1258      
00001B8A  43F8 014F               1259          lea     ASCIItoHexMsg,A1
00001B8E  103C 000E               1260          move.b  #14,D0
00001B92  4E4F                    1261          trap    #15
00001B94                          1262  
00001B94  4E75                    1263          rts
00001B96                          1264          
00001B96                          1265  
00001B96                          1266          
00001B96                          1267  * -- End of Hex to ASCII & ASCII to HEX --*
00001B96                          1268  
00001B96                          1269  * Put program code here
00001B96                          1270  
00001B96  FFFF FFFF               1271      SIMHALT             ; halt simulator
00001B9A                          1272  
00001B9A                          1273  * Put variables and constants here
00001B9A                          1274  
00001B9A                          1275      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  18A4
ADDA_INS            47C
ADDA_SIZE           13B4
ADDQ_INS            481
ADDR                17C6
ADD_A               1392
ADD_INDIRECT        1844
ADD_INS             478
ADD_REG             182C
ADD_REG_SR          1962
ANDQ_INS            4A8
AND_INS             489
ASCII2HEX_INIT      1B2A
ASCIITOHEX          1B1C
ASCIITOHEXMSG       14F
AS_INS              494
A_LOOP1             1990
A_LOOP1_DONE        199A
A_LOOP2             19AE
A_LOOP2_DONE        19C2
A_LOOP3             1A64
A_LOOP3_DONE        1A6E
A_LOOP4             1A82
A_LOOP4_DONE        1A96
A_REG               4C3
BEQ_INS             4B5
BGT_INS             4AD
BLE_INS             4B1
BRA_INS             4B9
BYTE                454
CHECKADDRESS        10E8
CHECK_WORD          167A
CLEARDONE           1124
CLEARSCREEN         10F6
CLEARSCREEN_40      110C
CLEAR_REGISTERS     1054
CLOSE_PARAN         4C8
COMMA               4D3
CONT                17D2
CONTINUEORNOTMSG    206
CONTINUE_INSTRUCTION_LS_AS_RO  1508
CONVERSION_LOOP     1B30
CR                  D
CREATORS            1F
DASH                4D8
DATA                4DF
DATA_REG            1814
DATA_REG_SR         194A
DESTINATION         180A
DOLLAR              4E6
DONE                1B84
D_LOOP1             19FC
D_LOOP1_DONE        1A06
D_LOOP2             1A1A
D_LOOP2_DONE        1A2C
D_LOOP3             1ACC
D_LOOP3_DONE        1AD6
D_LOOP4             1AEA
D_LOOP4_DONE        1AFC
D_REG               4C1
EA_DEST_ADD         1378
EA_DEST_SUB_AND_OR  145A
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13D4
END_ADDR_BUFFER     34C
END_BRA_BCC         169C
END_MOVEM           1708
END_MOVEM_POSTINC   1B1A
END_MOVEM_PREDEC    1A4A
ENTER               1288
ENTER_PRESS_TRUE    11BE
ERROR               1B74
ERRORMSG            11E
EXITMSG             23C
FLUSHSCREEN         119A
FLUSHSCREENMSG      190
FLUSHSCREEN_INPUT   11AC
GETENDADDRESS       10CE
GETSTARTADDRESS     10B4
HELPMSG             1CA
HEXTOASCIIMSG       12D
IMMEDIATE           18C2
IMM_COMPLETE        1900
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             1258
JSR_INS             49E
LEA_INS             4A3
LEFT                4BF
LETTERS_CAP         1B50
LF                  A
LONG                44C
LS_AS_RO_MEM        151E
LS_AS_RO_REG        1500
LS_INS              491
L_IMM               1920
MEMSEARCH           1126
MEMSEARCHLOOP       113A
MEMSEARCH_DONE      1174
MEM_TO_REG          16F4
MENU                1090
MOVEA_INS           472
MOVEM_DIRECTION     16CE
MOVEM_INS           46C
MOVEM_LONG          16C6
MOVEM_POSTINC       1A4C
MOVEM_PREDEC        197A
MOVEQ_INS           465
MOVE_A              1304
MOVE_INS            460
MOVE_MOVEA          18E8
MOVE_SIZE           1764
MUL_DIV             1478
MUL_DIV_LONG        149A
M_SIZE              130C
NEXT_ADD            13C0
NEXT_BRA_BCC        1648
NEXT_LS_AS_RO       154C
NOP_INS             458
NOT_INS             49A
NUMBERS             1B62
OPCODE_DECODE       11C0
OPEN_PARAN          4C5
OR_INS              486
OUT                 1274
POSTINC_NO_DASH     1AB4
POSTINC_SKIP_TO_D   1AC4
POST_INC            4CA
POST_INCREMENT      1864
POUND               4D6
PREDEC_NO_DASH      19E0
PREDEC_SKIP_TO_D    19F2
PRE_DEC             4CD
PRE_DECREMENT       1884
PRINT               1276
PRINTLN             1280
PRINT_ADDQ          15B8
PRINT_ADD_ADDA      1334
PRINT_AS            1752
PRINT_B             1786
PRINT_BEQ           1628
PRINT_BGT           1640
PRINT_BLE           1634
PRINT_BRA           161C
PRINT_BRA_BCC       15F2
PRINT_CORRECT_SHIFT_ROTATION  1732
PRINT_DIRECTION     1710
PRINT_INSTRUCTION   1428
PRINT_IT            175E
PRINT_JSR           157E
PRINT_L             179E
PRINT_LEA           1594
PRINT_LEFT          1728
PRINT_LS            175A
PRINT_LS_AS_RO      14A0
PRINT_MOVEM         16A4
PRINT_MOVEQ         12A6
PRINT_MOVE_MOVEA    12EA
PRINT_NOP           1292
PRINT_NOT           1554
PRINT_OR            1424
PRINT_RTS           129C
PRINT_SUB           140E
PRINT_SUB_AND_OR    13DC
PRINT_W             1792
RETURN              4DC
RIGHT               4BD
RO_INS              497
RTS_INS             45C
SCREENFLUSH_CHECK   1190
SIZE                17AA
SLASH               4DA
SPACE               4D1
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   24C
SUB_INS             48D
TAB                 9
TERMINATEORCONT     1180
WORD                450
W_IMM               1904
XN                  193E
