00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 10:10:24 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius Hartanto',CR,LF,0
00000057                            12  
00000057= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
00000098= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000D0= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000ED= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
00000127= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
00000136                            18  
00000136= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
00000158= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
0000017C                            21  
0000017C= 2D 2D 2D 46 69 6E ...     22  EndOfMemLoop        dc.b    '---Finished Reading Instructions---',CR,LF,0
000001A2= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to view the next set of instructions',0
000001D3= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
0000020F= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
00000245= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000255                            27  
00000255                            28  *size
00000255= 2E 4C 20 00               29  long                DC.B    '.L ',0
00000259= 2E 57 20 00               30  word                DC.B    '.W ',0
0000025D= 2E 42 20 00               31  byte                DC.B    '.B ',0
00000261                            32  
00000261                            33  *instructions
00000261= 4E 4F 50 00               34  nop_ins             DC.B    'NOP',0
00000265= 52 54 53 00               35  rts_ins             DC.B    'RTS',0
00000269= 4D 4F 56 45 00            36  move_ins            DC.B    'MOVE',0
0000026E= 4D 4F 56 45 51 20 00      37  moveq_ins           DC.B    'MOVEQ ',0
00000275= 4D 4F 56 45 4D 00         38  movem_ins           DC.B    'MOVEM',0
0000027B= 4D 4F 56 45 41 00         39  movea_ins           DC.B    'MOVEA',0
00000281= 41 44 44 00               40  add_ins             DC.B    'ADD',0
00000285= 41 44 44 41 00            41  adda_ins            DC.B    'ADDA',0
0000028A= 41 44 44 51 00            42  addq_ins            DC.B    'ADDQ',0
0000028F= 4F 52 00                  43  or_ins              DC.B    'OR',0
00000292= 41 4E 44 00               44  and_ins             DC.B    'AND',0
00000296= 53 55 42 00               45  sub_ins             DC.B    'SUB',0
0000029A= 4C 53 00                  46  ls_ins              DC.B    'LS',0
0000029D= 41 53 00                  47  as_ins              DC.B    'AS',0
000002A0= 52 4F 00                  48  ro_ins              DC.B    'RO',0
000002A3= 4E 4F 54 00               49  not_ins             DC.B    'NOT',0
000002A7= 4A 53 52 20 00            50  jsr_ins             DC.B    'JSR ',0
000002AC= 4C 45 41 20 00            51  lea_ins             DC.B    'LEA ',0
000002B1= 41 44 44 51 00            52  andq_ins            DC.B    'ADDQ',0
000002B6= 42 47 54 00               53  bgt_ins             DC.B    'BGT',0
000002BA= 42 4C 45 00               54  ble_ins             DC.B    'BLE',0
000002BE= 42 45 51 00               55  beq_ins             DC.B    'BEQ',0
000002C2= 42 52 41 00               56  bra_ins             DC.B    'BRA',0
000002C6                            57  
000002C6                            58  *direction
000002C6= 52 00                     59  right               DC.B    'R',0
000002C8= 4C 00                     60  left                DC.B    'L',0
000002CA                            61  
000002CA                            62  *EA
000002CA= 44 00                     63  D_reg               DC.B    'D',0
000002CC= 41 00                     64  A_reg               DC.B    'A',0
000002CE= 28 41 00                  65  open_paran          DC.B    '(A',0
000002D1= 29 00                     66  close_paran         DC.B    ')',0
000002D3= 29 2B 00                  67  post_inc            DC.B    ')+',0
000002D6= 2D 28 41 00               68  pre_dec             DC.B    '-(A',0
000002DA                            69  
000002DA                            70  *extra
000002DA= 20 00                     71  space               DC.B    ' ',0
000002DC= 2C 20 00                  72  comma               DC.B    ', ',0
000002DF= 23 00                     73  pound               DC.B    '#',0
000002E1= 2D 00                     74  dash                DC.B    '-',0
000002E3= 2F 00                     75  slash               DC.B    '/',0
000002E5  =00000009                 76  tab                 EQU     $9
000002E5= 0D 0A 00                  77  return              DC.B    CR,LF,0
000002E8= 44 41 54 41 20 24 00      78  data                DC.B    'DATA $',0
000002EF= 49 6E 76 61 6C 69 ...     79  ea                  DC.B    'Invalid Effective Address', 0
00000309= 24 00                     80  dollar              DC.B    '$',0
0000030B                            81      
00001000                            82      ORG    $1000    *Start at address $1000
00001000                            83  START:                  ; first instruction of program
00001000                            84  
00001000                            85  *---------- Beginning Messages ----------*
00001000                            86      
00001000  103C 000E                 87      move.b      #14,D0
00001004  43F8 0000                 88      lea         StartingMsg,A1 
00001008  4E4F                      89      trap        #15
0000100A                            90      
0000100A  103C 000E                 91      move.b      #14,D0
0000100E  43F8 001F                 92      lea         Creators,A1
00001012  4E4F                      93      trap        #15
00001014                            94      
00001014  4EB9 00001066             95      jsr         MENU
0000101A                            96      
0000101A                            97  * ---------- END OF PROGRAM -------------*
0000101A                            98  
0000101A  103C 000E                 99      move.b      #14,D0
0000101E  43F8 0245                100      lea         ExitMsg,A1 
00001022  4E4F                     101      trap        #15
00001024                           102      
00001024  103C 0009                103      move.b      #9,D0
00001028  4E4F                     104      trap        #15
0000102A                           105  * ---------------------------------------*
0000102A                           106      
0000102A                           107  *-- End of Opening and Ending Messages --*
0000102A                           108  
0000102A                           109  *--------- Start of I/O Section ---------*
0000102A                           110  
0000102A                           111  Clear_Registers:
0000102A  4280                     112      clr.l     D0
0000102C  4281                     113      clr.l     D1
0000102E  4282                     114      clr.l     D2
00001030  4283                     115      clr.l     D3
00001032  4284                     116      clr.l     D4
00001034  4285                     117      clr.l     D5
00001036  4286                     118      clr.l     D6
00001038  4287                     119      clr.l     D7
0000103A                           120      
0000103A  207C 00000000            121      movea.l   #0,A0
00001040  227C 00000000            122      movea.l   #0,A1
00001046  247C 00000000            123      movea.l   #0,A2
0000104C  267C 00000000            124      movea.l   #0,A3
00001052  287C 00000000            125      movea.l   #0,A4
00001058  2A7C 00000000            126      movea.l   #0,A5
0000105E  2C7C 00000000            127      movea.l   #0,A6
00001064  4E75                     128      rts
00001066                           129  
00001066                           130  MENU:
00001066  4EB8 102A                131      jsr         Clear_Registers
0000106A  4EB9 0000109E            132      jsr         GetStartAddress
00001070  4EB9 000010BE            133      jsr         GetEndAddress 
00001076  BBCC                     134      cmp.l       A4, A5
00001078  6F00 0006                135      ble         invalid_input
0000107C  6000 0018                136      bra         menu_cont
00001080                           137  invalid_input
00001080  43F8 00ED                138      lea         EndAddressInc, A1
00001084  103C 000E                139      move.b      #14, D0
00001088  4E4F                     140      trap        #15
0000108A  43F8 02E5                141      lea         return, A1
0000108E  4EB9 00001280            142      jsr         print
00001094  60D0                     143      bra         MENU
00001096                           144  menu_cont
00001096  4EB9 000010F6            145      jsr         MemSearch
0000109C  4E75                     146      rts
0000109E                           147      
0000109E                           148  GetStartAddress:         *Display input message
0000109E  103C 000E                149      move.b      #14, D0
000010A2  43F8 0057                150      lea         InputMsg1,A1
000010A6  4E4F                     151      trap        #15
000010A8  227C 00000000            152      MOVEA.L     #0, A1
000010AE  103C 0002                153      move.b      #2,D0
000010B2  4E4F                     154      trap        #15   
000010B4  4EB9 00001B4A            155      jsr         ASCIItoHex              *conversion to Hex
000010BA                           156      * Address Located in D6
000010BA  2846                     157      movea.l     D6,A4           *move into address register 4
000010BC  4E75                     158      rts
000010BE                           159      
000010BE                           160  GetEndAddress:
000010BE  103C 000E                161      move.b      #14,D0          *Display input message
000010C2  43F8 0098                162      lea         InputMsg2,A1
000010C6  4E4F                     163      trap        #15
000010C8  227C 00000000            164      MOVEA.L     #0, A1
000010CE  103C 0002                165      move.b      #2,D0
000010D2  4E4F                     166      trap        #15
000010D4                           167      
000010D4  4EB9 00001B4A            168      jsr         ASCIItoHex      *conversion to hex
000010DA                           169      * Address Located in D6 (overwrite)
000010DA  2A46                     170      movea.l     D6,A5           *move into address register 5
000010DC  4E75                     171      rts
000010DE                           172  
000010DE                           173  
000010DE                           174  ClearScreen:
000010DE  43F8 02E5                175      lea         return,A1
000010E2  103C 000E                176      move.b      #14,D0
000010E6  4E4F                     177      trap        #15
000010E8  B27C 0028                178      cmp.w       #40,D1
000010EC  6700 0006                179      beq         ClearDone
000010F0  5241                     180      add.w       #1,D1
000010F2  60EA                     181      bra         ClearScreen
000010F4                           182      
000010F4                           183  ClearDone:
000010F4  4E75                     184      rts
000010F6                           185      
000010F6                           186  MemSearch:
000010F6  7200                     187      move.l      #0,D1
000010F8  4EB8 10DE                188      jsr         ClearScreen
000010FC                           189      * Set up instruction counter and place onto stack
000010FC  303C 0000                190      move.w      #0,D0
00001100  3F00                     191      move.w      D0,-(SP)
00001102  4EB9 0000110A            192      jsr         MemSearchLoop
00001108  4E75                     193      rts
0000110A                           194      
0000110A                           195  MemSearchLoop:
0000110A                           196      
0000110A                           197      * Check if we reached the end address
0000110A  BBCC                     198      cmp.l       A4,A5
0000110C  6700 0036                199      beq         MemSearch_Done
00001110                           200      
00001110                           201      * Get data from memory
00001110  4241                     202      CLR D1
00001112  3414                     203      move.w      (A4),D2
00001114  3602                     204      move.w      D2, D3  mutable copy in D3
00001116                           205      * OPCODE Word Located in D2, mutable copy in D3
00001116  220C                     206      MOVE.L      A4, D1
00001118  143C 0010                207      MOVE.B      #16, D2
0000111C  103C 000F                208      MOVE.B      #15, D0     print address of instruction
00001120  4E4F                     209      TRAP        #15
00001122  3403                     210      MOVE.W      D3,D2
00001124  43F8 02DA                211      LEA         space,A1
00001128  4EB9 00001280            212      JSR         print
0000112E  4EB9 000011B6            213      jsr         OPCODE_DECODE    
00001134                           214      
00001134  544C                     215      adda.w      #2,A4
00001136                           216      
00001136                           217      * Call back counter from the stack
00001136  301F                     218      move.w      (SP)+,D0
00001138  5200                     219      add.b       #1,D0
0000113A  4EB9 00001186            220      jsr         ScreenFlush_Check
00001140  3F00                     221      move.w      D0,-(SP)
00001142                           222      
00001142  60C6                     223      bra         MemSearchLoop
00001144                           224      
00001144                           225  MemSearch_Done
00001144  43F8 017C                226      lea         EndOfMemLoop,A1 
00001148  4EB9 00001280            227      jsr         print
0000114E  43F8 02E5                228      lea         return, A1
00001152  4EB9 00001280            229      jsr         print
00001158  43F8 020F                230      lea         ContinueOrNotMsg, A1
0000115C  4EB9 00001280            231      jsr         print
00001162  103C 0005                232      MOVE.B      #5, D0
00001166  4E4F                     233      TRAP        #15
00001168  4EB9 00001292            234      jsr         enter
0000116E  B23C 0079                235      CMP.B       #121, D1    
00001172  6700 FEF2                236      beq         MENU
00001176  103C 000E                237      move.b      #14,D0
0000117A  43F8 0245                238      lea         ExitMsg, A1 
0000117E  4E4F                     239      trap        #15
00001180  103C 0009                240      move.b      #9,D0
00001184  4E4F                     241      trap        #15
00001186                           242  
00001186                           243  ScreenFlush_Check:
00001186  B03C 0024                244      cmp.b       #36,D0 * 31
0000118A  6700 0004                245      beq         FlushScreen
0000118E  4E75                     246      rts 
00001190                           247  
00001190                           248  FlushScreen:
00001190  43F8 01A2                249      lea         FlushScreenMsg,A1
00001194  103C 000E                250      move.b      #14,D0
00001198  4E4F                     251      trap        #15
0000119A  4EB9 000011A2            252      jsr         FlushScreen_Input
000011A0  4E75                     253      rts
000011A2                           254  
000011A2                           255  FlushScreen_Input:
000011A2  4241                     256      clr     D1
000011A4  103C 0005                257      move.b  #5,D0
000011A8  4E4F                     258      trap    #15
000011AA  B23C 000D                259      cmp.b   #13,D1
000011AE  6700 0004                260      beq     Enter_Press_True    
000011B2  60EE                     261      bra     FlushScreen_Input
000011B4                           262      
000011B4                           263  Enter_Press_True:
000011B4  4E75                     264      rts
000011B6                           265  
000011B6                           266  * -------- Start of Opcode Section -------*    
000011B6                           267  
000011B6                           268  OPCODE_DECODE:
000011B6                           269      * Begin OPCODE Decoding here
000011B6                           270      * Check first four bits and begin
000011B6                           271      * if-branch breakdown
000011B6  4284                     272      CLR.L D4
000011B8  4285                     273      CLR.L D5
000011BA  4286                     274      CLR.L D6
000011BC  4287                     275      CLR.L D7
000011BE                           276      
000011BE  B47C 4E71                277      CMP.W #$4E71, D2        
000011C2  6700 00D8                278      BEQ print_nop           *check if value is NOP
000011C6                           279      
000011C6  B47C 4E75                280      CMP.W #$4E75, D2        
000011CA  6700 00DA                281      BEQ print_rts           *check if value is RTS
000011CE                           282      
000011CE                           283      * Mask out only the first 4 bits
000011CE  C67C F000                284      AND.W #$F000,D3
000011D2                           285      
000011D2  B67C 9000                286      CMP.W #$9000,D3
000011D6  6700 020E                287      BEQ print_sub_and_or    *check if value is SUB
000011DA                           288      
000011DA  B67C 6000                289      CMP.W #$6000,D3
000011DE  6700 041C                290      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011E2                           291      
000011E2  B67C 8000                292      CMP.W #$8000, D3
000011E6  6700 01FE                293      BEQ print_sub_and_or    *check if value is OR
000011EA                           294  
000011EA  B67C C000                295      CMP.W #$C000,D3
000011EE  6700 01F6                296      BEQ print_sub_and_or    *check if value is AND
000011F2                           297      
000011F2  B67C D000                298      CMP.W #$D000,D3
000011F6  6700 0146                299      BEQ print_add_adda      *check if value is ADD or ADDA
000011FA                           300      
000011FA  B67C E000                301      CMP.W #$E000,D3
000011FE  6700 02AA                302      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001202                           303      
00001202  B67C 7000                304      CMP.W #$7000,D3
00001206  6700 00A8                305      BEQ print_moveq     *check if value is MOVEQ
0000120A                           306      
0000120A  B47C 1000                307      CMP.W #$1000,D2
0000120E  6D00 003E                308      BLT invalid
00001212  B47C 4000                309      CMP.W #$4000,D2
00001216  6D00 00DC                310      BLT print_move_movea    *check if value is MOVE or MOVEA
0000121A                           311      
0000121A                           312      * Mask out only the first 8 bits
0000121A  3602                     313      MOVE.W D2, D3
0000121C  C67C FF00                314      AND.W #$FF00,D3
00001220                           315      
00001220  B67C 4600                316      CMP.W #$4600,D3
00001224  6700 0338                317      BEQ print_not           *check if value is NOT
00001228                           318      
00001228  B67C 4E00                319      CMP.W #$4E00,D3
0000122C  6700 035A                320      BEQ print_jsr           *check if value is JSR
00001230                           321      
00001230                           322      * Mask out only the first 4 bits and the 8th bit
00001230  3602                     323      MOVE.W D2,D3
00001232  C67C F100                324      AND.W #$F100, D3
00001236                           325      
00001236  B67C 4000                326      CMP.W #$4000, D3
0000123A  6700 0472                327      BEQ print_movem         *check if value is MOVEM
0000123E                           328      
0000123E  B67C 4100                329      CMP.W #$4100, D3
00001242  6700 035A                330      BEQ print_lea           *check if value is LEA
00001246                           331      
00001246  B67C 5000                332      CMP.W #$5000,D3
0000124A  6700 0376                333      BEQ print_addq          *check if value is ANDQ     
0000124E                           334   
0000124E                           335  invalid 
0000124E  43F8 02E8                336      LEA data, A1
00001252  4EB9 00001280            337      JSR print
00001258  2202                     338      MOVE.L D2, D1
0000125A  143C 0010                339      MOVE.B #16, D2
0000125E  103C 000F                340      MOVE.B  #15, D0     
00001262  4E4F                     341      TRAP #15
00001264  4EB9 00001292            342      JSR enter
0000126A  6000 0012                343      BRA out
0000126E                           344  invalid_ea
0000126E  43F8 02EF                345      LEA ea, A1
00001272  4EB9 00001280            346      JSR print
00001278  4EB9 00001292            347      JSR enter
0000127E  4E75                     348  out rts
00001280                           349    
00001280                           350  * -------- End of Opcode Section --------*   
00001280                           351  
00001280                           352  * --------- Print Instructions ----------*
00001280                           353  
00001280                           354  print:
00001280  4240                     355      CLR D0 
00001282  103C 000E                356      MOVE.B #14,D0
00001286  4E4F                     357      TRAP #15
00001288  4E75                     358      RTS
0000128A                           359  
0000128A                           360  println:
0000128A  103C 000D                361      MOVE.B #13, D0
0000128E  4E4F                     362      TRAP #15
00001290  4E75                     363      RTS
00001292                           364      
00001292                           365  enter: 
00001292  43F8 02E5                366      LEA return, A1
00001296  4EB8 1280                367      JSR print
0000129A  4E75                     368      RTS
0000129C                           369      
0000129C                           370  print_nop
0000129C  43F8 0261                371      LEA nop_ins, A1
000012A0  4EB8 128A                372      JSR println
000012A4  60D8                     373      BRA out
000012A6                           374  
000012A6                           375  print_rts
000012A6  43F8 0265                376      LEA rts_ins, A1
000012AA  4EB8 128A                377      JSR println
000012AE  60CE                     378      BRA out
000012B0                           379      
000012B0                           380  print_moveq
000012B0  43F8 026E                381      lea moveq_ins, A1   *print MOVEQ
000012B4  4EB8 1280                382      jsr print
000012B8  3602                     383      move.w  D2,D3
000012BA  C67C 00FF                384      and.w   #$00FF,D3   * Figure out the immediate address value
000012BE  43F8 02DF                385      lea pound,A1        *print '#'
000012C2  4EB8 1280                386      jsr print
000012C6  43F8 0309                387      LEA dollar, A1
000012CA  4EB8 1280                388      JSR print
000012CE  3203                     389      move.w  D3,D1
000012D0  3602                     390      MOVE.W D2,D3
000012D2  343C 0010                391      MOVE.W #16, D2
000012D6  103C 000F                392      move.b  #15,D0
000012DA  4E4F                     393      trap    #15         *print immediate address value
000012DC  43F8 02DC                394      lea comma,A1        *print comma
000012E0  4EB8 1280                395      jsr print
000012E4  3403                     396      MOVE.W D3, D2
000012E6  3A02                     397      MOVE.W D2, D5
000012E8  4EB9 000019B8            398      JSR data_reg_sr     *figure out data address
000012EE  4EB8 1292                399      jsr enter           *print out enter
000012F2  608A                     400      bra out
000012F4                           401      
000012F4                           402  print_move_movea
000012F4  3602                     403      MOVE.W D2, D3       
000012F6  C67C 01C0                404      AND.W #$01C0, D3
000012FA  B67C 0040                405      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000012FE  6700 000E                406      BEQ move_a
00001302  43F8 0269                407      LEA move_ins, A1 *print Instruction 
00001306  4EB8 1280                408      JSR print
0000130A  6000 000A                409      BRA m_size
0000130E                           410  move_a          *if instruction is MOVEA
0000130E  43F8 027B                411      LEA movea_ins, A1
00001312  4EB8 1280                412      JSR print
00001316                           413  m_size              *determine instruction size
00001316  4EB9 000017D2            414      JSR move_size
0000131C  4EB9 00001834            415      JSR addr        *determine the source address
00001322  43F8 02DC                416      LEA comma, A1   *print comma
00001326  4EB8 1280                417      JSR print
0000132A  4207                     418      CLR.B D7
0000132C  1E3C 0001                419      MOVE.B #1, D7   *determine destination address
00001330  4EB9 00001834            420      JSR addr
00001336  4EB8 1292                421      JSR enter       *print enter
0000133A  6000 FF42                422      BRA out
0000133E                           423      
0000133E                           424  print_add_adda
0000133E  3602                     425      MOVE.W D2, D3   
00001340  C63C 00C0                426      AND.B #$C0, D3
00001344  B63C 00C0                427      CMP.B #$C0, D3      *determine if ADD or ADDA
00001348  6700 0052                428      BEQ add_a
0000134C                           429      *if just ADD then print instruction
0000134C  43F8 0281                430      LEA add_ins, A1
00001350  4EB8 1280                431      JSR print
00001354                           432      *print instruction size for ADD
00001354  4EB9 00001818            433      JSR size
0000135A                           434      *determine direction of ADD, Dn -> EA or EA -> Dn
0000135A  3602                     435      MOVE.W D2,D3
0000135C  C67C 0100                436      AND.W #$0100, D3
00001360  B67C 0100                437      CMP.W #$0100, D3
00001364  6700 001C                438      BEQ ea_dest_add 
00001368  4EB9 00001834            439      JSR addr            *if Direction bit is 0
0000136E  43F8 02DC                440      LEA comma, A1
00001372  4EB8 1280                441      JSR print
00001376  3A02                     442      MOVE.W D2,D5
00001378  4EB9 000019B8            443      JSR data_reg_sr
0000137E  6000 005E                444      BRA end_add
00001382                           445  ea_dest_add             *if Direction bit is 1
00001382  3A02                     446      MOVE.W D2,D5
00001384  4EB9 000019B8            447      JSR data_reg_sr
0000138A  43F8 02DC                448      LEA comma, A1
0000138E  4EB8 1280                449      JSR print
00001392  4EB9 00001834            450      JSR addr
00001398  6000 0044                451      BRA end_add
0000139C                           452  add_a                   *if instruction is ADDA
0000139C  43F8 0285                453      LEA adda_ins, A1
000013A0  4EB8 1280                454      JSR print
000013A4                           455      *print instruction size for ADDA (either W or L)
000013A4  3602                     456      MOVE.W D2,D3
000013A6  C67C 0100                457      AND.W #$0100, D3
000013AA  B67C 0100                458      CMP.W #$0100, D3
000013AE  6700 000E                459      BEQ adda_size
000013B2  43F8 0259                460      LEA word, A1
000013B6  4EB8 1280                461      JSR print
000013BA  6000 000E                462      BRA next_add
000013BE                           463  adda_size
000013BE  43F8 0255                464      LEA long,A1
000013C2  4EB8 1280                465      JSR print
000013C6  183C 0080                466      MOVE.B #$80, D4
000013CA                           467  next_add                *print effective address for ADDA
000013CA  4EB9 00001834            468      JSR addr            
000013D0  43F8 02DC                469      LEA comma, A1
000013D4  4EB8 1280                470      JSR print
000013D8  4EB9 000019D0            471      JSR add_reg_sr
000013DE                           472  end_add                 *complete instruction printing by printing enter
000013DE  4EB8 1292                473      JSR enter
000013E2  6000 FE9A                474      BRA out
000013E6                           475  
000013E6                           476  print_sub_and_or
000013E6                           477      *determine if instruction is SUB, AND, or OR.
000013E6  3602                     478      MOVE.W D2, D3
000013E8  C67C F0C0                479      AND.W #$F0C0, D3
000013EC  B67C C0C0                480      CMP.W #$C0C0, D3
000013F0  6700 0090                481      BEQ mul_div
000013F4  B67C 80C0                482      CMP.W #$80C0, D3
000013F8  6700 0088                483      BEQ mul_div
000013FC  C67C F000                484      AND.W #$F000,D3
00001400  B67C 8000                485      CMP.W #$8000, D3
00001404  6700 0028                486      BEQ print_or
00001408  B67C 9000                487      CMP.W #$9000, D3
0000140C  6700 000A                488      BEQ print_sub
00001410  43F8 0292                489      LEA and_ins, A1
00001414  6000 001C                490      BRA print_instruction
00001418                           491  print_sub
00001418  3602                     492      MOVE.W D2, D3
0000141A  C67C 00C0                493      AND.W #$00C0, D3
0000141E  B63C 00C0                494      CMP.B #$C0, D3
00001422  6700 FE2A                495      BEQ invalid
00001426  43F8 0296                496      LEA sub_ins, A1
0000142A  6000 0006                497      BRA print_instruction
0000142E                           498  print_or
0000142E  43F8 028F                499      LEA or_ins, A1
00001432                           500  print_instruction       *print correct instruction
00001432  4EB8 1280                501      JSR print
00001436  4EB9 00001818            502      JSR size            *print instruction size
0000143C  3602                     503      MOVE.W D2,D3
0000143E                           504  *determine direction of ADD, Dn -> EA or EA -> Dn   
0000143E  C67C 0100                505      AND.W #$0100, D3
00001442  B67C 0100                506      CMP.W #$0100, D3
00001446  6700 001C                507      BEQ ea_dest_sub_and_or
0000144A  4EB9 00001834            508      JSR addr            *if Direction bit is 0
00001450  43F8 02DC                509      LEA comma, A1
00001454  4EB8 1280                510      JSR print
00001458  3A02                     511      MOVE.W D2,D5
0000145A  4EB9 000019B8            512      JSR data_reg_sr
00001460  6000 FF7C                513      BRA end_add
00001464                           514  ea_dest_sub_and_or      *if Direction bit is 1
00001464  3A02                     515      MOVE.W D2,D5
00001466  4EB9 000019B8            516      JSR data_reg_sr
0000146C  43F8 02DC                517      LEA comma, A1
00001470  4EB8 1280                518      JSR print
00001474  4EB9 00001834            519      JSR addr
0000147A                           520      *complete instruction printing by printing enter
0000147A  4EB8 1292                521      JSR enter
0000147E  6000 FDFE                522      BRA out
00001482                           523      
00001482                           524  mul_div             *deal with MULU and DIVU cases
00001482  4283                     525      CLR.L D3
00001484  3602                     526      MOVE.W D2,D3
00001486  C67C 00FF                527      AND.W #$00FF, D3
0000148A  B6BC 000000F8            528      CMP.L #$00F8, D3
00001490  6D00 FDBC                529      BLT invalid
00001494  B6BC 000000F9            530      CMP.L #$00F9, D3
0000149A  6700 0008                531      BEQ mul_div_long
0000149E  544C                     532      ADDA.W #2,A4
000014A0  6000 FDAC                533      BRA invalid
000014A4                           534  mul_div_long
000014A4  584C                     535      ADDA.W #4,A4
000014A6  6000 FDA6                536      BRA invalid
000014AA                           537      
000014AA                           538  print_ls_as_ro
000014AA                           539      *figure out if shift or rotation are memory or register based               
000014AA  3602                     540      MOVE.W D2, D3
000014AC  C63C 00C0                541      AND.B #$C0, D3
000014B0  B63C 00C0                542      CMP.B #$C0, D3
000014B4  6700 0072                543      BEQ ls_as_ro_mem
000014B8  3602                     544      MOVE.W D2, D3
000014BA  E60B                     545      LSR.B #3, D3
000014BC                           546      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000014BC  4EB9 000017A0            547      JSR print_correct_shift_rotation
000014C2  4EB9 0000177E            548      JSR print_direction     *print direction
000014C8  4EB9 00001818            549      JSR size                *print size
000014CE  3602                     550      MOVE.W D2, D3
000014D0  C63C 0020                551      AND.B #$20,D3
000014D4  B63C 0020                552      CMP.B #$20, D3
000014D8                           553      *determine if instruction is using immediate address or register
000014D8  6700 0030                554      BEQ ls_as_ro_reg     
000014DC  43F8 02DF                555      LEA pound, A1        *if immediate address print '#'
000014E0  4EB8 1280                556      JSR print
000014E4                           557      *print immediate address rotation value
000014E4  3C02                     558      MOVE.W D2,D6
000014E6  EF5E                     559      ROL.W #7,D6
000014E8  CC7C 0007                560      AND.W #$0007, D6
000014EC  43F8 0309                561      LEA dollar, A1
000014F0  4EB8 1280                562      JSR print
000014F4  4281                     563      CLR.L D1
000014F6  3206                     564      MOVE.W D6, D1
000014F8  3602                     565      MOVE.W D2, D3
000014FA  143C 0010                566      MOVE.B #16, D2
000014FE  103C 000F                567      MOVE.B #15, D0
00001502  4E4F                     568      TRAP #15
00001504  3403                     569      MOVE.W D3,D2
00001506  6000 000A                570      BRA continue_instruction_ls_as_ro
0000150A                           571  ls_as_ro_reg            *if instruction is using register to shift values in another register
0000150A  3A02                     572      MOVE.W D2,D5
0000150C  4EB9 000019B8            573      JSR data_reg_sr
00001512                           574  continue_instruction_ls_as_ro *complete instrcuction
00001512  43F8 02DC                575      LEA comma, A1       *print comma
00001516  4EB8 1280                576      JSR print
0000151A  3A02                     577      MOVE.W D2,D5
0000151C  EE5D                     578      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
0000151E  4EB9 000019B8            579      JSR data_reg_sr     *determine destination data register to perform instruction on
00001524  6000 0030                580      BRA next_ls_as_ro   *finish printing instruction
00001528                           581  ls_as_ro_mem            *check if immediate address is being shifted or rotated
00001528  3602                     582      MOVE.W D2, D3
0000152A  C63C 003F                583      AND.B #$3F, D3
0000152E  B63C 003C                584      CMP.B #$3C, D3
00001532  6700 FD3A                585      BEQ invalid_ea  *ROL #4 <- not allowed (immediate addressing)
00001536                           586      *if not immediate adress print normally 
00001536  3602                     587      MOVE.W D2, D3
00001538  EF5B                     588      ROL.W #7, D3    
0000153A  4EB9 000017A0            589      JSR print_correct_shift_rotation
00001540  3602                     590      MOVE.W D2,D3
00001542  4EB9 0000177E            591      JSR print_direction
00001548  43F8 0259                592      LEA word, A1
0000154C  4EB8 1280                593      JSR print
00001550  4EB9 00001834            594      JSR addr
00001556                           595  next_ls_as_ro
00001556  4EB8 1292                596      JSR enter
0000155A  6000 FD22                597      BRA out
0000155E                           598      
0000155E                           599  print_not
0000155E  43F8 02A3                600      LEA not_ins, A1 *print instruction
00001562  4EB8 1280                601      JSR print
00001566  4EB9 00001818            602      JSR size
0000156C  3602                     603      MOVE.W D2, D3
0000156E  C63C 003F                604      AND.B #$3F, D3
00001572  B63C 003C                605      CMP.B #$3C, D3
00001576  6700 FCF6                606      BEQ invalid_ea  *NOT #4 <- not allowed (immediate addressing)
0000157A  4EB9 00001834            607      JSR addr
00001580  4EB8 1292                608      JSR enter
00001584  6000 FCF8                609      BRA out
00001588                           610  
00001588                           611  print_jsr
00001588  43F8 02A7                612      LEA jsr_ins, A1 *print instruction
0000158C  4EB8 1280                613      JSR print
00001590  4EB9 00001834            614      JSR addr    *print address
00001596  4EB8 1292                615      JSR enter   *print enter (next line)
0000159A  6000 FCE2                616      BRA out
0000159E                           617  
0000159E                           618  print_lea
0000159E  43F8 02AC                619      LEA lea_ins, A1 *print instruction
000015A2  4EB8 1280                620      JSR print   
000015A6  4EB9 00001834            621      JSR addr    *print address
000015AC  43F8 02DC                622      LEA comma, A1   *print comma
000015B0  4EB8 1280                623      JSR print
000015B4  4EB9 000019D0            624      JSR add_reg_sr *print destination address register
000015BA  4EB8 1292                625      JSR enter
000015BE  6000 FCBE                626      BRA out
000015C2                           627  
000015C2                           628  print_addq
000015C2  43F8 028A                629      LEA addq_ins, A1    *print instruction
000015C6  4EB8 1280                630      JSR print
000015CA  4EB9 00001818            631      JSR size            *print instruction size
000015D0  43F8 02DF                632      LEA pound, A1
000015D4  4EB8 1280                633      JSR print           *print '#' for immediate addressing
000015D8  3C02                     634      MOVE.W D2,D6
000015DA  EF5E                     635      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015DC  CC7C 0007                636      AND.W #$0007, D6
000015E0  4EB9 000019AC            637      JSR Xn
000015E6  43F8 02DC                638      LEA comma, A1       *print comma
000015EA  4EB8 1280                639      JSR print
000015EE  4EB9 00001834            640      JSR addr            *print destination address
000015F4  4EB8 1292                641      JSR enter
000015F8  6000 FC84                642      BRA out
000015FC                           643  
000015FC                           644  print_bra_bcc           *needs comments
000015FC  3602                     645      MOVE.W D2,D3
000015FE  C67C 0F00                646      AND.W #$0F00, D3
00001602  B67C 0000                647      CMP.W #$0000, D3
00001606  6700 001E                648      BEQ print_bra
0000160A  B67C 0700                649      CMP.W #$0700, D3
0000160E  6700 0022                650      BEQ print_beq
00001612  B67C 0E00                651      CMP.W #$0E00, D3
00001616  6700 0032                652      BEQ print_bgt
0000161A  B67C 0F00                653      CMP.W #$0F00, D3
0000161E  6700 001E                654      BEQ print_ble
00001622  6000 FC2A                655      BRA invalid
00001626                           656  print_bra
00001626  43F8 02C2                657      LEA bra_ins, A1
0000162A  4EB8 1280                658      JSR print
0000162E  6000 0022                659      BRA next_bra_bcc
00001632                           660  print_beq
00001632  43F8 02BE                661      LEA beq_ins, A1
00001636  4EB8 1280                662      JSR print
0000163A  6000 0016                663      BRA next_bra_bcc
0000163E                           664  print_ble
0000163E  43F8 02BA                665      LEA ble_ins, A1
00001642  4EB8 1280                666      JSR print
00001646  6000 000A                667      BRA next_bra_bcc
0000164A                           668  print_bgt
0000164A  43F8 02B6                669      LEA bgt_ins, A1
0000164E  4EB8 1280                670      JSR print
00001652                           671  next_bra_bcc
00001652  3602                     672      MOVE.W D2, D3
00001654  C67C 00FF                673      AND.W #$00FF, D3
00001658  B67C 0000                674      CMP.W #$0000, D3
0000165C  6700 0026                675      BEQ check_word
00001660  43F8 025D                676      LEA byte, A1
00001664  4EB8 1280                677      JSR print
00001668  43F8 0309                678      LEA dollar, A1
0000166C  4EB8 1280                679      JSR print
00001670  3203                     680      MOVE.W D3, D1
00001672  3602                     681      MOVE.W D2, D3
00001674  343C 0010                682      MOVE.W #16, D2
00001678  303C 000F                683      MOVE.W #15,D0
0000167C  4E4F                     684      trap #15            *print immediate address value
0000167E  3403                     685      MOVE.W D3, D2
00001680  6000 0024                686      BRA end_bra_bcc
00001684                           687  check_word
00001684  43F8 0259                688      LEA word, A1
00001688  4EB8 1280                689      JSR print
0000168C  43F8 0309                690      LEA dollar, A1
00001690  4EB8 1280                691      JSR print
00001694  544C                     692      ADDA.W #2,A4        *update current address
00001696  3214                     693      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001698  3602                     694      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000169A  343C 0010                695      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000169E  103C 000F                696      MOVE.B #15, D0      *use trap instruction that allows use of base 16
000016A2  4E4F                     697      TRAP #15
000016A4  3403                     698      MOVE.W D3,D2        *copy opcode back to register D2
000016A6                           699  end_bra_bcc
000016A6  4EB8 1292                700      JSR enter
000016AA  6000 FBD2                701      BRA out
000016AE                           702  
000016AE                           703  print_movem         *needs comments
000016AE  43F8 0275                704      LEA movem_ins, A1
000016B2  4EB8 1280                705      JSR print
000016B6  3602                     706      MOVE.W D2,D3
000016B8  C67C 0040                707      AND.W #$0040,D3
000016BC  B67C 0040                708      CMP.W #$0040,D3
000016C0  6700 000E                709      BEQ movem_long
000016C4  43F8 0259                710      LEA word, A1
000016C8  4EB8 1280                711      JSR print
000016CC  6000 000A                712      BRA movem_direction
000016D0                           713  movem_long
000016D0  43F8 0255                714      LEA long, A1
000016D4  4EB8 1280                715      JSR print
000016D8                           716  movem_direction
000016D8  3602                     717      MOVE.W D2,D3
000016DA  C67C 0400                718      AND.W #$0400,D3
000016DE  B67C 0400                719      CMP.W #$0400,D3
000016E2  6700 001A                720      BEQ mem_to_reg
000016E6  4EB9 0000175A            721      JSR movem_check_pre_post
000016EC  43F8 02DC                722      LEA comma, A1
000016F0  4EB8 1280                723      JSR print
000016F4  4EB9 00001834            724      JSR addr
000016FA  6000 0056                725      BRA end_movem
000016FE                           726  mem_to_reg
000016FE  3602                     727      MOVE.W D2, D3
00001700  C67C 003F                728      AND.W #$003F, D3
00001704  B67C 0038                729      CMP.W #$0038, D3
00001708  6700 000E                730      BEQ fix_mem_order_word
0000170C  B67C 0039                731      CMP.W #$0039, D3
00001710  6700 0016                732      BEQ fix_mem_order_long
00001714  6000 0028                733      BRA movem_cont
00001718                           734  fix_mem_order_word
00001718  2C4C                     735      MOVE.L A4, A6
0000171A  584E                     736      ADD.W #4, A6
0000171C  2A16                     737      MOVE.L (A6),D5
0000171E  4845                     738      SWAP D5
00001720  2C85                     739      MOVE.L D5, (A6)
00001722  4285                     740      CLR.L D5
00001724  6000 0018                741      BRA movem_cont
00001728                           742  fix_mem_order_long
00001728  2C4C                     743      MOVE.L A4, A6
0000172A  544E                     744      ADD.W #2, A6
0000172C  3A16                     745      MOVE.W (A6),D5
0000172E  544E                     746      ADD.W #2, A6
00001730  2C16                     747      MOVE.L (A6),D6
00001732  554E                     748      SUB.W #2, A6
00001734  2C86                     749      MOVE.L D6, (A6)
00001736  584E                     750      ADD.W #4, A6
00001738  3C85                     751      MOVE.W D5, (A6)
0000173A  4285                     752      CLR.L D5
0000173C  4286                     753      CLR.L D6
0000173E                           754  movem_cont
0000173E  4EB9 00001834            755      JSR addr
00001744  43F8 02DC                756      LEA comma, A1
00001748  4EB8 1280                757      JSR print
0000174C  4EB9 0000175A            758      JSR movem_check_pre_post
00001752                           759  end_movem
00001752  4EB8 1292                760      JSR enter
00001756  6000 FB26                761      BRA out
0000175A                           762      
0000175A                           763  movem_check_pre_post:
0000175A  3602                     764      MOVE.W D2, D3
0000175C  C67C 0038                765      AND.W #$0038, D3
00001760  B67C 0020                766      CMP.W #$0020, D3
00001764  6700 000C                767      BEQ movem_check_pre
00001768  4EB9 00001A98            768      JSR movem_postinc
0000176E  6000 0008                769      BRA movem_check_done
00001772                           770  movem_check_pre
00001772  4EB9 000019E8            771      JSR movem_predec
00001778                           772  movem_check_done
00001778  4287                     773      CLR.L D7
0000177A  4281                     774      CLR.L D1
0000177C  4E75                     775      RTS
0000177E                           776  
0000177E                           777  print_direction:
0000177E                           778  *print correct direction given direction bit
0000177E  C67C 0100                779      AND.W #$0100, D3
00001782  B67C 0100                780      CMP.W #$0100, D3
00001786  6700 000E                781      BEQ print_left  *print left
0000178A  43F8 02C6                782      LEA right, A1
0000178E  4EB8 1280                783      JSR print
00001792  6000 FAEA                784      BRA out
00001796                           785  print_left
00001796  43F8 02C8                786      LEA left, A1
0000179A  4EB8 1280                787      JSR print *print right
0000179E  4E75                     788      RTS
000017A0                           789      
000017A0                           790  print_correct_shift_rotation:
000017A0                           791  *determine if instruction is logical, arithmetic, or rotation 
000017A0  C63C 0003                792      AND.B #$03, D3
000017A4  B63C 0000                793      CMP.B #$00, D3
000017A8  6700 0016                794      BEQ print_as
000017AC  B63C 0001                795      CMP.B #$01, D3
000017B0  6700 0016                796      BEQ print_ls
000017B4  B63C 0003                797      CMP.B #$03, D3
000017B8  43F8 02A0                798      LEA ro_ins, A1  print rotation
000017BC  6000 000E                799      BRA print_it
000017C0                           800  print_as
000017C0  43F8 029D                801      LEA as_ins, A1  print arithmetic shift
000017C4  6000 0006                802      BRA print_it
000017C8                           803  print_ls
000017C8  43F8 029A                804      LEA ls_ins, A1 print logical shift
000017CC                           805  print_it
000017CC  4EB8 1280                806      JSR print
000017D0  4E75                     807      RTS
000017D2                           808  * --------- End Print Instruction ----------*
000017D2                           809  
000017D2                           810  * ------- Instruction sizes ---------*
000017D2                           811  
000017D2                           812  move_size:  *print size for MOVE and MOVEA instruction
000017D2  4284                     813      CLR.L D4
000017D4  3802                     814      MOVE.W D2, D4
000017D6  C87C 3000                815      AND.W #$3000, D4
000017DA  B87C 1000                816      CMP.W #$1000, D4
000017DE  6700 0014                817      BEQ print_b
000017E2  B87C 3000                818      CMP.W #$3000, D4
000017E6  6700 0018                819      BEQ print_w
000017EA  B87C 2000                820      CMP.W #$2000, D4
000017EE  6700 001C                821      BEQ print_l
000017F2  4E75                     822      RTS
000017F4                           823      
000017F4                           824  print_b     *print '.B'
000017F4  43F8 025D                825      LEA byte, A1
000017F8  4EB8 1280                826      JSR print
000017FC  6000 FA80                827      BRA out
00001800                           828      
00001800                           829  print_w     *print '.W'
00001800  43F8 0259                830      LEA word, A1
00001804  4EB8 1280                831      JSR print
00001808  6000 FA74                832      BRA out
0000180C                           833      
0000180C                           834  print_l:    *print '.L'
0000180C  43F8 0255                835      LEA long, A1
00001810  4EB8 1280                836      JSR print
00001814  6000 FA68                837      BRA out
00001818                           838  
00001818                           839  size:       *print size for non "move" instructions
00001818  4284                     840      CLR.L D4
0000181A  1802                     841      MOVE.B D2,D4
0000181C  C83C 00C0                842      AND.B #$C0, D4
00001820  B83C 0000                843      CMP.B #$00, D4
00001824  67CE                     844      BEQ print_b
00001826  B83C 0040                845      CMP.B #$40,D4
0000182A  67D4                     846      BEQ print_w
0000182C  B83C 0080                847      CMP.B #$80, D4
00001830  67DA                     848      BEQ print_l
00001832  4E75                     849      RTS
00001834                           850      
00001834                           851  * ------- End Instruction sizes ---------*
00001834                           852  
00001834                           853  * ------- Effective Address -------*
00001834                           854  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
00001834  3A02                     855      MOVE.W D2, D5
00001836  3C02                     856      MOVE.W D2, D6               
00001838  BE3C 0001                857      CMP.B #1, D7
0000183C  6700 003A                858      BEQ destination *check if evaluating destination address (used for MOVE)
00001840                           859  cont
00001840  CC3C 0038                860      AND.B #$38, D6
00001844  BC3C 0000                861      CMP.B #0, D6
00001848  6700 0038                862      BEQ data_reg        *check if EA mode is data register
0000184C  BC3C 0008                863      CMP.B #$08, D6
00001850  6700 0048                864      BEQ add_reg         *check if EA mode is address register
00001854  BC3C 0010                865      CMP.B #$10, D6
00001858  6700 0058                866      BEQ add_indirect    *check if EA mode is address indirect
0000185C  BC3C 0018                867      CMP.B #$18, D6
00001860  6700 0070                868      BEQ post_increment  *check if EA mode is post increment
00001864  BC3C 0020                869      CMP.B #$20, D6
00001868  6700 0088                870      BEQ pre_decrement   *check if EA mode is pre_decrement
0000186C  BC3C 0038                871      CMP.B #$38, D6
00001870  6700 00A0                872      BEQ absolute_or_immediate
00001874  6000 FA08                873      BRA out *needs Immediate, Abs Long, and Abs Word
00001878                           874  destination     *perform correct rotation to retrieve destination address
00001878  3C05                     875      MOVE.W D5,D6
0000187A  EF5D                     876      ROL.W #7,D5
0000187C  E64E                     877      LSR.W #3,D6
0000187E  60C0                     878      BRA cont
00001880  4E75                     879      RTS
00001882                           880  
00001882                           881  data_reg    *used with addr sub routine
00001882  3C05                     882      MOVE.W D5,D6    
00001884  CC3C 0007                883      AND.B #$07, D6  
00001888  43F8 02CA                884      LEA D_reg, A1   
0000188C  4EB8 1280                885      JSR print
00001890  4EB9 000019AC            886      JSR Xn
00001896  6000 F9E6                887      BRA out
0000189A                           888  
0000189A                           889  add_reg     *used with addr sub routine
0000189A  3C05                     890      MOVE.W D5,D6    
0000189C  CC3C 0007                891      AND.B #$07, D6
000018A0  43F8 02CC                892      LEA A_reg, A1   
000018A4  4EB8 1280                893      JSR print
000018A8  4EB9 000019AC            894      JSR Xn
000018AE  6000 F9CE                895      BRA out
000018B2                           896      
000018B2                           897  add_indirect    *used with addr sub routine
000018B2  3C05                     898      MOVE.W D5,D6    
000018B4  CC3C 0007                899      AND.B #$07, D6
000018B8  43F8 02CE                900      LEA open_paran, A1  
000018BC  4EB8 1280                901      JSR print
000018C0  4EB9 000019AC            902      JSR Xn
000018C6  43F8 02D1                903      LEA close_paran, A1 
000018CA  4EB8 1280                904      JSR print
000018CE  6000 F9AE                905      BRA out
000018D2                           906      
000018D2                           907  post_increment  *used with addr sub routine
000018D2  3C05                     908      MOVE.W D5,D6    
000018D4  CC3C 0007                909      AND.B #$07, D6
000018D8  43F8 02CE                910      LEA open_paran, A1  
000018DC  4EB8 1280                911      JSR print
000018E0  4EB9 000019AC            912      JSR Xn
000018E6  43F8 02D3                913      LEA post_inc, A1    
000018EA  4EB8 1280                914      JSR print
000018EE  6000 F98E                915      BRA out
000018F2                           916      
000018F2                           917  pre_decrement   *used with addr sub routine
000018F2  3C05                     918      MOVE.W D5,D6    
000018F4  CC3C 0007                919      AND.B #$07, D6
000018F8  43F8 02D6                920      LEA pre_dec, A1 
000018FC  4EB8 1280                921      JSR print
00001900  4EB9 000019AC            922      JSR Xn
00001906  43F8 02D1                923      LEA close_paran, A1 
0000190A  4EB8 1280                924      JSR print
0000190E  6000 F96E                925      BRA out
00001912                           926  
00001912                           927  absolute_or_immediate *check if EA is immediate or absolute address
00001912  3C05                     928      MOVE.W D5,D6    
00001914  CC3C 0007                929      AND.B #$07, D6
00001918  BC3C 0000                930      CMP.B #$00, D6
0000191C  6700 0054                931      BEQ w_imm
00001920  BC3C 0001                932      CMP.B #$01, D6
00001924  6700 0068                933      BEQ l_imm
00001928  BC3C 0004                934      CMP.B #04, D6
0000192C  6700 0002                935      BEQ immediate
00001930                           936      
00001930                           937  immediate
00001930  43F8 02DF                938      LEA pound, A1
00001934  4EB8 1280                939      JSR print
00001938  B4BC 00004000            940      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
0000193E  6D00 0016                941      BLT move_movea      *check if instruction is move or movea
00001942  B8BC 00000040            942      CMP.L #$0040, D4        *if not move or movea
00001948  6F00 0028                943      BLE w_imm           *byte and word check the next 2 addresses in mem
0000194C  B8BC 00000080            944      CMP.L #$0080, D4
00001952  6700 003A                945      BEQ l_imm           *long checks the next 4 addresses in mem
00001956                           946  move_movea              *similar comparisons, but for different bits in OPCODE
00001956  B87C 1000                947      CMP.W #$1000, D4
0000195A  6700 0016                948      BEQ w_imm
0000195E  B87C 3000                949      CMP.W #$3000, D4
00001962  6700 000E                950      BEQ w_imm
00001966  B87C 2000                951      CMP.W #$2000, D4
0000196A  6700 0022                952      BEQ l_imm
0000196E                           953  imm_complete
0000196E  6000 F90E                954      BRA out
00001972                           955      
00001972                           956  w_imm
00001972  43F8 0309                957      LEA dollar, A1      *print '$'
00001976  4EB8 1280                958      JSR print
0000197A  544C                     959      ADDA.W #2,A4        *update current address
0000197C  3214                     960      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000197E  3602                     961      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001980  343C 0010                962      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001984  103C 000F                963      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001988  4E4F                     964      TRAP #15
0000198A  3403                     965      MOVE.W D3,D2        *copy opcode back to register D2
0000198C  60E0                     966      BRA imm_complete    *exit addr subroutine
0000198E                           967      
0000198E                           968  l_imm
0000198E  43F8 0309                969      LEA dollar, A1      *print '$'
00001992  4EB8 1280                970      JSR print
00001996  544C                     971      ADDA.W  #2,A4       *update current address
00001998  2214                     972      MOVE.L (A4),D1      *retrieve long data stored in the new current address
0000199A  3602                     973      MOVE.W D2, D3
0000199C  343C 0010                974      MOVE.W #16, D2
000019A0  103C 000F                975      MOVE.B #15, D0
000019A4  4E4F                     976      TRAP #15
000019A6  3403                     977      MOVE.W D3,D2
000019A8  544C                     978      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
000019AA  60C2                     979      BRA imm_complete    *exit addr subroutine
000019AC                           980  
000019AC                           981  Xn:                     *retieve signed decimal value of data stored in register D6
000019AC  4281                     982      CLR.L D1
000019AE  1206                     983      MOVE.B D6,D1
000019B0  103C 0003                984      MOVE.B #3, D0
000019B4  4E4F                     985      TRAP #15
000019B6  4E75                     986      RTS
000019B8                           987  
000019B8                           988  data_reg_sr:    *use if dealing with Dn only
000019B8  4286                     989      CLR.L D6
000019BA  3C05                     990      MOVE.W D5,D6
000019BC  EF5E                     991      ROL.W #7,D6
000019BE  CC3C 0007                992      AND.B #$07, D6  
000019C2  43F8 02CA                993      LEA D_reg, A1   
000019C6  4EB8 1280                994      JSR print
000019CA  4EB8 19AC                995      JSR Xn
000019CE  4E75                     996      RTS
000019D0                           997      
000019D0                           998  add_reg_sr:     *use if dealing with An only
000019D0  4286                     999      CLR.L D6
000019D2  3C02                    1000      MOVE.W D2,D6
000019D4  EF5E                    1001      ROL.W #7,D6
000019D6  CC3C 0007               1002      AND.B #$07, D6  
000019DA  43F8 02CC               1003      LEA A_reg, A1   
000019DE  4EB8 1280               1004      JSR print
000019E2  4EB8 19AC               1005      JSR Xn
000019E6  4E75                    1006      RTS
000019E8                          1007      
000019E8                          1008  movem_predec:           *needs to be worked on
000019E8  4285                    1009      CLR.L D5
000019EA  544C                    1010      ADDA.W  #2,A4       *update current address
000019EC  3A14                    1011      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019EE  3C05                    1012      MOVE.W D5,D6
000019F0  4281                    1013      CLR.L D1
000019F2  4287                    1014      CLR.L D7
000019F4  BA3C 0000               1015      CMP.B #$00, D5
000019F8  6700 005E               1016      BEQ predec_skip_to_d
000019FC  E14E                    1017      LSL #8, D6
000019FE                          1018  predec_loop_a   
000019FE  E34E                    1019      LSL #1, D6
00001A00  6400 0006               1020      BCC predec_inc_loop_a
00001A04  6000 000E               1021      BRA predec_check_first_a
00001A08                          1022  predec_inc_loop_a
00001A08  5201                    1023      ADD.B #1, D1
00001A0A  B23C 0008               1024      CMP.B #8, D1
00001A0E  66EE                    1025      BNE predec_loop_a
00001A10  6000 0038               1026      BRA predec_loop_a_done  
00001A14                          1027  predec_check_first_a
00001A14  BE3C 0000               1028      CMP.B #0, D7
00001A18  6700 000A               1029      BEQ predec_first_a
00001A1C  43F8 02E3               1030      LEA slash, A1
00001A20  4EB8 1280               1031      JSR print
00001A24                          1032  predec_first_a
00001A24  43F8 02CC               1033      LEA A_reg, A1
00001A28  4EB8 1280               1034      JSR print
00001A2C  103C 0003               1035      MOVE.B #3, D0
00001A30  4E4F                    1036      TRAP #15
00001A32  5201                    1037      ADD.B #1, D1
00001A34  5207                    1038      ADD.B #1, D7
00001A36  B23C 0008               1039      CMP.B #8, D1
00001A3A  66C2                    1040      BNE predec_loop_a
00001A3C  3C05                    1041      MOVE.W D5,D6
00001A3E  CC7C FF00               1042      AND.W #$FF00, D6
00001A42  BC7C 0000               1043      CMP.W #$00, D6
00001A46  6700 004E               1044      BEQ end_movem_predec
00001A4A                          1045  predec_loop_a_done
00001A4A  3C05                    1046      MOVE.W D5,D6
00001A4C  43F8 02E3               1047      LEA slash, A1
00001A50  4EB8 1280               1048      JSR print
00001A54  4281                    1049      CLR.L D1
00001A56  4287                    1050      CLR.L D7
00001A58                          1051  predec_skip_to_d
00001A58                          1052  predec_loop_d   
00001A58  E34E                    1053      LSL #1, D6
00001A5A  6400 0006               1054      BCC predec_inc_loop_d
00001A5E  6000 000E               1055      BRA predec_check_first_d
00001A62                          1056  predec_inc_loop_d
00001A62  5201                    1057      ADD.B #1, D1
00001A64  B23C 0008               1058      CMP.B #8, D1
00001A68  66EE                    1059      BNE predec_loop_d   
00001A6A  6000 002A               1060      BRA end_movem_predec
00001A6E                          1061  predec_check_first_d
00001A6E  BE3C 0000               1062      CMP.B #0, D7
00001A72  6700 000A               1063      BEQ predec_first_d
00001A76  43F8 02E3               1064      LEA slash, A1
00001A7A  4EB8 1280               1065      JSR print
00001A7E                          1066  predec_first_d
00001A7E  43F8 02CA               1067      LEA D_reg, A1
00001A82  4EB8 1280               1068      JSR print
00001A86  103C 0003               1069      MOVE.B #3, D0
00001A8A  4E4F                    1070      TRAP #15
00001A8C  5201                    1071      ADD.B #1, D1
00001A8E  5207                    1072      ADD.B #1, D7
00001A90  B23C 0008               1073      CMP.B #8, D1
00001A94  66C2                    1074      BNE predec_loop_d
00001A96                          1075  end_movem_predec
00001A96  4E75                    1076      RTS
00001A98                          1077      
00001A98                          1078  movem_postinc:          *needs to be worked on
00001A98  4285                    1079      CLR.L D5
00001A9A  544C                    1080      ADDA.W  #2,A4       *update current address
00001A9C  3A14                    1081      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A9E  3C05                    1082      MOVE.W D5,D6
00001AA0  4281                    1083      CLR.L D1
00001AA2  4287                    1084      CLR.L D7
00001AA4  3C05                    1085      MOVE.W D5,D6
00001AA6  CC7C FF00               1086      AND.W #$FF00, D6
00001AAA  BC7C 0000               1087      CMP.W #$00, D6
00001AAE  6700 0058               1088      BEQ postinc_skip_to_d
00001AB2  E04E                    1089      LSR #8, D6
00001AB4                          1090  postinc_loop_a  
00001AB4  E24E                    1091      LSR #1, D6
00001AB6  6400 0006               1092      BCC postinc_inc_loop_a
00001ABA  6000 000E               1093      BRA postinc_check_first_a
00001ABE                          1094  postinc_inc_loop_a
00001ABE  5201                    1095      ADD.B #1, D1
00001AC0  B23C 0008               1096      CMP.B #8, D1
00001AC4  66EE                    1097      BNE postinc_loop_a
00001AC6  6000 0032               1098      BRA postinc_loop_a_done 
00001ACA                          1099  postinc_check_first_a
00001ACA  BE3C 0000               1100      CMP.B #0, D7
00001ACE  6700 000A               1101      BEQ postinc_first_a
00001AD2  43F8 02E3               1102      LEA slash, A1
00001AD6  4EB8 1280               1103      JSR print
00001ADA                          1104  postinc_first_a
00001ADA  43F8 02CC               1105      LEA A_reg, A1
00001ADE  4EB8 1280               1106      JSR print
00001AE2  103C 0003               1107      MOVE.B #3, D0
00001AE6  4E4F                    1108      TRAP #15
00001AE8  5201                    1109      ADD.B #1, D1
00001AEA  5207                    1110      ADD.B #1, D7
00001AEC  B23C 0008               1111      CMP.B #8, D1
00001AF0  66C2                    1112      BNE postinc_loop_a
00001AF2  BA3C 0000               1113      CMP.B #$00, D5
00001AF6  6700 0050               1114      BEQ end_movem_postinc
00001AFA                          1115  postinc_loop_a_done
00001AFA  3C05                    1116      MOVE.W D5,D6
00001AFC  43F8 02E3               1117      LEA slash, A1
00001B00  4EB8 1280               1118      JSR print
00001B04  4281                    1119      CLR.L D1
00001B06  4287                    1120      CLR.L D7
00001B08                          1121  postinc_skip_to_d
00001B08  3C05                    1122      MOVE.W D5,D6
00001B0A                          1123  postinc_loop_d  
00001B0A  E24E                    1124      LSR #1, D6
00001B0C  6400 0006               1125      BCC postinc_inc_loop_d
00001B10  6000 000E               1126      BRA postinc_check_first_d
00001B14                          1127  postinc_inc_loop_d
00001B14  5201                    1128      ADD.B #1, D1
00001B16  B23C 0008               1129      CMP.B #8, D1
00001B1A  66EE                    1130      BNE postinc_loop_d  
00001B1C  6000 002A               1131      BRA end_movem_postinc
00001B20                          1132  postinc_check_first_d
00001B20  BE3C 0000               1133      CMP.B #0, D7
00001B24  6700 000A               1134      BEQ postinc_first_d
00001B28  43F8 02E3               1135      LEA slash, A1
00001B2C  4EB8 1280               1136      JSR print
00001B30                          1137  postinc_first_d
00001B30  43F8 02CA               1138      LEA D_reg, A1
00001B34  4EB8 1280               1139      JSR print
00001B38  103C 0003               1140      MOVE.B #3, D0
00001B3C  4E4F                    1141      TRAP #15
00001B3E  5201                    1142      ADD.B #1, D1
00001B40  5207                    1143      ADD.B #1, D7
00001B42  B23C 0008               1144      CMP.B #8, D1
00001B46  66C2                    1145      BNE postinc_loop_d
00001B48                          1146  end_movem_postinc
00001B48  4E75                    1147      RTS
00001B4A                          1148  
00001B4A                          1149  
00001B4A                          1150  * ------- End Effective Address -------*
00001B4A                          1151  
00001B4A                          1152  * ----- Hex to ASCII & ASCII to HEX -----*
00001B4A                          1153  
00001B4A                          1154  ASCIItoHex:
00001B4A  4EB9 00001B58           1155          jsr     ASCII2Hex_init  
00001B50  4EB9 00001B5E           1156          jsr     conversion_loop
00001B56  4E75                    1157          rts                    
00001B58                          1158  
00001B58                          1159  ASCII2Hex_init:   
00001B58  143C 0000               1160          move.b  #0,D2       *set up counter    
00001B5C  4E75                    1161          rts         
00001B5E                          1162          
00001B5E                          1163  conversion_loop:            
00001B5E  5282                    1164          add.l   #1,D2       *increment counter
00001B60  B4BC 00000009           1165          cmp.l   #9,D2       *ends at 9
00001B66  6700 004A               1166          BEQ     DONE        *branch when compare is true
00001B6A  1819                    1167          move.b  (A1)+,D4    *Get first num
00001B6C                          1168          
00001B6C  B83C 0040               1169          cmp.b   #$40,D4        
00001B70  6E00 000C               1170          bgt     Letters_Cap  
00001B74                          1171          
00001B74  B83C 0039               1172          cmp.b   #$39,D4
00001B78  6F00 0016               1173          BLE     Numbers      
00001B7C  4E75                    1174          rts
00001B7E                          1175          
00001B7E                          1176  Letters_Cap:      
00001B7E  B83C 0046               1177          cmp.b   #$46,D4          
00001B82  6E00 001E               1178          bgt     ERROR  
00001B86  0404 0037               1179          sub.b   #$37,D4     
00001B8A  E986                    1180          asl.l   #4,D6       
00001B8C  DC84                    1181          add.l   D4,D6     
00001B8E  60CE                    1182          bra     conversion_loop 
00001B90                          1183  Numbers:
00001B90  B83C 0030               1184          cmp.b   #$30,D4         
00001B94  6D00 000C               1185          blt     ERROR        
00001B98  0404 0030               1186          sub.b   #$30,D4      
00001B9C  E986                    1187          asl.l   #4,D6        
00001B9E  DC84                    1188          add.l   D4,D6     
00001BA0  60BC                    1189          bra     conversion_loop
00001BA2                          1190          
00001BA2                          1191  ERROR:
00001BA2  43F8 0127               1192          lea     ErrorMsg,A1    
00001BA6  103C 000E               1193          move.b  #14,D0
00001BAA  4E4F                    1194          trap    #15
00001BAC                          1195      
00001BAC  103C 0009               1196          move.b  #9,D0
00001BB0  4E4F                    1197          trap    #15
00001BB2                          1198          
00001BB2                          1199  DONE:
00001BB2                          1200     
00001BB2  4241                    1201          clr     D1
00001BB4  4242                    1202          clr     D2
00001BB6  4244                    1203          clr     D4
00001BB8                          1204      
00001BB8  43F8 0158               1205          lea     ASCIItoHexMsg,A1
00001BBC  103C 000E               1206          move.b  #14,D0
00001BC0  4E4F                    1207          trap    #15
00001BC2                          1208  
00001BC2  4E75                    1209          rts
00001BC4                          1210          
00001BC4                          1211  * -- End of Hex to ASCII & ASCII to HEX --*
00001BC4                          1212  
00001BC4                          1213  * Put program code here
00001BC4                          1214  
00001BC4  FFFF FFFF               1215      SIMHALT             ; halt simulator
00001BC8                          1216  
00001BC8                          1217  * Put variables and constants here 
00001BC8                          1218  
00001BC8                          1219      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  1912
ADDA_INS            285
ADDA_SIZE           13BE
ADDQ_INS            28A
ADDR                1834
ADD_A               139C
ADD_INDIRECT        18B2
ADD_INS             281
ADD_REG             189A
ADD_REG_SR          19D0
ANDQ_INS            2B1
AND_INS             292
ASCII2HEX_INIT      1B58
ASCIITOHEX          1B4A
ASCIITOHEXMSG       158
AS_INS              29D
A_REG               2CC
BEQ_INS             2BE
BGT_INS             2B6
BLE_INS             2BA
BRA_INS             2C2
BYTE                25D
CHECK_WORD          1684
CLEARDONE           10F4
CLEARSCREEN         10DE
CLEAR_REGISTERS     102A
CLOSE_PARAN         2D1
COMMA               2DC
CONT                1840
CONTINUEORNOTMSG    20F
CONTINUE_INSTRUCTION_LS_AS_RO  1512
CONVERSION_LOOP     1B5E
CR                  D
CREATORS            1F
DASH                2E1
DATA                2E8
DATA_REG            1882
DATA_REG_SR         19B8
DESTINATION         1878
DOLLAR              309
DONE                1BB2
D_REG               2CA
EA                  2EF
EA_DEST_ADD         1382
EA_DEST_SUB_AND_OR  1464
ENDADDRESSINC       ED
ENDOFMEMLOOP        17C
END_ADD             13DE
END_BRA_BCC         16A6
END_MOVEM           1752
END_MOVEM_POSTINC   1B48
END_MOVEM_PREDEC    1A96
ENTER               1292
ENTER_PRESS_TRUE    11B4
ERROR               1BA2
ERRORMSG            127
EXITMSG             245
FIX_MEM_ORDER_LONG  1728
FIX_MEM_ORDER_WORD  1718
FLUSHSCREEN         1190
FLUSHSCREENMSG      1A2
FLUSHSCREEN_INPUT   11A2
GETENDADDRESS       10BE
GETSTARTADDRESS     109E
HELPMSG             1D3
HEXTOASCIIMSG       136
IMMEDIATE           1930
IMM_COMPLETE        196E
INPUTISINC          D0
INPUTMSG1           57
INPUTMSG2           98
INVALID             124E
INVALID_EA          126E
INVALID_INPUT       1080
JSR_INS             2A7
LEA_INS             2AC
LEFT                2C8
LETTERS_CAP         1B7E
LF                  A
LONG                255
LS_AS_RO_MEM        1528
LS_AS_RO_REG        150A
LS_INS              29A
L_IMM               198E
MEMSEARCH           10F6
MEMSEARCHLOOP       110A
MEMSEARCH_DONE      1144
MEM_TO_REG          16FE
MENU                1066
MENU_CONT           1096
MOVEA_INS           27B
MOVEM_CHECK_DONE    1778
MOVEM_CHECK_PRE     1772
MOVEM_CHECK_PRE_POST  175A
MOVEM_CONT          173E
MOVEM_DIRECTION     16D8
MOVEM_INS           275
MOVEM_LONG          16D0
MOVEM_POSTINC       1A98
MOVEM_PREDEC        19E8
MOVEQ_INS           26E
MOVE_A              130E
MOVE_INS            269
MOVE_MOVEA          1956
MOVE_SIZE           17D2
MUL_DIV             1482
MUL_DIV_LONG        14A4
M_SIZE              1316
NEXT_ADD            13CA
NEXT_BRA_BCC        1652
NEXT_LS_AS_RO       1556
NOP_INS             261
NOT_INS             2A3
NUMBERS             1B90
OPCODE_DECODE       11B6
OPEN_PARAN          2CE
OR_INS              28F
OUT                 127E
POSTINC_CHECK_FIRST_A  1ACA
POSTINC_CHECK_FIRST_D  1B20
POSTINC_FIRST_A     1ADA
POSTINC_FIRST_D     1B30
POSTINC_INC_LOOP_A  1ABE
POSTINC_INC_LOOP_D  1B14
POSTINC_LOOP_A      1AB4
POSTINC_LOOP_A_DONE  1AFA
POSTINC_LOOP_D      1B0A
POSTINC_SKIP_TO_D   1B08
POST_INC            2D3
POST_INCREMENT      18D2
POUND               2DF
PREDEC_CHECK_FIRST_A  1A14
PREDEC_CHECK_FIRST_D  1A6E
PREDEC_FIRST_A      1A24
PREDEC_FIRST_D      1A7E
PREDEC_INC_LOOP_A   1A08
PREDEC_INC_LOOP_D   1A62
PREDEC_LOOP_A       19FE
PREDEC_LOOP_A_DONE  1A4A
PREDEC_LOOP_D       1A58
PREDEC_SKIP_TO_D    1A58
PRE_DEC             2D6
PRE_DECREMENT       18F2
PRINT               1280
PRINTLN             128A
PRINT_ADDQ          15C2
PRINT_ADD_ADDA      133E
PRINT_AS            17C0
PRINT_B             17F4
PRINT_BEQ           1632
PRINT_BGT           164A
PRINT_BLE           163E
PRINT_BRA           1626
PRINT_BRA_BCC       15FC
PRINT_CORRECT_SHIFT_ROTATION  17A0
PRINT_DIRECTION     177E
PRINT_INSTRUCTION   1432
PRINT_IT            17CC
PRINT_JSR           1588
PRINT_L             180C
PRINT_LEA           159E
PRINT_LEFT          1796
PRINT_LS            17C8
PRINT_LS_AS_RO      14AA
PRINT_MOVEM         16AE
PRINT_MOVEQ         12B0
PRINT_MOVE_MOVEA    12F4
PRINT_NOP           129C
PRINT_NOT           155E
PRINT_OR            142E
PRINT_RTS           12A6
PRINT_SUB           1418
PRINT_SUB_AND_OR    13E6
PRINT_W             1800
RETURN              2E5
RIGHT               2C6
RO_INS              2A0
RTS_INS             265
SCREENFLUSH_CHECK   1186
SIZE                1818
SLASH               2E3
SPACE               2DA
START               1000
STARTINGMSG         0
SUB_INS             296
TAB                 9
WORD                259
W_IMM               1972
XN                  19AC
