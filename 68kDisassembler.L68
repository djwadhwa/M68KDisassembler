00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 8:22:18 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 46 69 6E ...     22  EndOfMemLoop        dc.b    '---Finished Reading Instructions---',CR,LF,0
00000199= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to continue with the next set of instructions',0
000001D3= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
0000020F= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
00000245= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000255                            27  
00000255                            28  *START_ADDR_BUFFER  DS.B    256
00000255                            29  *END_ADDR_BUFFER    DS.B    256
00000255                            30  
00000255                            31  *size
00000255= 2E 4C 20 00               32  long                DC.B    '.L ',0
00000259= 2E 57 20 00               33  word                DC.B    '.W ',0
0000025D= 2E 42 20 00               34  byte                DC.B    '.B ',0
00000261                            35  
00000261                            36  *instructions
00000261= 4E 4F 50 00               37  nop_ins             DC.B    'NOP',0
00000265= 52 54 53 00               38  rts_ins             DC.B    'RTS',0
00000269= 4D 4F 56 45 00            39  move_ins                DC.B    'MOVE',0
0000026E= 4D 4F 56 45 51 20 00      40  moveq_ins           DC.B    'MOVEQ ',0
00000275= 4D 4F 56 45 4D 00         41  movem_ins           DC.B    'MOVEM',0
0000027B= 4D 4F 56 45 41 00         42  movea_ins           DC.B    'MOVEA',0
00000281= 41 44 44 00               43  add_ins             DC.B    'ADD',0
00000285= 41 44 44 41 00            44  adda_ins                DC.B    'ADDA',0
0000028A= 41 44 44 51 00            45  addq_ins                DC.B    'ADDQ',0
0000028F= 4F 52 00                  46  or_ins              DC.B    'OR',0
00000292= 41 4E 44 00               47  and_ins             DC.B    'AND',0
00000296= 53 55 42 00               48  sub_ins             DC.B    'SUB',0
0000029A= 4C 53 00                  49  ls_ins              DC.B    'LS',0
0000029D= 41 53 00                  50  as_ins              DC.B    'AS',0
000002A0= 52 4F 00                  51  ro_ins              DC.B    'RO',0
000002A3= 4E 4F 54 00               52  not_ins             DC.B    'NOT',0
000002A7= 4A 53 52 20 00            53  jsr_ins             DC.B    'JSR ',0
000002AC= 4C 45 41 20 00            54  lea_ins             DC.B    'LEA ',0
000002B1= 41 44 44 51 00            55  andq_ins                DC.B    'ADDQ',0
000002B6= 42 47 54 00               56  bgt_ins             DC.B    'BGT',0
000002BA= 42 4C 45 00               57  ble_ins             DC.B    'BLE',0
000002BE= 42 45 51 00               58  beq_ins             DC.B    'BEQ',0
000002C2= 42 52 41 00               59  bra_ins             DC.B    'BRA',0
000002C6                            60  
000002C6                            61  *direction
000002C6= 52 00                     62  right               DC.B    'R',0
000002C8= 4C 00                     63  left                    DC.B    'L',0
000002CA                            64  
000002CA                            65  *EA
000002CA= 44 00                     66  D_reg               DC.B    'D',0
000002CC= 41 00                     67  A_reg               DC.B    'A',0
000002CE= 28 41 00                  68  open_paran          DC.B    '(A',0
000002D1= 29 00                     69  close_paran         DC.B    ')',0
000002D3= 29 2B 00                  70  post_inc                DC.B    ')+',0
000002D6= 2D 28 41 00               71  pre_dec             DC.B    '-(A',0
000002DA                            72  
000002DA                            73  *extra
000002DA= 20 00                     74  space               DC.B    ' ',0
000002DC= 2C 20 00                  75  comma               DC.B    ', ',0
000002DF= 23 00                     76  pound               DC.B    '#',0
000002E1= 2D 00                     77  dash                    DC.B    '-',0
000002E3= 2F 00                     78  slash               DC.B    '/',0
000002E5  =00000009                 79  tab                  EQU     $9
000002E5= 0D 0A 00                  80  return              DC.B    CR,LF,0
000002E8= 44 41 54 41 20 24 00      81  data                    DC.B    'DATA $',0
000002EF= 24 00                     82  dollar              DC.B    '$',0
000002F1                            83      
00001000                            84      ORG    $1000    *Start at address $1000
00001000                            85  START:                  ; first instruction of program
00001000                            86  
00001000                            87  *---------- Beginning Messages ----------*
00001000                            88      
00001000  103C 000E                 89      move.b      #14,D0
00001004  43F8 0000                 90      lea         StartingMsg,A1 
00001008  4E4F                      91      trap        #15
0000100A                            92      
0000100A  103C 000E                 93      move.b      #14,D0
0000100E  43F8 001F                 94      lea         Creators,A1
00001012  4E4F                      95      trap        #15
00001014                            96      
00001014  4EB9 00001066             97      jsr         MENU
0000101A                            98      
0000101A                            99  * ---------- END OF PROGRAM -------------*
0000101A                           100  
0000101A  103C 000E                101      move.b      #14,D0
0000101E  43F8 0245                102      lea         ExitMsg,A1 
00001022  4E4F                     103      trap        #15
00001024                           104      
00001024  103C 0009                105      move.b      #9,D0
00001028  4E4F                     106      trap        #15
0000102A                           107  * ---------------------------------------*
0000102A                           108      
0000102A                           109  *-- End of Opening and Ending Messages --*
0000102A                           110  
0000102A                           111  *--------- Start of I/O Section ---------*
0000102A                           112  
0000102A                           113  Clear_Registers:
0000102A  4280                     114      clr.l     D0
0000102C  4281                     115      clr.l     D1
0000102E  4282                     116      clr.l     D2
00001030  4283                     117      clr.l     D3
00001032  4284                     118      clr.l     D4
00001034  4285                     119      clr.l     D5
00001036  4286                     120      clr.l     D6
00001038  4287                     121      clr.l     D7
0000103A                           122      
0000103A  207C 00000000            123      movea.l   #0,A0
00001040  227C 00000000            124      movea.l   #0,A1
00001046  247C 00000000            125      movea.l   #0,A2
0000104C  267C 00000000            126      movea.l   #0,A3
00001052  287C 00000000            127      movea.l   #0,A4
00001058  2A7C 00000000            128      movea.l   #0,A5
0000105E  2C7C 00000000            129      movea.l   #0,A6
00001064  4E75                     130      rts
00001066                           131  
00001066                           132  MENU:
00001066  4EB8 102A                133      jsr         Clear_Registers
0000106A  4EB9 0000107E            134      jsr         GetStartAddress
00001070  4EB9 0000109E            135      jsr         GetEndAddress
00001076                           136      
00001076  4EB9 000010D6            137      jsr         MemSearch
0000107C  4E75                     138      rts
0000107E                           139      
0000107E                           140  GetStartAddress:         *Display input message
0000107E  103C 000E                141      move.b  #14, D0
00001082  43F8 004E                142      lea         InputMsg1,A1
00001086  4E4F                     143      trap #15
00001088  227C 00000000            144      MOVEA.L #0, A1
0000108E  103C 0002                145      move.b      #2,D0
00001092  4E4F                     146      trap        #15
00001094                           147          
00001094  4EB9 00001B1A            148      jsr ASCIItoHex              *conversion to Hex
0000109A                           149      * Address Located in D6
0000109A  2846                     150      movea.l     D6,A4           *move into address register 4
0000109C  4E75                     151      rts
0000109E                           152      
0000109E                           153      
0000109E                           154  GetEndAddress:
0000109E  103C 000E                155      move.b      #14,D0          *Display input message
000010A2  43F8 008F                156      lea         InputMsg2,A1
000010A6  4E4F                     157      trap        #15
000010A8  227C 00000000            158      MOVEA.L #0, A1
000010AE  103C 0002                159      move.b      #2,D0
000010B2  4E4F                     160      trap        #15
000010B4                           161      
000010B4  4EB9 00001B1A            162      jsr         ASCIItoHex      *conversion to hex
000010BA                           163      * Address Located in D6 (overwrite)
000010BA  2A46                     164      movea.l     D6,A5           *move into address register 5
000010BC  4E75                     165      rts
000010BE                           166  
000010BE                           167  
000010BE                           168  ClearScreen:
000010BE  43F8 02E5                169      lea     return,A1
000010C2  103C 000E                170      move.b  #14,D0
000010C6  4E4F                     171      trap    #15
000010C8                           172  
000010C8  B27C 0028                173      cmp.w   #40,D1
000010CC  6700 0006                174      beq     ClearDone
000010D0  5241                     175      add.w   #1,D1
000010D2  60EA                     176      bra     ClearScreen
000010D4                           177      
000010D4                           178  ClearDone:
000010D4  4E75                     179      rts
000010D6                           180      
000010D6                           181  MemSearch:
000010D6  7200                     182      move.l      #0,D1
000010D8  4EB8 10BE                183      jsr         ClearScreen
000010DC                           184      * Set up instruction counter and place onto stack
000010DC  303C 0000                185      move.w      #0,D0
000010E0  3F00                     186      move.w      D0,-(SP)
000010E2                           187      
000010E2  4EB9 000010EA            188      jsr MemSearchLoop
000010E8  4E75                     189      rts
000010EA                           190      
000010EA                           191  MemSearchLoop:
000010EA                           192      
000010EA                           193      * Check if we reached the end address
000010EA  BBCC                     194      cmp.l       A4,A5
000010EC  6700 0036                195      beq         MemSearch_Done
000010F0                           196      
000010F0                           197      * Get data from memory
000010F0  4241                     198      CLR D1
000010F2  3414                     199      move.w     (A4),D2
000010F4  3602                     200      move.w      D2, D3  mutable copy in D3
000010F6                           201      * OPCODE Word Located in D2, mutable copy in D3
000010F6  220C                     202      MOVE.L      A4, D1
000010F8  143C 0010                203      MOVE.B      #16, D2
000010FC  103C 000F                204      MOVE.B      #15, D0     print address of instruction
00001100  4E4F                     205      TRAP        #15
00001102  3403                     206      MOVE.W      D3,D2
00001104  43F8 02DA                207      LEA         space,A1
00001108  4EB9 00001250            208      JSR         print
0000110E  4EB9 0000119A            209      jsr         OPCODE_DECODE    
00001114                           210      
00001114  544C                     211      adda.w      #2,A4
00001116                           212      
00001116                           213      * Call back counter from the stack
00001116  301F                     214      move.w      (SP)+,D0
00001118  5200                     215      add.b       #1,D0
0000111A  4EB9 0000116A            216      jsr         ScreenFlush_Check
00001120  3F00                     217      move.w      D0,-(SP)
00001122                           218      
00001122  60C6                     219      bra         MemSearchLoop
00001124                           220      
00001124                           221  MemSearch_Done
00001124  43F8 0173                222      lea         EndOfMemLoop,A1 
00001128  4EB9 00001250            223      jsr print
0000112E  43F8 02E5                224      lea     return, A1
00001132  4EB9 00001250            225      jsr print
00001138  43F8 020F                226      lea ContinueOrNotMsg, A1
0000113C  4EB9 00001250            227      jsr print
00001142  103C 0005                228      MOVE.B #5, D0
00001146  4E4F                     229      TRAP #15
00001148  43F8 02E5                230      lea return, A1
0000114C  4EB9 00001250            231      jsr print
00001152  B23C 0079                232      CMP.B #121, D1    
00001156  6700 FF0E                233      beq MENU
0000115A  103C 000E                234      move.b      #14,D0
0000115E  43F8 0245                235      lea         ExitMsg,A1 
00001162  4E4F                     236      trap        #15
00001164                           237      
00001164  103C 0009                238      move.b      #9,D0
00001168  4E4F                     239      trap        #15
0000116A                           240  
0000116A                           241  ScreenFlush_Check:
0000116A  B03C 0024                242      cmp.b       #36,D0 * 31
0000116E  6700 0004                243      beq         FlushScreen
00001172  4E75                     244      rts 
00001174                           245  
00001174                           246  FlushScreen:
00001174  43F8 0199                247      lea         FlushScreenMsg,A1
00001178  103C 000E                248      move.b      #14,D0
0000117C  4E4F                     249      trap        #15
0000117E  4EB9 00001186            250      jsr         FlushScreen_Input
00001184  4E75                     251      rts
00001186                           252  
00001186                           253  FlushScreen_Input:
00001186                           254  
00001186  4241                     255      clr     D1
00001188                           256  
00001188  103C 0005                257      move.b  #5,D0
0000118C  4E4F                     258      trap    #15
0000118E                           259      
0000118E  B23C 000D                260      cmp.b   #13,D1
00001192  6700 0004                261      beq     Enter_Press_True    
00001196                           262      
00001196  60EE                     263      bra     FlushScreen_Input
00001198                           264      
00001198                           265  Enter_Press_True:
00001198  4E75                     266      rts
0000119A                           267  
0000119A                           268  * -------- Start of Opcode Section -------*    
0000119A                           269  
0000119A                           270  OPCODE_DECODE:
0000119A                           271      * Begin OPCODE Decoding here
0000119A                           272      * Check first four bits and begin
0000119A                           273      * if-branch breakdown
0000119A  4284                     274      CLR.L D4
0000119C  4285                     275      CLR.L D5
0000119E  4286                     276      CLR.L D6
000011A0  4287                     277      CLR.L D7
000011A2                           278      
000011A2  B47C 4E71                279      CMP.W #$4E71, D2        
000011A6  6700 00C4                280      BEQ print_nop           *check if value is NOP
000011AA                           281      
000011AA  B47C 4E75                282      CMP.W #$4E75, D2        
000011AE  6700 00C6                283      BEQ print_rts           *check if value is RTS
000011B2                           284      
000011B2                           285      * Mask out only the first 4 bits
000011B2  C67C F000                286      AND.W #$F000,D3
000011B6                           287      
000011B6  B67C 9000                288      CMP.W #$9000,D3
000011BA  6700 01FA                289      BEQ print_sub_and_or    *check if value is SUB
000011BE                           290      
000011BE  B67C 6000                291      CMP.W #$6000,D3
000011C2  6700 0408                292      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011C6                           293      
000011C6  B67C 8000                294      CMP.W #$8000, D3
000011CA  6700 01EA                295      BEQ print_sub_and_or    *check if value is OR
000011CE                           296  
000011CE  B67C C000                297      CMP.W #$C000,D3
000011D2  6700 01E2                298      BEQ print_sub_and_or    *check if value is AND
000011D6                           299      
000011D6  B67C D000                300      CMP.W #$D000,D3
000011DA  6700 0132                301      BEQ print_add_adda      *check if value is ADD or ADDA
000011DE                           302      
000011DE  B67C E000                303      CMP.W #$E000,D3
000011E2  6700 0296                304      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
000011E6                           305      
000011E6  B67C 7000                306      CMP.W #$7000,D3
000011EA  6700 0094                307      BEQ print_moveq     *check if value is MOVEQ
000011EE                           308      
000011EE  B47C 1000                309      CMP.W #$1000,D2
000011F2  6D00 003E                310      BLT invalid
000011F6  B47C 4000                311      CMP.W #$4000,D2
000011FA  6D00 00C8                312      BLT print_move_movea    *check if value is MOVE or MOVEA
000011FE                           313      
000011FE                           314      * Mask out only the first 8 bits
000011FE  3602                     315      MOVE.W D2, D3
00001200  C67C FF00                316      AND.W #$FF00,D3
00001204                           317      
00001204  B67C 4600                318      CMP.W #$4600,D3
00001208  6700 0324                319      BEQ print_not           *check if value is NOT
0000120C                           320      
0000120C  B67C 4E00                321      CMP.W #$4E00,D3
00001210  6700 0346                322      BEQ print_jsr           *check if value is JSR
00001214                           323      
00001214                           324      * Mask out only the first 4 bits and the 8th bit
00001214  3602                     325      MOVE.W D2,D3
00001216  C67C F100                326      AND.W #$F100, D3
0000121A                           327      
0000121A  B67C 4000                328      CMP.W #$4000, D3
0000121E  6700 045E                329      BEQ print_movem         *check if value is MOVEM
00001222                           330      
00001222  B67C 4100                331      CMP.W #$4100, D3
00001226  6700 0346                332      BEQ print_lea           *check if value is LEA
0000122A                           333      
0000122A  B67C 5000                334      CMP.W #$5000,D3
0000122E  6700 0362                335      BEQ print_addq          *check if value is ANDQ     
00001232                           336   
00001232                           337  invalid 
00001232  43F8 02E8                338      LEA data, A1
00001236  4EB9 00001250            339      JSR print
0000123C  2202                     340      MOVE.L D2, D1
0000123E  143C 0010                341      MOVE.B #16, D2
00001242  103C 000F                342      MOVE.B  #15, D0     
00001246  4E4F                     343      TRAP #15
00001248  4EB9 00001262            344      JSR enter
0000124E  4E75                     345  out rts
00001250                           346    
00001250                           347  * -------- End of Opcode Section --------*   
00001250                           348  
00001250                           349  * --------- Print Instructions ----------*
00001250                           350  
00001250                           351  print:
00001250  4240                     352      CLR D0 
00001252  103C 000E                353      MOVE.B #14,D0
00001256  4E4F                     354      TRAP #15
00001258  4E75                     355      RTS
0000125A                           356  
0000125A                           357  println:
0000125A  103C 000D                358      MOVE.B #13, D0
0000125E  4E4F                     359      TRAP #15
00001260  4E75                     360      RTS
00001262                           361      
00001262                           362  enter: 
00001262  43F8 02E5                363      LEA return, A1
00001266  4EB8 1250                364      JSR print
0000126A  4E75                     365      RTS
0000126C                           366      
0000126C                           367  print_nop
0000126C  43F8 0261                368      LEA nop_ins, A1
00001270  4EB8 125A                369      JSR println
00001274  60D8                     370      BRA out
00001276                           371  
00001276                           372  print_rts
00001276  43F8 0265                373      LEA rts_ins, A1
0000127A  4EB8 125A                374      JSR println
0000127E  60CE                     375      BRA out
00001280                           376      
00001280                           377  print_moveq
00001280  43F8 026E                378      lea moveq_ins, A1   *print MOVEQ
00001284  4EB8 1250                379      jsr print
00001288  3602                     380      move.w  D2,D3
0000128A  C67C 00FF                381      and.w   #$00FF,D3   * Figure out the immediate address value
0000128E  43F8 02DF                382      lea pound,A1        *print '#'
00001292  4EB8 1250                383      jsr print
00001296  43F8 02EF                384      LEA dollar, A1
0000129A  4EB8 1250                385      JSR print
0000129E  3203                     386      move.w  D3,D1
000012A0  3602                     387      MOVE.W D2,D3
000012A2  343C 0010                388      MOVE.W #16, D2
000012A6  103C 000F                389      move.b  #15,D0
000012AA  4E4F                     390      trap    #15         *print immediate address value
000012AC  43F8 02DC                391      lea comma,A1        *print comma
000012B0  4EB8 1250                392      jsr print
000012B4  3403                     393      MOVE.W D3, D2
000012B6  3A02                     394      MOVE.W D2, D5
000012B8  4EB9 00001988            395      JSR data_reg_sr     *figure out data address
000012BE  4EB8 1262                396      jsr enter           *print out enter
000012C2  608A                     397      bra out
000012C4                           398      
000012C4                           399  print_move_movea
000012C4  3602                     400      MOVE.W D2, D3       
000012C6  C67C 01C0                401      AND.W #$01C0, D3
000012CA  B67C 0040                402      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000012CE  6700 000E                403      BEQ move_a
000012D2  43F8 0269                404      LEA move_ins, A1 *print Instruction 
000012D6  4EB8 1250                405      JSR print
000012DA  6000 000A                406      BRA m_size
000012DE                           407  move_a          *if instruction is MOVEA
000012DE  43F8 027B                408      LEA movea_ins, A1
000012E2  4EB8 1250                409      JSR print
000012E6                           410  m_size              *determine instruction size
000012E6  4EB9 000017A2            411      JSR move_size
000012EC  4EB9 00001804            412      JSR addr        *determine the source address
000012F2  43F8 02DC                413      LEA comma, A1   *print comma
000012F6  4EB8 1250                414      JSR print
000012FA  4207                     415      CLR.B D7
000012FC  1E3C 0001                416      MOVE.B #1, D7   *determine destination address
00001300  4EB9 00001804            417      JSR addr
00001306  4EB8 1262                418      JSR enter       *print enter
0000130A  6000 FF42                419      BRA out
0000130E                           420      
0000130E                           421  print_add_adda
0000130E  3602                     422      MOVE.W D2, D3   
00001310  C63C 00C0                423      AND.B #$C0, D3
00001314  B63C 00C0                424      CMP.B #$C0, D3      *determine if ADD or ADDA
00001318  6700 0052                425      BEQ add_a
0000131C                           426      *if just ADD then print instruction
0000131C  43F8 0281                427      LEA add_ins, A1
00001320  4EB8 1250                428      JSR print
00001324                           429      *print instruction size for ADD
00001324  4EB9 000017E8            430      JSR size
0000132A                           431      *determine direction of ADD, Dn -> EA or EA -> Dn
0000132A  3602                     432      MOVE.W D2,D3
0000132C  C67C 0100                433      AND.W #$0100, D3
00001330  B67C 0100                434      CMP.W #$0100, D3
00001334  6700 001C                435      BEQ ea_dest_add 
00001338  4EB9 00001804            436      JSR addr            *if Direction bit is 0
0000133E  43F8 02DC                437      LEA comma, A1
00001342  4EB8 1250                438      JSR print
00001346  3A02                     439      MOVE.W D2,D5
00001348  4EB9 00001988            440      JSR data_reg_sr
0000134E  6000 005E                441      BRA end_add
00001352                           442  ea_dest_add             *if Direction bit is 1
00001352  3A02                     443      MOVE.W D2,D5
00001354  4EB9 00001988            444      JSR data_reg_sr
0000135A  43F8 02DC                445      LEA comma, A1
0000135E  4EB8 1250                446      JSR print
00001362  4EB9 00001804            447      JSR addr
00001368  6000 0044                448      BRA end_add
0000136C                           449  add_a                   *if instruction is ADDA
0000136C  43F8 0285                450      LEA adda_ins, A1
00001370  4EB8 1250                451      JSR print
00001374                           452      *print instruction size for ADDA (either W or L)
00001374  3602                     453      MOVE.W D2,D3
00001376  C67C 0100                454      AND.W #$0100, D3
0000137A  B67C 0100                455      CMP.W #$0100, D3
0000137E  6700 000E                456      BEQ adda_size
00001382  43F8 0259                457      LEA word, A1
00001386  4EB8 1250                458      JSR print
0000138A  6000 000E                459      BRA next_add
0000138E                           460  adda_size
0000138E  43F8 0255                461      LEA long,A1
00001392  4EB8 1250                462      JSR print
00001396  183C 0080                463      MOVE.B #$80, D4
0000139A                           464  next_add                *print effective address for ADDA
0000139A  4EB9 00001804            465      JSR addr            
000013A0  43F8 02DC                466      LEA comma, A1
000013A4  4EB8 1250                467      JSR print
000013A8  4EB9 000019A0            468      JSR add_reg_sr
000013AE                           469  end_add                 *complete instruction printing by printing enter
000013AE  4EB8 1262                470      JSR enter
000013B2  6000 FE9A                471      BRA out
000013B6                           472  
000013B6                           473  print_sub_and_or
000013B6                           474      *determine if instruction is SUB, AND, or OR.
000013B6  3602                     475      MOVE.W D2, D3
000013B8  C67C F0C0                476      AND.W #$F0C0, D3
000013BC  B67C C0C0                477      CMP.W #$C0C0, D3
000013C0  6700 0090                478      BEQ mul_div
000013C4  B67C 80C0                479      CMP.W #$80C0, D3
000013C8  6700 0088                480      BEQ mul_div
000013CC  C67C F000                481      AND.W #$F000,D3
000013D0  B67C 8000                482      CMP.W #$8000, D3
000013D4  6700 0028                483      BEQ print_or
000013D8  B67C 9000                484      CMP.W #$9000, D3
000013DC  6700 000A                485      BEQ print_sub
000013E0  43F8 0292                486      LEA and_ins, A1
000013E4  6000 001C                487      BRA print_instruction
000013E8                           488  print_sub
000013E8  3602                     489      MOVE.W D2, D3
000013EA  C67C 00C0                490      AND.W #$00C0, D3
000013EE  B63C 00C0                491      CMP.B #$C0, D3
000013F2  6700 FE3E                492      BEQ invalid
000013F6  43F8 0296                493      LEA sub_ins, A1
000013FA  6000 0006                494      BRA print_instruction
000013FE                           495  print_or
000013FE  43F8 028F                496      LEA or_ins, A1
00001402                           497  print_instruction       *print correct instruction
00001402  4EB8 1250                498      JSR print
00001406  4EB9 000017E8            499      JSR size            *print instruction size
0000140C  3602                     500      MOVE.W D2,D3
0000140E                           501  *determine direction of ADD, Dn -> EA or EA -> Dn   
0000140E  C67C 0100                502      AND.W #$0100, D3
00001412  B67C 0100                503      CMP.W #$0100, D3
00001416  6700 001C                504      BEQ ea_dest_sub_and_or
0000141A  4EB9 00001804            505      JSR addr            *if Direction bit is 0
00001420  43F8 02DC                506      LEA comma, A1
00001424  4EB8 1250                507      JSR print
00001428  3A02                     508      MOVE.W D2,D5
0000142A  4EB9 00001988            509      JSR data_reg_sr
00001430  6000 FF7C                510      BRA end_add
00001434                           511  ea_dest_sub_and_or      *if Direction bit is 1
00001434  3A02                     512      MOVE.W D2,D5
00001436  4EB9 00001988            513      JSR data_reg_sr
0000143C  43F8 02DC                514      LEA comma, A1
00001440  4EB8 1250                515      JSR print
00001444  4EB9 00001804            516      JSR addr
0000144A                           517      *complete instruction printing by printing enter
0000144A  4EB8 1262                518      JSR enter
0000144E  6000 FDFE                519      BRA out
00001452                           520      
00001452                           521  mul_div             *deal with MULU and DIVU cases
00001452  4283                     522      CLR.L D3
00001454  3602                     523      MOVE.W D2,D3
00001456  C67C 00FF                524      AND.W #$00FF, D3
0000145A  B6BC 000000F8            525      CMP.L #$00F8, D3
00001460  6D00 FDD0                526      BLT invalid
00001464  B6BC 000000F9            527      CMP.L #$00F9, D3
0000146A  6700 0008                528      BEQ mul_div_long
0000146E  544C                     529      ADDA.W #2,A4
00001470  6000 FDC0                530      BRA invalid
00001474                           531  mul_div_long
00001474  584C                     532      ADDA.W #4,A4
00001476  6000 FDBA                533      BRA invalid
0000147A                           534      
0000147A                           535  print_ls_as_ro
0000147A                           536      *figure out if shift or rotation are memory or register based               
0000147A  3602                     537      MOVE.W D2, D3
0000147C  C63C 00C0                538      AND.B #$C0, D3
00001480  B63C 00C0                539      CMP.B #$C0, D3
00001484  6700 0072                540      BEQ ls_as_ro_mem
00001488  3602                     541      MOVE.W D2, D3
0000148A  E60B                     542      LSR.B #3, D3
0000148C                           543      *print correct instruction type (logical shift, arithmetic shift, or rotation)
0000148C  4EB9 00001770            544      JSR print_correct_shift_rotation
00001492  4EB9 0000174E            545      JSR print_direction     *print direction
00001498  4EB9 000017E8            546      JSR size                *print size
0000149E  3602                     547      MOVE.W D2, D3
000014A0  C63C 0020                548      AND.B #$20,D3
000014A4  B63C 0020                549      CMP.B #$20, D3
000014A8                           550      *determine if instruction is using immediate address or register
000014A8  6700 0030                551      BEQ ls_as_ro_reg     
000014AC  43F8 02DF                552      LEA pound, A1        *if immediate address print '#'
000014B0  4EB8 1250                553      JSR print
000014B4                           554      *print immediate address rotation value
000014B4  3C02                     555      MOVE.W D2,D6
000014B6  EF5E                     556      ROL.W #7,D6
000014B8  CC7C 0007                557      AND.W #$0007, D6
000014BC  43F8 02EF                558      LEA dollar, A1
000014C0  4EB8 1250                559      JSR print
000014C4  4281                     560      CLR.L D1
000014C6  3206                     561      MOVE.W D6, D1
000014C8  3602                     562      MOVE.W D2, D3
000014CA  143C 0010                563      MOVE.B #16, D2
000014CE  103C 000F                564      MOVE.B #15, D0
000014D2  4E4F                     565      TRAP #15
000014D4  3403                     566      MOVE.W D3,D2
000014D6  6000 000A                567      BRA continue_instruction_ls_as_ro
000014DA                           568  ls_as_ro_reg            *if instruction is using register to shift values in another register
000014DA  3A02                     569      MOVE.W D2,D5
000014DC  4EB9 00001988            570      JSR data_reg_sr
000014E2                           571  continue_instruction_ls_as_ro *complete instrcuction
000014E2  43F8 02DC                572      LEA comma, A1       *print comma
000014E6  4EB8 1250                573      JSR print
000014EA  3A02                     574      MOVE.W D2,D5
000014EC  EE5D                     575      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
000014EE  4EB9 00001988            576      JSR data_reg_sr     *determine destination data register to perform instruction on
000014F4  6000 0030                577      BRA next_ls_as_ro   *finish printing instruction
000014F8                           578  ls_as_ro_mem            *check if immediate address is being shifted or rotated
000014F8  3602                     579      MOVE.W D2, D3
000014FA  C63C 003F                580      AND.B #$3F, D3
000014FE  B63C 003C                581      CMP.B #$3C, D3
00001502  6700 FD2E                582      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001506                           583      *if not immediate adress print normally 
00001506  3602                     584      MOVE.W D2, D3
00001508  EF5B                     585      ROL.W #7, D3    
0000150A  4EB9 00001770            586      JSR print_correct_shift_rotation
00001510  3602                     587      MOVE.W D2,D3
00001512  4EB9 0000174E            588      JSR print_direction
00001518  43F8 0259                589      LEA word, A1
0000151C  4EB8 1250                590      JSR print
00001520  4EB9 00001804            591      JSR addr
00001526                           592  next_ls_as_ro
00001526  4EB8 1262                593      JSR enter
0000152A  6000 FD22                594      BRA out
0000152E                           595      
0000152E                           596  print_not
0000152E  43F8 02A3                597      LEA not_ins, A1 *print instruction
00001532  4EB8 1250                598      JSR print
00001536  4EB9 000017E8            599      JSR size
0000153C  3602                     600      MOVE.W D2, D3
0000153E  C63C 003F                601      AND.B #$3F, D3
00001542  B63C 003C                602      CMP.B #$3C, D3
00001546  6700 FCEA                603      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
0000154A  4EB9 00001804            604      JSR addr
00001550  4EB8 1262                605      JSR enter
00001554  6000 FCF8                606      BRA out
00001558                           607  
00001558                           608  print_jsr
00001558  43F8 02A7                609      LEA jsr_ins, A1 *print instruction
0000155C  4EB8 1250                610      JSR print
00001560  4EB9 00001804            611      JSR addr    *print address
00001566  4EB8 1262                612      JSR enter   *print enter (next line)
0000156A  6000 FCE2                613      BRA out
0000156E                           614  
0000156E                           615  print_lea
0000156E  43F8 02AC                616      LEA lea_ins, A1 *print instruction
00001572  4EB8 1250                617      JSR print   
00001576  4EB9 00001804            618      JSR addr    *print address
0000157C  43F8 02DC                619      LEA comma, A1   *print comma
00001580  4EB8 1250                620      JSR print
00001584  4EB9 000019A0            621      JSR add_reg_sr *print destination address register
0000158A  4EB8 1262                622      JSR enter
0000158E  6000 FCBE                623      BRA out
00001592                           624  
00001592                           625  print_addq
00001592  43F8 028A                626      LEA addq_ins, A1    *print instruction
00001596  4EB8 1250                627      JSR print
0000159A  4EB9 000017E8            628      JSR size            *print instruction size
000015A0  43F8 02DF                629      LEA pound, A1
000015A4  4EB8 1250                630      JSR print           *print '#' for immediate addressing
000015A8  3C02                     631      MOVE.W D2,D6
000015AA  EF5E                     632      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015AC  CC7C 0007                633      AND.W #$0007, D6
000015B0  4EB9 0000197C            634      JSR Xn
000015B6  43F8 02DC                635      LEA comma, A1       *print comma
000015BA  4EB8 1250                636      JSR print
000015BE  4EB9 00001804            637      JSR addr            *print destination address
000015C4  4EB8 1262                638      JSR enter
000015C8  6000 FC84                639      BRA out
000015CC                           640  
000015CC                           641  print_bra_bcc           *needs comments
000015CC  3602                     642      MOVE.W D2,D3
000015CE  C67C 0F00                643      AND.W #$0F00, D3
000015D2  B67C 0000                644      CMP.W #$0000, D3
000015D6  6700 001E                645      BEQ print_bra
000015DA  B67C 0700                646      CMP.W #$0700, D3
000015DE  6700 0022                647      BEQ print_beq
000015E2  B67C 0E00                648      CMP.W #$0E00, D3
000015E6  6700 0032                649      BEQ print_bgt
000015EA  B67C 0F00                650      CMP.W #$0F00, D3
000015EE  6700 001E                651      BEQ print_ble
000015F2  6000 FC3E                652      BRA invalid
000015F6                           653  print_bra
000015F6  43F8 02C2                654      LEA bra_ins, A1
000015FA  4EB8 1250                655      JSR print
000015FE  6000 0022                656      BRA next_bra_bcc
00001602                           657  print_beq
00001602  43F8 02BE                658      LEA beq_ins, A1
00001606  4EB8 1250                659      JSR print
0000160A  6000 0016                660      BRA next_bra_bcc
0000160E                           661  print_ble
0000160E  43F8 02BA                662      LEA ble_ins, A1
00001612  4EB8 1250                663      JSR print
00001616  6000 000A                664      BRA next_bra_bcc
0000161A                           665  print_bgt
0000161A  43F8 02B6                666      LEA bgt_ins, A1
0000161E  4EB8 1250                667      JSR print
00001622                           668  next_bra_bcc
00001622  3602                     669      MOVE.W D2, D3
00001624  C67C 00FF                670      AND.W #$00FF, D3
00001628  B67C 0000                671      CMP.W #$0000, D3
0000162C  6700 0026                672      BEQ check_word
00001630  43F8 025D                673      LEA byte, A1
00001634  4EB8 1250                674      JSR print
00001638  43F8 02EF                675      LEA dollar, A1
0000163C  4EB8 1250                676      JSR print
00001640  3203                     677      MOVE.W D3, D1
00001642  3602                     678      MOVE.W D2, D3
00001644  343C 0010                679      MOVE.W #16, D2
00001648  303C 000F                680      MOVE.W #15,D0
0000164C  4E4F                     681      trap #15            *print immediate address value
0000164E  3403                     682      MOVE.W D3, D2
00001650  6000 0024                683      BRA end_bra_bcc
00001654                           684  check_word
00001654  43F8 0259                685      LEA word, A1
00001658  4EB8 1250                686      JSR print
0000165C  43F8 02EF                687      LEA dollar, A1
00001660  4EB8 1250                688      JSR print
00001664  544C                     689      ADDA.W #2,A4        *update current address
00001666  3214                     690      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001668  3602                     691      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000166A  343C 0010                692      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000166E  103C 000F                693      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001672  4E4F                     694      TRAP #15
00001674  3403                     695      MOVE.W D3,D2        *copy opcode back to register D2
00001676                           696  end_bra_bcc
00001676  4EB8 1262                697      JSR enter
0000167A  6000 FBD2                698      BRA out
0000167E                           699  
0000167E                           700  print_movem         *needs comments
0000167E  43F8 0275                701      LEA movem_ins, A1
00001682  4EB8 1250                702      JSR print
00001686  3602                     703      MOVE.W D2,D3
00001688  C67C 0040                704      AND.W #$0040,D3
0000168C  B67C 0040                705      CMP.W #$0040,D3
00001690  6700 000E                706      BEQ movem_long
00001694  43F8 0259                707      LEA word, A1
00001698  4EB8 1250                708      JSR print
0000169C  6000 000A                709      BRA movem_direction
000016A0                           710  movem_long
000016A0  43F8 0255                711      LEA long, A1
000016A4  4EB8 1250                712      JSR print
000016A8                           713  movem_direction
000016A8  3602                     714      MOVE.W D2,D3
000016AA  C67C 0400                715      AND.W #$0400,D3
000016AE  B67C 0400                716      CMP.W #$0400,D3
000016B2  6700 001A                717      BEQ mem_to_reg
000016B6  4EB9 0000172A            718      JSR movem_check_pre_post
000016BC  43F8 02DC                719      LEA comma, A1
000016C0  4EB8 1250                720      JSR print
000016C4  4EB9 00001804            721      JSR addr
000016CA  6000 0056                722      BRA end_movem
000016CE                           723  mem_to_reg
000016CE  3602                     724      MOVE.W D2, D3
000016D0  C67C 003F                725      AND.W #$003F, D3
000016D4  B67C 0038                726      CMP.W #$0038, D3
000016D8  6700 000E                727      BEQ fix_mem_order_word
000016DC  B67C 0039                728      CMP.W #$0039, D3
000016E0  6700 0016                729      BEQ fix_mem_order_long
000016E4  6000 0028                730      BRA movem_cont
000016E8                           731  fix_mem_order_word
000016E8  2C4C                     732      MOVE.L A4, A6
000016EA  584E                     733      ADD.W #4, A6
000016EC  2A16                     734      MOVE.L (A6),D5
000016EE  4845                     735      SWAP D5
000016F0  2C85                     736      MOVE.L D5, (A6)
000016F2  4285                     737      CLR.L D5
000016F4  6000 0018                738      BRA movem_cont
000016F8                           739  fix_mem_order_long
000016F8  2C4C                     740      MOVE.L A4, A6
000016FA  544E                     741      ADD.W #2, A6
000016FC  3A16                     742      MOVE.W (A6),D5
000016FE  544E                     743      ADD.W #2, A6
00001700  2C16                     744      MOVE.L (A6),D6
00001702  554E                     745      SUB.W #2, A6
00001704  2C86                     746      MOVE.L D6, (A6)
00001706  584E                     747      ADD.W #4, A6
00001708  3C85                     748      MOVE.W D5, (A6)
0000170A  4285                     749      CLR.L D5
0000170C  4286                     750      CLR.L D6
0000170E                           751  movem_cont
0000170E  4EB9 00001804            752      JSR addr
00001714  43F8 02DC                753      LEA comma, A1
00001718  4EB8 1250                754      JSR print
0000171C  4EB9 0000172A            755      JSR movem_check_pre_post
00001722                           756  end_movem
00001722  4EB8 1262                757      JSR enter
00001726  6000 FB26                758      BRA out
0000172A                           759      
0000172A                           760  movem_check_pre_post:
0000172A  3602                     761      MOVE.W D2, D3
0000172C  C67C 0038                762      AND.W #$0038, D3
00001730  B67C 0020                763      CMP.W #$0020, D3
00001734  6700 000C                764      BEQ movem_check_pre
00001738  4EB9 00001A68            765      JSR movem_postinc
0000173E  6000 0008                766      BRA movem_check_done
00001742                           767  movem_check_pre
00001742  4EB9 000019B8            768      JSR movem_predec
00001748                           769  movem_check_done
00001748  4287                     770      CLR.L D7
0000174A  4281                     771      CLR.L D1
0000174C  4E75                     772      RTS
0000174E                           773  
0000174E                           774  print_direction:
0000174E                           775  *print correct direction given direction bit
0000174E  C67C 0100                776      AND.W #$0100, D3
00001752  B67C 0100                777      CMP.W #$0100, D3
00001756  6700 000E                778      BEQ print_left  *print left
0000175A  43F8 02C6                779      LEA right, A1
0000175E  4EB8 1250                780      JSR print
00001762  6000 FAEA                781      BRA out
00001766                           782  print_left
00001766  43F8 02C8                783      LEA left, A1
0000176A  4EB8 1250                784      JSR print *print right
0000176E  4E75                     785      RTS
00001770                           786      
00001770                           787  print_correct_shift_rotation:
00001770                           788  *determine if instruction is logical, arithmetic, or rotation 
00001770  C63C 0003                789      AND.B #$03, D3
00001774  B63C 0000                790      CMP.B #$00, D3
00001778  6700 0016                791      BEQ print_as
0000177C  B63C 0001                792      CMP.B #$01, D3
00001780  6700 0016                793      BEQ print_ls
00001784  B63C 0003                794      CMP.B #$03, D3
00001788  43F8 02A0                795      LEA ro_ins, A1  print rotation
0000178C  6000 000E                796      BRA print_it
00001790                           797  print_as
00001790  43F8 029D                798      LEA as_ins, A1  print arithmetic shift
00001794  6000 0006                799      BRA print_it
00001798                           800  print_ls
00001798  43F8 029A                801      LEA ls_ins, A1 print logical shift
0000179C                           802  print_it
0000179C  4EB8 1250                803      JSR print
000017A0  4E75                     804      RTS
000017A2                           805  * --------- End Print Instruction ----------*
000017A2                           806  
000017A2                           807  * ------- Instruction sizes ---------*
000017A2                           808  
000017A2                           809  move_size:  *print size for MOVE and MOVEA instruction
000017A2  4284                     810      CLR.L D4
000017A4  3802                     811      MOVE.W D2, D4
000017A6  C87C 3000                812      AND.W #$3000, D4
000017AA  B87C 1000                813      CMP.W #$1000, D4
000017AE  6700 0014                814      BEQ print_b
000017B2  B87C 3000                815      CMP.W #$3000, D4
000017B6  6700 0018                816      BEQ print_w
000017BA  B87C 2000                817      CMP.W #$2000, D4
000017BE  6700 001C                818      BEQ print_l
000017C2  4E75                     819      RTS
000017C4                           820      
000017C4                           821  print_b     *print '.B'
000017C4  43F8 025D                822      LEA byte, A1
000017C8  4EB8 1250                823      JSR print
000017CC  6000 FA80                824      BRA out
000017D0                           825      
000017D0                           826  print_w     *print '.W'
000017D0  43F8 0259                827      LEA word, A1
000017D4  4EB8 1250                828      JSR print
000017D8  6000 FA74                829      BRA out
000017DC                           830      
000017DC                           831  print_l:    *print '.L'
000017DC  43F8 0255                832      LEA long, A1
000017E0  4EB8 1250                833      JSR print
000017E4  6000 FA68                834      BRA out
000017E8                           835  
000017E8                           836  size:       *print size for non "move" instructions
000017E8  4284                     837      CLR.L D4
000017EA  1802                     838      MOVE.B D2,D4
000017EC  C83C 00C0                839      AND.B #$C0, D4
000017F0  B83C 0000                840      CMP.B #$00, D4
000017F4  67CE                     841      BEQ print_b
000017F6  B83C 0040                842      CMP.B #$40,D4
000017FA  67D4                     843      BEQ print_w
000017FC  B83C 0080                844      CMP.B #$80, D4
00001800  67DA                     845      BEQ print_l
00001802  4E75                     846      RTS
00001804                           847      
00001804                           848  * ------- End Instruction sizes ---------*
00001804                           849  
00001804                           850  * ------- Effective Address -------*
00001804                           851  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
00001804  3A02                     852      MOVE.W D2, D5
00001806  3C02                     853      MOVE.W D2, D6               
00001808  BE3C 0001                854      CMP.B #1, D7
0000180C  6700 003A                855      BEQ destination *check if evaluating destination address (used for MOVE)
00001810                           856  cont
00001810  CC3C 0038                857      AND.B #$38, D6
00001814  BC3C 0000                858      CMP.B #0, D6
00001818  6700 0038                859      BEQ data_reg        *check if EA mode is data register
0000181C  BC3C 0008                860      CMP.B #$08, D6
00001820  6700 0048                861      BEQ add_reg         *check if EA mode is address register
00001824  BC3C 0010                862      CMP.B #$10, D6
00001828  6700 0058                863      BEQ add_indirect    *check if EA mode is address indirect
0000182C  BC3C 0018                864      CMP.B #$18, D6
00001830  6700 0070                865      BEQ post_increment  *check if EA mode is post increment
00001834  BC3C 0020                866      CMP.B #$20, D6
00001838  6700 0088                867      BEQ pre_decrement   *check if EA mode is pre_decrement
0000183C  BC3C 0038                868      CMP.B #$38, D6
00001840  6700 00A0                869      BEQ absolute_or_immediate
00001844  6000 FA08                870      BRA out *needs Immediate, Abs Long, and Abs Word
00001848                           871  destination     *perform correct rotation to retrieve destination address
00001848  3C05                     872      MOVE.W D5,D6
0000184A  EF5D                     873      ROL.W #7,D5
0000184C  E64E                     874      LSR.W #3,D6
0000184E  60C0                     875      BRA cont
00001850  4E75                     876      RTS
00001852                           877  
00001852                           878  data_reg    *used with addr sub routine
00001852  3C05                     879      MOVE.W D5,D6    
00001854  CC3C 0007                880      AND.B #$07, D6  
00001858  43F8 02CA                881      LEA D_reg, A1   
0000185C  4EB8 1250                882      JSR print
00001860  4EB9 0000197C            883      JSR Xn
00001866  6000 F9E6                884      BRA out
0000186A                           885  
0000186A                           886  add_reg     *used with addr sub routine
0000186A  3C05                     887      MOVE.W D5,D6    
0000186C  CC3C 0007                888      AND.B #$07, D6
00001870  43F8 02CC                889      LEA A_reg, A1   
00001874  4EB8 1250                890      JSR print
00001878  4EB9 0000197C            891      JSR Xn
0000187E  6000 F9CE                892      BRA out
00001882                           893      
00001882                           894  add_indirect    *used with addr sub routine
00001882  3C05                     895      MOVE.W D5,D6    
00001884  CC3C 0007                896      AND.B #$07, D6
00001888  43F8 02CE                897      LEA open_paran, A1  
0000188C  4EB8 1250                898      JSR print
00001890  4EB9 0000197C            899      JSR Xn
00001896  43F8 02D1                900      LEA close_paran, A1 
0000189A  4EB8 1250                901      JSR print
0000189E  6000 F9AE                902      BRA out
000018A2                           903      
000018A2                           904  post_increment  *used with addr sub routine
000018A2  3C05                     905      MOVE.W D5,D6    
000018A4  CC3C 0007                906      AND.B #$07, D6
000018A8  43F8 02CE                907      LEA open_paran, A1  
000018AC  4EB8 1250                908      JSR print
000018B0  4EB9 0000197C            909      JSR Xn
000018B6  43F8 02D3                910      LEA post_inc, A1    
000018BA  4EB8 1250                911      JSR print
000018BE  6000 F98E                912      BRA out
000018C2                           913      
000018C2                           914  pre_decrement   *used with addr sub routine
000018C2  3C05                     915      MOVE.W D5,D6    
000018C4  CC3C 0007                916      AND.B #$07, D6
000018C8  43F8 02D6                917      LEA pre_dec, A1 
000018CC  4EB8 1250                918      JSR print
000018D0  4EB9 0000197C            919      JSR Xn
000018D6  43F8 02D1                920      LEA close_paran, A1 
000018DA  4EB8 1250                921      JSR print
000018DE  6000 F96E                922      BRA out
000018E2                           923  
000018E2                           924  absolute_or_immediate *check if EA is immediate or absolute address
000018E2  3C05                     925      MOVE.W D5,D6    
000018E4  CC3C 0007                926      AND.B #$07, D6
000018E8  BC3C 0000                927      CMP.B #$00, D6
000018EC  6700 0054                928      BEQ w_imm
000018F0  BC3C 0001                929      CMP.B #$01, D6
000018F4  6700 0068                930      BEQ l_imm
000018F8  BC3C 0004                931      CMP.B #04, D6
000018FC  6700 0002                932      BEQ immediate
00001900                           933      
00001900                           934  immediate
00001900  43F8 02DF                935      LEA pound, A1
00001904  4EB8 1250                936      JSR print
00001908  B4BC 00004000            937      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
0000190E  6D00 0016                938      BLT move_movea      *check if instruction is move or movea
00001912  B8BC 00000040            939      CMP.L #$0040, D4        *if not move or movea
00001918  6F00 0028                940      BLE w_imm           *byte and word check the next 2 addresses in mem
0000191C  B8BC 00000080            941      CMP.L #$0080, D4
00001922  6700 003A                942      BEQ l_imm           *long checks the next 4 addresses in mem
00001926                           943  move_movea              *similar comparisons, but for different bits in OPCODE
00001926  B87C 1000                944      CMP.W #$1000, D4
0000192A  6700 0016                945      BEQ w_imm
0000192E  B87C 3000                946      CMP.W #$3000, D4
00001932  6700 000E                947      BEQ w_imm
00001936  B87C 2000                948      CMP.W #$2000, D4
0000193A  6700 0022                949      BEQ l_imm
0000193E                           950  imm_complete
0000193E  6000 F90E                951      BRA out
00001942                           952      
00001942                           953  w_imm
00001942  43F8 02EF                954      LEA dollar, A1      *print '$'
00001946  4EB8 1250                955      JSR print
0000194A  544C                     956      ADDA.W #2,A4        *update current address
0000194C  3214                     957      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000194E  3602                     958      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001950  343C 0010                959      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001954  103C 000F                960      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001958  4E4F                     961      TRAP #15
0000195A  3403                     962      MOVE.W D3,D2        *copy opcode back to register D2
0000195C  60E0                     963      BRA imm_complete    *exit addr subroutine
0000195E                           964      
0000195E                           965  l_imm
0000195E  43F8 02EF                966      LEA dollar, A1      *print '$'
00001962  4EB8 1250                967      JSR print
00001966  544C                     968      ADDA.W  #2,A4       *update current address
00001968  2214                     969      MOVE.L (A4),D1      *retrieve long data stored in the new current address
0000196A  3602                     970      MOVE.W D2, D3
0000196C  343C 0010                971      MOVE.W #16, D2
00001970  103C 000F                972      MOVE.B #15, D0
00001974  4E4F                     973      TRAP #15
00001976  3403                     974      MOVE.W D3,D2
00001978  544C                     975      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
0000197A  60C2                     976      BRA imm_complete    *exit addr subroutine
0000197C                           977  
0000197C                           978  Xn:                     *retieve signed decimal value of data stored in register D6
0000197C  4281                     979      CLR.L D1
0000197E  1206                     980      MOVE.B D6,D1
00001980  103C 0003                981      MOVE.B #3, D0
00001984  4E4F                     982      TRAP #15
00001986  4E75                     983      RTS
00001988                           984  
00001988                           985  data_reg_sr:    *use if dealing with Dn only
00001988  4286                     986      CLR.L D6
0000198A  3C05                     987      MOVE.W D5,D6
0000198C  EF5E                     988      ROL.W #7,D6
0000198E  CC3C 0007                989      AND.B #$07, D6  
00001992  43F8 02CA                990      LEA D_reg, A1   
00001996  4EB8 1250                991      JSR print
0000199A  4EB8 197C                992      JSR Xn
0000199E  4E75                     993      RTS
000019A0                           994      
000019A0                           995  add_reg_sr:     *use if dealing with An only
000019A0  4286                     996      CLR.L D6
000019A2  3C02                     997      MOVE.W D2,D6
000019A4  EF5E                     998      ROL.W #7,D6
000019A6  CC3C 0007                999      AND.B #$07, D6  
000019AA  43F8 02CC               1000      LEA A_reg, A1   
000019AE  4EB8 1250               1001      JSR print
000019B2  4EB8 197C               1002      JSR Xn
000019B6  4E75                    1003      RTS
000019B8                          1004      
000019B8                          1005  movem_predec:           *needs to be worked on
000019B8  4285                    1006      CLR.L D5
000019BA  544C                    1007      ADDA.W  #2,A4       *update current address
000019BC  3A14                    1008      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019BE  3C05                    1009      MOVE.W D5,D6
000019C0  4281                    1010      CLR.L D1
000019C2  4287                    1011      CLR.L D7
000019C4  BA3C 0000               1012      CMP.B #$00, D5
000019C8  6700 005E               1013      BEQ predec_skip_to_d
000019CC  E14E                    1014      LSL #8, D6
000019CE                          1015  predec_loop_a   
000019CE  E34E                    1016      LSL #1, D6
000019D0  6400 0006               1017      BCC predec_inc_loop_a
000019D4  6000 000E               1018      BRA predec_check_first_a
000019D8                          1019  predec_inc_loop_a
000019D8  5201                    1020      ADD.B #1, D1
000019DA  B23C 0008               1021      CMP.B #8, D1
000019DE  66EE                    1022      BNE predec_loop_a
000019E0  6000 0038               1023      BRA predec_loop_a_done  
000019E4                          1024  predec_check_first_a
000019E4  BE3C 0000               1025      CMP.B #0, D7
000019E8  6700 000A               1026      BEQ predec_first_a
000019EC  43F8 02E3               1027      LEA slash, A1
000019F0  4EB8 1250               1028      JSR print
000019F4                          1029  predec_first_a
000019F4  43F8 02CC               1030      LEA A_reg, A1
000019F8  4EB8 1250               1031      JSR print
000019FC  103C 0003               1032      MOVE.B #3, D0
00001A00  4E4F                    1033      TRAP #15
00001A02  5201                    1034      ADD.B #1, D1
00001A04  5207                    1035      ADD.B #1, D7
00001A06  B23C 0008               1036      CMP.B #8, D1
00001A0A  66C2                    1037      BNE predec_loop_a
00001A0C  3C05                    1038      MOVE.W D5,D6
00001A0E  CC7C FF00               1039      AND.W #$FF00, D6
00001A12  BC7C 0000               1040      CMP.W #$00, D6
00001A16  6700 004E               1041      BEQ end_movem_predec
00001A1A                          1042  predec_loop_a_done
00001A1A  3C05                    1043      MOVE.W D5,D6
00001A1C  43F8 02E3               1044      LEA slash, A1
00001A20  4EB8 1250               1045      JSR print
00001A24  4281                    1046      CLR.L D1
00001A26  4287                    1047      CLR.L D7
00001A28                          1048  predec_skip_to_d
00001A28                          1049  predec_loop_d   
00001A28  E34E                    1050      LSL #1, D6
00001A2A  6400 0006               1051      BCC predec_inc_loop_d
00001A2E  6000 000E               1052      BRA predec_check_first_d
00001A32                          1053  predec_inc_loop_d
00001A32  5201                    1054      ADD.B #1, D1
00001A34  B23C 0008               1055      CMP.B #8, D1
00001A38  66EE                    1056      BNE predec_loop_d   
00001A3A  6000 002A               1057      BRA end_movem_predec
00001A3E                          1058  predec_check_first_d
00001A3E  BE3C 0000               1059      CMP.B #0, D7
00001A42  6700 000A               1060      BEQ predec_first_d
00001A46  43F8 02E3               1061      LEA slash, A1
00001A4A  4EB8 1250               1062      JSR print
00001A4E                          1063  predec_first_d
00001A4E  43F8 02CA               1064      LEA D_reg, A1
00001A52  4EB8 1250               1065      JSR print
00001A56  103C 0003               1066      MOVE.B #3, D0
00001A5A  4E4F                    1067      TRAP #15
00001A5C  5201                    1068      ADD.B #1, D1
00001A5E  5207                    1069      ADD.B #1, D7
00001A60  B23C 0008               1070      CMP.B #8, D1
00001A64  66C2                    1071      BNE predec_loop_d
00001A66                          1072  end_movem_predec
00001A66  4E75                    1073      RTS
00001A68                          1074      
00001A68                          1075  movem_postinc:          *needs to be worked on
00001A68  4285                    1076      CLR.L D5
00001A6A  544C                    1077      ADDA.W  #2,A4       *update current address
00001A6C  3A14                    1078      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A6E  3C05                    1079      MOVE.W D5,D6
00001A70  4281                    1080      CLR.L D1
00001A72  4287                    1081      CLR.L D7
00001A74  3C05                    1082      MOVE.W D5,D6
00001A76  CC7C FF00               1083      AND.W #$FF00, D6
00001A7A  BC7C 0000               1084      CMP.W #$00, D6
00001A7E  6700 0058               1085      BEQ postinc_skip_to_d
00001A82  E04E                    1086      LSR #8, D6
00001A84                          1087  postinc_loop_a  
00001A84  E24E                    1088      LSR #1, D6
00001A86  6400 0006               1089      BCC postinc_inc_loop_a
00001A8A  6000 000E               1090      BRA postinc_check_first_a
00001A8E                          1091  postinc_inc_loop_a
00001A8E  5201                    1092      ADD.B #1, D1
00001A90  B23C 0008               1093      CMP.B #8, D1
00001A94  66EE                    1094      BNE postinc_loop_a
00001A96  6000 0032               1095      BRA postinc_loop_a_done 
00001A9A                          1096  postinc_check_first_a
00001A9A  BE3C 0000               1097      CMP.B #0, D7
00001A9E  6700 000A               1098      BEQ postinc_first_a
00001AA2  43F8 02E3               1099      LEA slash, A1
00001AA6  4EB8 1250               1100      JSR print
00001AAA                          1101  postinc_first_a
00001AAA  43F8 02CC               1102      LEA A_reg, A1
00001AAE  4EB8 1250               1103      JSR print
00001AB2  103C 0003               1104      MOVE.B #3, D0
00001AB6  4E4F                    1105      TRAP #15
00001AB8  5201                    1106      ADD.B #1, D1
00001ABA  5207                    1107      ADD.B #1, D7
00001ABC  B23C 0008               1108      CMP.B #8, D1
00001AC0  66C2                    1109      BNE postinc_loop_a
00001AC2  BA3C 0000               1110      CMP.B #$00, D5
00001AC6  6700 0050               1111      BEQ end_movem_postinc
00001ACA                          1112  postinc_loop_a_done
00001ACA  3C05                    1113      MOVE.W D5,D6
00001ACC  43F8 02E3               1114      LEA slash, A1
00001AD0  4EB8 1250               1115      JSR print
00001AD4  4281                    1116      CLR.L D1
00001AD6  4287                    1117      CLR.L D7
00001AD8                          1118  postinc_skip_to_d
00001AD8  3C05                    1119      MOVE.W D5,D6
00001ADA                          1120  postinc_loop_d  
00001ADA  E24E                    1121      LSR #1, D6
00001ADC  6400 0006               1122      BCC postinc_inc_loop_d
00001AE0  6000 000E               1123      BRA postinc_check_first_d
00001AE4                          1124  postinc_inc_loop_d
00001AE4  5201                    1125      ADD.B #1, D1
00001AE6  B23C 0008               1126      CMP.B #8, D1
00001AEA  66EE                    1127      BNE postinc_loop_d  
00001AEC  6000 002A               1128      BRA end_movem_postinc
00001AF0                          1129  postinc_check_first_d
00001AF0  BE3C 0000               1130      CMP.B #0, D7
00001AF4  6700 000A               1131      BEQ postinc_first_d
00001AF8  43F8 02E3               1132      LEA slash, A1
00001AFC  4EB8 1250               1133      JSR print
00001B00                          1134  postinc_first_d
00001B00  43F8 02CA               1135      LEA D_reg, A1
00001B04  4EB8 1250               1136      JSR print
00001B08  103C 0003               1137      MOVE.B #3, D0
00001B0C  4E4F                    1138      TRAP #15
00001B0E  5201                    1139      ADD.B #1, D1
00001B10  5207                    1140      ADD.B #1, D7
00001B12  B23C 0008               1141      CMP.B #8, D1
00001B16  66C2                    1142      BNE postinc_loop_d
00001B18                          1143  end_movem_postinc
00001B18  4E75                    1144      RTS
00001B1A                          1145  
00001B1A                          1146  
00001B1A                          1147  * ------- End Effective Address -------*
00001B1A                          1148  
00001B1A                          1149  * ----- Hex to ASCII & ASCII to HEX -----*
00001B1A                          1150  
00001B1A                          1151  ASCIItoHex:
00001B1A  4EB9 00001B28           1152          jsr     ASCII2Hex_init  
00001B20  4EB9 00001B2E           1153          jsr     conversion_loop
00001B26  4E75                    1154          rts                    
00001B28                          1155  
00001B28                          1156  ASCII2Hex_init:   
00001B28  143C 0000               1157          move.b  #0,D2       *set up counter    
00001B2C  4E75                    1158          rts         
00001B2E                          1159          
00001B2E                          1160  conversion_loop:            
00001B2E  5282                    1161          add.l   #1,D2       *increment counter
00001B30  B4BC 00000009           1162          cmp.l   #9,D2       *ends at 9
00001B36  6700 004A               1163          BEQ     DONE        *branch when compare is true
00001B3A  1819                    1164          move.b  (A1)+,D4    *Get first num
00001B3C                          1165          
00001B3C  B83C 0040               1166          cmp.b   #$40,D4        
00001B40  6E00 000C               1167          bgt     Letters_Cap  
00001B44                          1168          
00001B44  B83C 0039               1169          cmp.b   #$39,D4
00001B48  6F00 0016               1170          BLE     Numbers      
00001B4C  4E75                    1171          rts
00001B4E                          1172          
00001B4E                          1173  Letters_Cap:      
00001B4E  B83C 0046               1174          cmp.b   #$46,D4          
00001B52  6E00 001E               1175          bgt     ERROR  
00001B56  0404 0037               1176          sub.b   #$37,D4     
00001B5A  E986                    1177          asl.l   #4,D6       
00001B5C  DC84                    1178          add.l   D4,D6     
00001B5E  60CE                    1179          bra     conversion_loop 
00001B60                          1180  Numbers:
00001B60  B83C 0030               1181          cmp.b   #$30,D4         
00001B64  6D00 000C               1182          blt     ERROR        
00001B68  0404 0030               1183          sub.b   #$30,D4      
00001B6C  E986                    1184          asl.l   #4,D6        
00001B6E  DC84                    1185          add.l   D4,D6     
00001B70  60BC                    1186          bra     conversion_loop
00001B72                          1187          
00001B72                          1188  ERROR:
00001B72  43F8 011E               1189          lea     ErrorMsg,A1    
00001B76  103C 000E               1190          move.b  #14,D0
00001B7A  4E4F                    1191          trap    #15
00001B7C                          1192      
00001B7C  103C 0009               1193          move.b  #9,D0
00001B80  4E4F                    1194          trap    #15
00001B82                          1195          
00001B82                          1196  DONE:
00001B82                          1197     
00001B82  4241                    1198          clr     D1
00001B84  4242                    1199          clr     D2
00001B86  4244                    1200          clr     D4
00001B88                          1201      
00001B88  43F8 014F               1202          lea     ASCIItoHexMsg,A1
00001B8C  103C 000E               1203          move.b  #14,D0
00001B90  4E4F                    1204          trap    #15
00001B92                          1205  
00001B92  4E75                    1206          rts
00001B94                          1207          
00001B94                          1208  * -- End of Hex to ASCII & ASCII to HEX --*
00001B94                          1209  
00001B94                          1210  * Put program code here
00001B94                          1211  
00001B94  FFFF FFFF               1212      SIMHALT             ; halt simulator
00001B98                          1213  
00001B98                          1214  * Put variables and constants here 
00001B98                          1215  
00001B98                          1216      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  18E2
ADDA_INS            285
ADDA_SIZE           138E
ADDQ_INS            28A
ADDR                1804
ADD_A               136C
ADD_INDIRECT        1882
ADD_INS             281
ADD_REG             186A
ADD_REG_SR          19A0
ANDQ_INS            2B1
AND_INS             292
ASCII2HEX_INIT      1B28
ASCIITOHEX          1B1A
ASCIITOHEXMSG       14F
AS_INS              29D
A_REG               2CC
BEQ_INS             2BE
BGT_INS             2B6
BLE_INS             2BA
BRA_INS             2C2
BYTE                25D
CHECK_WORD          1654
CLEARDONE           10D4
CLEARSCREEN         10BE
CLEAR_REGISTERS     102A
CLOSE_PARAN         2D1
COMMA               2DC
CONT                1810
CONTINUEORNOTMSG    20F
CONTINUE_INSTRUCTION_LS_AS_RO  14E2
CONVERSION_LOOP     1B2E
CR                  D
CREATORS            1F
DASH                2E1
DATA                2E8
DATA_REG            1852
DATA_REG_SR         1988
DESTINATION         1848
DOLLAR              2EF
DONE                1B82
D_REG               2CA
EA_DEST_ADD         1352
EA_DEST_SUB_AND_OR  1434
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13AE
END_BRA_BCC         1676
END_MOVEM           1722
END_MOVEM_POSTINC   1B18
END_MOVEM_PREDEC    1A66
ENTER               1262
ENTER_PRESS_TRUE    1198
ERROR               1B72
ERRORMSG            11E
EXITMSG             245
FIX_MEM_ORDER_LONG  16F8
FIX_MEM_ORDER_WORD  16E8
FLUSHSCREEN         1174
FLUSHSCREENMSG      199
FLUSHSCREEN_INPUT   1186
GETENDADDRESS       109E
GETSTARTADDRESS     107E
HELPMSG             1D3
HEXTOASCIIMSG       12D
IMMEDIATE           1900
IMM_COMPLETE        193E
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             1232
JSR_INS             2A7
LEA_INS             2AC
LEFT                2C8
LETTERS_CAP         1B4E
LF                  A
LONG                255
LS_AS_RO_MEM        14F8
LS_AS_RO_REG        14DA
LS_INS              29A
L_IMM               195E
MEMSEARCH           10D6
MEMSEARCHLOOP       10EA
MEMSEARCH_DONE      1124
MEM_TO_REG          16CE
MENU                1066
MOVEA_INS           27B
MOVEM_CHECK_DONE    1748
MOVEM_CHECK_PRE     1742
MOVEM_CHECK_PRE_POST  172A
MOVEM_CONT          170E
MOVEM_DIRECTION     16A8
MOVEM_INS           275
MOVEM_LONG          16A0
MOVEM_POSTINC       1A68
MOVEM_PREDEC        19B8
MOVEQ_INS           26E
MOVE_A              12DE
MOVE_INS            269
MOVE_MOVEA          1926
MOVE_SIZE           17A2
MUL_DIV             1452
MUL_DIV_LONG        1474
M_SIZE              12E6
NEXT_ADD            139A
NEXT_BRA_BCC        1622
NEXT_LS_AS_RO       1526
NOP_INS             261
NOT_INS             2A3
NUMBERS             1B60
OPCODE_DECODE       119A
OPEN_PARAN          2CE
OR_INS              28F
OUT                 124E
POSTINC_CHECK_FIRST_A  1A9A
POSTINC_CHECK_FIRST_D  1AF0
POSTINC_FIRST_A     1AAA
POSTINC_FIRST_D     1B00
POSTINC_INC_LOOP_A  1A8E
POSTINC_INC_LOOP_D  1AE4
POSTINC_LOOP_A      1A84
POSTINC_LOOP_A_DONE  1ACA
POSTINC_LOOP_D      1ADA
POSTINC_SKIP_TO_D   1AD8
POST_INC            2D3
POST_INCREMENT      18A2
POUND               2DF
PREDEC_CHECK_FIRST_A  19E4
PREDEC_CHECK_FIRST_D  1A3E
PREDEC_FIRST_A      19F4
PREDEC_FIRST_D      1A4E
PREDEC_INC_LOOP_A   19D8
PREDEC_INC_LOOP_D   1A32
PREDEC_LOOP_A       19CE
PREDEC_LOOP_A_DONE  1A1A
PREDEC_LOOP_D       1A28
PREDEC_SKIP_TO_D    1A28
PRE_DEC             2D6
PRE_DECREMENT       18C2
PRINT               1250
PRINTLN             125A
PRINT_ADDQ          1592
PRINT_ADD_ADDA      130E
PRINT_AS            1790
PRINT_B             17C4
PRINT_BEQ           1602
PRINT_BGT           161A
PRINT_BLE           160E
PRINT_BRA           15F6
PRINT_BRA_BCC       15CC
PRINT_CORRECT_SHIFT_ROTATION  1770
PRINT_DIRECTION     174E
PRINT_INSTRUCTION   1402
PRINT_IT            179C
PRINT_JSR           1558
PRINT_L             17DC
PRINT_LEA           156E
PRINT_LEFT          1766
PRINT_LS            1798
PRINT_LS_AS_RO      147A
PRINT_MOVEM         167E
PRINT_MOVEQ         1280
PRINT_MOVE_MOVEA    12C4
PRINT_NOP           126C
PRINT_NOT           152E
PRINT_OR            13FE
PRINT_RTS           1276
PRINT_SUB           13E8
PRINT_SUB_AND_OR    13B6
PRINT_W             17D0
RETURN              2E5
RIGHT               2C6
RO_INS              2A0
RTS_INS             265
SCREENFLUSH_CHECK   116A
SIZE                17E8
SLASH               2E3
SPACE               2DA
START               1000
STARTINGMSG         0
SUB_INS             296
TAB                 9
WORD                259
W_IMM               1942
XN                  197C
