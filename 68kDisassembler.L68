00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 3:09:11 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to continue with the next set of instructions',0
000001CA= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
00000206= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
00000229= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000239                            27  
00000239                            28  START_ADDR_BUFFER  DS.B    256
00000339                            29  END_ADDR_BUFFER    DS.B    256
00000439                            30  
00000439                            31  *size
00000439= 2E 4C 20 00               32  long                DC.B    '.L ',0
0000043D= 2E 57 20 00               33  word                DC.B    '.W ',0
00000441= 2E 42 20 00               34  byte                DC.B    '.B ',0
00000445                            35  
00000445                            36  *instructions
00000445= 4E 4F 50 00               37  nop_ins             DC.B    'NOP',0
00000449= 52 54 53 00               38  rts_ins             DC.B    'RTS',0
0000044D= 4D 4F 56 45 00            39  move_ins            DC.B    'MOVE',0
00000452= 4D 4F 56 45 51 20 00      40  moveq_ins           DC.B    'MOVEQ ',0
00000459= 4D 4F 56 45 4D 00         41  movem_ins           DC.B    'MOVEM',0
0000045F= 4D 4F 56 45 41 00         42  movea_ins           DC.B    'MOVEA',0
00000465= 41 44 44 00               43  add_ins             DC.B    'ADD',0
00000469= 41 44 44 41 00            44  adda_ins            DC.B    'ADDA',0
0000046E= 41 44 44 51 00            45  addq_ins            DC.B    'ADDQ',0
00000473= 4F 52 00                  46  or_ins              DC.B    'OR',0
00000476= 41 4E 44 00               47  and_ins             DC.B    'AND',0
0000047A= 53 55 42 00               48  sub_ins             DC.B    'SUB',0
0000047E= 4C 53 00                  49  ls_ins              DC.B    'LS',0
00000481= 41 53 00                  50  as_ins              DC.B    'AS',0
00000484= 52 4F 00                  51  ro_ins              DC.B    'RO',0
00000487= 4E 4F 54 00               52  not_ins             DC.B    'NOT',0
0000048B= 4A 53 52 20 00            53  jsr_ins             DC.B    'JSR ',0
00000490= 4C 45 41 20 00            54  lea_ins             DC.B    'LEA ',0
00000495= 41 44 44 51 00            55  andq_ins            DC.B    'ADDQ',0
0000049A= 42 47 54 00               56  bgt_ins             DC.B    'BGT',0
0000049E= 42 4C 45 00               57  ble_ins             DC.B    'BLE',0
000004A2= 42 45 51 00               58  beq_ins             DC.B    'BEQ',0
000004A6= 42 52 41 00               59  bra_ins             DC.B    'BRA',0
000004AA                            60  
000004AA                            61  *direction
000004AA= 52 00                     62  right               DC.B    'R',0
000004AC= 4C 00                     63  left                DC.B    'L',0
000004AE                            64  
000004AE                            65  *EA
000004AE= 44 00                     66  D_reg               DC.B    'D',0
000004B0= 41 00                     67  A_reg               DC.B    'A',0
000004B2= 28 41 00                  68  open_paran          DC.B    '(A',0
000004B5= 29 00                     69  close_paran         DC.B    ')',0
000004B7= 29 2B 00                  70  post_inc            DC.B    ')+',0
000004BA= 2D 28 41 00               71  pre_dec             DC.B    '-(A',0
000004BE                            72  
000004BE                            73  *extra
000004BE= 20 00                     74  space               DC.B    ' ',0
000004C0= 2C 20 00                  75  comma               DC.B    ', ',0
000004C3= 23 00                     76  pound               DC.B    '#',0
000004C5= 2D 00                     77  dash                DC.B    '-',0
000004C7= 2F 00                     78  slash               DC.B    '/',0
000004C9  =00000009                 79  tab                 EQU     $9
000004C9= 0D 0A 00                  80  return              DC.B    CR,LF,0
000004CC= 44 41 54 41 20 24 00      81  data                DC.B    'DATA $',0
000004D3= 24 00                     82  dollar              DC.B    '$',0
00001000                            83      ORG    $1000    *Start at address $1000
00001000                            84  START:                  ; first instruction of program
00001000                            85  
00001000                            86  *---------- Test value, will remove in final build ----------*
00001000                            87  
00001000                            88  *   Move.W #$4E75,$00009234 *RTS
00001000                            89  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            90  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            91  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            92  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            93  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            94  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            95  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            96  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            97  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            98  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            99  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                           100  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           101  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           102  *   MOVE.W #$000C,$00009250
00001000                           103  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           104  *   MOVE.L #$12345678,$00009254
00001000                           105  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           106  *   MOVE.W #$0012,$0000925A
00001000                           107  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           108  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           109  *   MOVE.L #$00009208,$00009260
00001000                           110  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           111  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           112  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           113  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           114  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           115  *    MOVE.W #$FE7A,$0000926E
00001000                           116  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           117  *    MOVE.W #$FE60,$00009272
00001000                           118  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           119  *    MOVE.L #$00009208,$000009276
00001000                           120  *    MOVE.W #$48A1,$0000927A
00001000                           121  *    MOVE.W #$011F,$0000927C
00001000                           122  *    MOVE.W #$4C91,$0000927E
00001000                           123  *    MOVE.W #$FE00,$00009280
00001000                           124  *   MOVE.W #$C2BC, $00009000
00001000                           125  *   MOVE.L #$12345678, $00009002
00001000  33FC 82F9 00009000       126      MOVE.W #$82F9 , $00009000
00001008  23FC 12345678 00009002   127      MOVE.L #$12345678, $00009002 
00001012  33FC 9441 00009006       128      MOVE.W #$9441, $00009006
0000101A  33FC C27C 00009008       129      Move.w #$C27C, $00009008
00001022  33FC 1234 0000900A       130      move.w #$1234, $0000900A
0000102A                           131  *   MOVE.L #$12345678, $00009002
0000102A                           132  *---------- END Test ----------*
0000102A                           133  
0000102A                           134  
0000102A                           135  
0000102A                           136  *---------- Beginning Messages ----------*
0000102A                           137      
0000102A  103C 000E                138      move.b      #14,D0
0000102E  43F8 0000                139      lea         StartingMsg,A1 
00001032  4E4F                     140      trap        #15
00001034                           141      
00001034  103C 000E                142      move.b      #14,D0
00001038  43F8 001F                143      lea         Creators,A1
0000103C  4E4F                     144      trap        #15
0000103E                           145      
0000103E  4EB9 00001090            146      jsr         MENU
00001044                           147      
00001044                           148      
00001044                           149  * ---------- END OF PROGRAM -------------*
00001044                           150  
00001044  103C 000E                151      move.b      #14,D0
00001048  43F8 0229                152      lea         ExitMsg,A1 
0000104C  4E4F                     153      trap        #15
0000104E                           154      
0000104E  103C 0009                155      move.b      #9,D0
00001052  4E4F                     156      trap        #15
00001054                           157  * ---------------------------------------*
00001054                           158      
00001054                           159  *-- End of Opening and Ending Messages --*
00001054                           160  
00001054                           161  *--------- Start of I/O Section ---------*
00001054                           162  
00001054                           163  Clear_Registers:
00001054  4280                     164      clr.l     D0
00001056  4281                     165      clr.l     D1
00001058  4282                     166      clr.l     D2
0000105A  4283                     167      clr.l     D3
0000105C  4284                     168      clr.l     D4
0000105E  4285                     169      clr.l     D5
00001060  4286                     170      clr.l     D6
00001062  4287                     171      clr.l     D7
00001064                           172      
00001064  207C 00000000            173      movea.l   #0,A0
0000106A  227C 00000000            174      movea.l   #0,A1
00001070  247C 00000000            175      movea.l   #0,A2
00001076  267C 00000000            176      movea.l   #0,A3
0000107C  287C 00000000            177      movea.l   #0,A4
00001082  2A7C 00000000            178      movea.l   #0,A5
00001088  2C7C 00000000            179      movea.l   #0,A6
0000108E  4E75                     180      rts
00001090                           181  
00001090                           182  MENU:
00001090  4EB8 1054                183      jsr         Clear_Registers
00001094  4EB9 000010B4            184      jsr         GetStartAddress
0000109A  4EB9 000010CE            185      jsr         GetEndAddress
000010A0  4EB9 000010E8            186      jsr         CheckAddress
000010A6                           187      
000010A6  4EB9 0000111C            188      jsr         MemSearch
000010AC  4EB9 00001176            189      jsr         TerminateOrCont
000010B2  4E75                     190      rts
000010B4                           191      
000010B4                           192  GetStartAddress:
000010B4                           193      
000010B4  103C 000E                194      move.b      #14, D0         *Display input message
000010B8  43F8 004E                195      lea         InputMsg1,A1
000010BC  4E4F                     196      trap        #15
000010BE                           197      
000010BE  103C 0002                198      move.b      #2,D0
000010C2  4E4F                     199      trap        #15
000010C4                           200          
000010C4  4EB9 00001B12            201      jsr ASCIItoHex              *conversion to Hex
000010CA                           202      * Address Located in D6
000010CA  2846                     203      movea.l     D6,A4           *move into address register 4
000010CC  4E75                     204      rts
000010CE                           205      
000010CE                           206      
000010CE                           207  GetEndAddress:
000010CE  103C 000E                208      move.b      #14,D0          *Display input message
000010D2  43F8 008F                209      lea         InputMsg2,A1
000010D6  4E4F                     210      trap        #15
000010D8                           211      
000010D8  103C 0002                212      move.b      #2,D0
000010DC  4E4F                     213      trap        #15
000010DE                           214      
000010DE  4EB9 00001B12            215      jsr         ASCIItoHex      *conversion to hex
000010E4                           216      * Address Located in D6 (overwrite)
000010E4  2A46                     217      movea.l     D6,A5           *move into address register 5
000010E6  4E75                     218      rts
000010E8                           219      
000010E8                           220  CheckAddress:
000010E8  BBCC                     221      cmp.l       A4,A5
000010EA  67A4                     222      beq         Menu
000010EC                           223  
000010EC                           224  
000010EC                           225  
000010EC                           226  
000010EC                           227  ClearScreen:
000010EC  43F8 04C9                228      lea     return,A1
000010F0  103C 000E                229      move.b  #14,D0
000010F4  4E4F                     230      trap    #15
000010F6                           231      
000010F6                           232      *move.b  #9,D0
000010F6                           233      *trap    #15
000010F6                           234      
000010F6  B27C 0028                235      cmp.w   #40,D1
000010FA  6700 001E                236      beq     ClearDone
000010FE  5241                     237      add.w   #1,D1
00001100  60EA                     238      bra     ClearScreen
00001102                           239  
00001102                           240  
00001102                           241  ClearScreen_40:
00001102  43F8 04C9                242      lea     return,A1
00001106  103C 000E                243      move.b  #14,D0
0000110A  4E4F                     244      trap    #15
0000110C                           245      
0000110C  B2BC 00000028            246      cmp.l   #40,D1
00001112  6700 0006                247      beq     ClearDone
00001116  5281                     248      add.l   #1,D1
00001118  60E8                     249      bra     ClearScreen_40
0000111A                           250      
0000111A                           251  ClearDone:
0000111A  4E75                     252      rts
0000111C                           253      
0000111C                           254  MemSearch:
0000111C  7200                     255      move.l      #0,D1
0000111E  4EB8 10EC                256      jsr         ClearScreen
00001122                           257      * Set up instruction counter and place onto stack
00001122  303C 0000                258      move.w      #0,D0
00001126  3F00                     259      move.w      D0,-(SP)
00001128                           260      
00001128  4EB9 00001130            261      jsr MemSearchLoop
0000112E  4E75                     262      rts
00001130                           263      
00001130                           264  MemSearchLoop:
00001130                           265      
00001130                           266      * Check if we reached the end address
00001130  BBCC                     267      cmp.l       A4,A5
00001132  6700 0036                268      beq         MemSearch_Done
00001136                           269      
00001136                           270      * Get data from memory
00001136  4241                     271      CLR D1
00001138  3414                     272      move.w     (A4),D2
0000113A  3602                     273      move.w      D2, D3  mutable copy in D3
0000113C                           274      * OPCODE Word Located in D2, mutable copy in D3
0000113C  220C                     275      MOVE.L      A4, D1
0000113E  143C 0010                276      MOVE.B      #16, D2
00001142  103C 000F                277      MOVE.B      #15, D0     print address of instruction
00001146  4E4F                     278      TRAP        #15
00001148  3403                     279      MOVE.W      D3,D2
0000114A  43F8 04BE                280      LEA         space,A1
0000114E  4EB9 0000126C            281      JSR         print
00001154  4EB9 000011B6            282      jsr         OPCODE_DECODE    
0000115A                           283      
0000115A  544C                     284      adda.w      #2,A4
0000115C                           285      
0000115C                           286      * Call back counter from the stack
0000115C  301F                     287      move.w      (SP)+,D0
0000115E  5200                     288      add.b       #1,D0
00001160  4EB9 00001186            289      jsr         ScreenFlush_Check
00001166  3F00                     290      move.w      D0,-(SP)
00001168                           291      
00001168  60C6                     292      bra         MemSearchLoop
0000116A                           293      
0000116A                           294      
0000116A                           295  MemSearch_Done:
0000116A  103C 000E                296      move.b      #14,D0
0000116E  43F8 0173                297      lea         EndOfMemLoop,A1 
00001172  4E4F                     298      trap        #15
00001174  4E75                     299      rts
00001176                           300      
00001176                           301  TerminateOrCont:
00001176  4EB8 1054                302      jsr         Clear_Registers
0000117A  103C 000E                303      move.b      #14,D0
0000117E  43F8 0206                304      lea         ContinueOrNotMsg,A1 
00001182  4E4F                     305      trap        #15
00001184                           306      
00001184  4E75                     307      rts
00001186                           308  
00001186                           309  ScreenFlush_Check:
00001186  B03C 001F                310      cmp.b       #31,D0 * 31
0000118A  6700 0004                311      beq         FlushScreen
0000118E  4E75                     312      rts 
00001190                           313  
00001190                           314  FlushScreen:
00001190  43F8 0190                315      lea         FlushScreenMsg,A1
00001194  103C 000E                316      move.b      #14,D0
00001198  4E4F                     317      trap        #15
0000119A  4EB9 000011A2            318      jsr         FlushScreen_Input
000011A0                           319      *move.l      #0,D1
000011A0                           320      *jsr         ClearScreen_40
000011A0  4E75                     321      rts
000011A2                           322  
000011A2                           323  FlushScreen_Input:
000011A2                           324  
000011A2  4241                     325      clr     D1
000011A4                           326  
000011A4  103C 0005                327      move.b  #5,D0
000011A8  4E4F                     328      trap    #15
000011AA                           329      
000011AA  B23C 000D                330      cmp.b   #13,D1
000011AE  6700 0004                331      beq     Enter_Press_True    
000011B2                           332      
000011B2  60EE                     333      bra     FlushScreen_Input
000011B4                           334      
000011B4                           335  Enter_Press_True:
000011B4  4E75                     336      rts
000011B6                           337      
000011B6                           338  
000011B6                           339      
000011B6                           340  
000011B6                           341  * -------- Start of Opcode Section -------*    
000011B6                           342  
000011B6                           343  OPCODE_DECODE:
000011B6                           344      * Begin OPCODE Decoding here
000011B6                           345      * Check first four bits and begin
000011B6                           346      * if-branch breakdown
000011B6  4284                     347      CLR.L D4
000011B8  4285                     348      CLR.L D5
000011BA  4286                     349      CLR.L D6
000011BC  4287                     350      CLR.L D7
000011BE                           351      
000011BE  B47C 4E71                352      CMP.W #$4E71, D2        
000011C2  6700 00C4                353      BEQ print_nop           *check if value is NOP
000011C6                           354      
000011C6  B47C 4E75                355      CMP.W #$4E75, D2        
000011CA  6700 00C6                356      BEQ print_rts           *check if value is RTS
000011CE                           357      
000011CE                           358      * Mask out only the first 4 bits
000011CE  C67C F000                359      AND.W #$F000,D3
000011D2                           360      
000011D2  B67C 9000                361      CMP.W #$9000,D3
000011D6  6700 01FA                362      BEQ print_sub_and_or    *check if value is SUB
000011DA                           363      
000011DA  B67C 6000                364      CMP.W #$6000,D3
000011DE  6700 0408                365      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011E2                           366      
000011E2  B67C 8000                367      CMP.W #$8000, D3
000011E6  6700 01EA                368      BEQ print_sub_and_or    *check if value is OR
000011EA                           369  
000011EA  B67C C000                370      CMP.W #$C000,D3
000011EE  6700 01E2                371      BEQ print_sub_and_or    *check if value is AND
000011F2                           372      
000011F2  B67C D000                373      CMP.W #$D000,D3
000011F6  6700 0132                374      BEQ print_add_adda      *check if value is ADD or ADDA
000011FA                           375      
000011FA  B67C E000                376      CMP.W #$E000,D3
000011FE  6700 0296                377      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001202                           378      
00001202  B67C 7000                379      CMP.W #$7000,D3
00001206  6700 0094                380      BEQ print_moveq     *check if value is MOVEQ
0000120A                           381      
0000120A  B47C 1000                382      CMP.W #$1000,D2
0000120E  6D00 003E                383      BLT invalid
00001212  B47C 4000                384      CMP.W #$4000,D2
00001216  6D00 00C8                385      BLT print_move_movea    *check if value is MOVE or MOVEA
0000121A                           386      
0000121A                           387      * Mask out only the first 8 bits
0000121A  3602                     388      MOVE.W D2, D3
0000121C  C67C FF00                389      AND.W #$FF00,D3
00001220                           390      
00001220  B67C 4600                391      CMP.W #$4600,D3
00001224  6700 0324                392      BEQ print_not           *check if value is NOT
00001228                           393      
00001228  B67C 4E00                394      CMP.W #$4E00,D3
0000122C  6700 0346                395      BEQ print_jsr           *check if value is JSR
00001230                           396      
00001230                           397      * Mask out only the first 4 bits and the 8th bit
00001230  3602                     398      MOVE.W D2,D3
00001232  C67C F100                399      AND.W #$F100, D3
00001236                           400      
00001236  B67C 4000                401      CMP.W #$4000, D3
0000123A  6700 045E                402      BEQ print_movem         *check if value is MOVEM
0000123E                           403      
0000123E  B67C 4100                404      CMP.W #$4100, D3
00001242  6700 0346                405      BEQ print_lea           *check if value is LEA
00001246                           406      
00001246  B67C 5000                407      CMP.W #$5000,D3
0000124A  6700 0362                408      BEQ print_addq          *check if value is ANDQ     
0000124E                           409      
0000124E                           410      
0000124E                           411  invalid 
0000124E  43F8 04CC                412      LEA data, A1
00001252  4EB9 0000126C            413      JSR print
00001258  2202                     414      MOVE.L D2, D1
0000125A  143C 0010                415      MOVE.B #16, D2
0000125E  103C 000F                416      MOVE.B  #15, D0     
00001262  4E4F                     417      TRAP #15
00001264  4EB9 0000127E            418      JSR enter
0000126A  4E75                     419  out rts
0000126C                           420  
0000126C                           421      
0000126C                           422  * -------- End of Opcode Section --------*   
0000126C                           423  
0000126C                           424  * --------- Print Instructions ----------*
0000126C                           425  
0000126C                           426  
0000126C                           427  print:
0000126C  4240                     428      CLR D0 
0000126E  103C 000E                429      MOVE.B #14,D0
00001272  4E4F                     430      TRAP #15
00001274  4E75                     431      RTS
00001276                           432  
00001276                           433  println:
00001276  103C 000D                434      MOVE.B #13, D0
0000127A  4E4F                     435      TRAP #15
0000127C  4E75                     436      RTS
0000127E                           437      
0000127E                           438  enter: 
0000127E  43F8 04C9                439      LEA return, A1
00001282  4EB8 126C                440      JSR print
00001286  4E75                     441      RTS
00001288                           442      
00001288                           443  print_nop
00001288  43F8 0445                444      LEA nop_ins, A1
0000128C  4EB8 1276                445      JSR println
00001290  60D8                     446      BRA out
00001292                           447  
00001292                           448  print_rts
00001292  43F8 0449                449      LEA rts_ins, A1
00001296  4EB8 1276                450      JSR println
0000129A  60CE                     451      BRA out
0000129C                           452      
0000129C                           453  print_moveq
0000129C  43F8 0452                454      lea moveq_ins, A1   *print MOVEQ
000012A0  4EB8 126C                455      jsr print
000012A4  3602                     456      move.w  D2,D3
000012A6  C67C 00FF                457      and.w   #$00FF,D3   * Figure out the immediate address value
000012AA  43F8 04C3                458      lea pound,A1        *print '#'
000012AE  4EB8 126C                459      jsr print
000012B2  43F8 04D3                460      LEA dollar, A1
000012B6  4EB8 126C                461      JSR print
000012BA  3203                     462      move.w  D3,D1
000012BC  3602                     463      MOVE.W D2,D3
000012BE  343C 0010                464      MOVE.W #16, D2
000012C2  103C 000F                465      move.b  #15,D0
000012C6  4E4F                     466      trap    #15         *print immediate address value
000012C8  43F8 04C0                467      lea comma,A1        *print comma
000012CC  4EB8 126C                468      jsr print
000012D0  3403                     469      MOVE.W D3, D2
000012D2  3A02                     470      MOVE.W D2, D5
000012D4  4EB9 00001940            471      JSR data_reg_sr     *figure out data address
000012DA  4EB8 127E                472      jsr enter           *print out enter
000012DE  608A                     473      bra out
000012E0                           474      
000012E0                           475  print_move_movea
000012E0  3602                     476      MOVE.W D2, D3       
000012E2  C67C 01C0                477      AND.W #$01C0, D3
000012E6  B67C 0040                478      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000012EA  6700 000E                479      BEQ move_a
000012EE  43F8 044D                480      LEA move_ins, A1 *print Instruction 
000012F2  4EB8 126C                481      JSR print
000012F6  6000 000A                482      BRA m_size
000012FA                           483  move_a          *if instruction is MOVEA
000012FA  43F8 045F                484      LEA movea_ins, A1
000012FE  4EB8 126C                485      JSR print
00001302                           486  m_size              *determine instruction size
00001302  4EB9 0000175A            487      JSR move_size
00001308  4EB9 000017BC            488      JSR addr        *determine the source address
0000130E  43F8 04C0                489      LEA comma, A1   *print comma
00001312  4EB8 126C                490      JSR print
00001316  4207                     491      CLR.B D7
00001318  1E3C 0001                492      MOVE.B #1, D7   *determine destination address
0000131C  4EB9 000017BC            493      JSR addr
00001322  4EB8 127E                494      JSR enter       *print enter
00001326  6000 FF42                495      BRA out
0000132A                           496      
0000132A                           497  print_add_adda
0000132A  3602                     498      MOVE.W D2, D3   
0000132C  C63C 00C0                499      AND.B #$C0, D3
00001330  B63C 00C0                500      CMP.B #$C0, D3      *determine if ADD or ADDA
00001334  6700 0052                501      BEQ add_a
00001338                           502      *if just ADD then print instruction
00001338  43F8 0465                503      LEA add_ins, A1
0000133C  4EB8 126C                504      JSR print
00001340                           505      *print instruction size for ADD
00001340  4EB9 000017A0            506      JSR size
00001346                           507      *determine direction of ADD, Dn -> EA or EA -> Dn
00001346  3602                     508      MOVE.W D2,D3
00001348  C67C 0100                509      AND.W #$0100, D3
0000134C  B67C 0100                510      CMP.W #$0100, D3
00001350  6700 001C                511      BEQ ea_dest_add 
00001354  4EB9 000017BC            512      JSR addr            *if Direction bit is 0
0000135A  43F8 04C0                513      LEA comma, A1
0000135E  4EB8 126C                514      JSR print
00001362  3A02                     515      MOVE.W D2,D5
00001364  4EB9 00001940            516      JSR data_reg_sr
0000136A  6000 005E                517      BRA end_add
0000136E                           518  ea_dest_add             *if Direction bit is 1
0000136E  3A02                     519      MOVE.W D2,D5
00001370  4EB9 00001940            520      JSR data_reg_sr
00001376  43F8 04C0                521      LEA comma, A1
0000137A  4EB8 126C                522      JSR print
0000137E  4EB9 000017BC            523      JSR addr
00001384  6000 0044                524      BRA end_add
00001388                           525  add_a                   *if instruction is ADDA
00001388  43F8 0469                526      LEA adda_ins, A1
0000138C  4EB8 126C                527      JSR print
00001390                           528      *print instruction size for ADDA (either W or L)
00001390  3602                     529      MOVE.W D2,D3
00001392  C67C 0100                530      AND.W #$0100, D3
00001396  B67C 0100                531      CMP.W #$0100, D3
0000139A  6700 000E                532      BEQ adda_size
0000139E  43F8 043D                533      LEA word, A1
000013A2  4EB8 126C                534      JSR print
000013A6  6000 000E                535      BRA next_add
000013AA                           536  adda_size
000013AA  43F8 0439                537      LEA long,A1
000013AE  4EB8 126C                538      JSR print
000013B2  183C 0080                539      MOVE.B #$80, D4
000013B6                           540  next_add                *print effective address for ADDA
000013B6  4EB9 000017BC            541      JSR addr            
000013BC  43F8 04C0                542      LEA comma, A1
000013C0  4EB8 126C                543      JSR print
000013C4  4EB9 00001958            544      JSR add_reg_sr
000013CA                           545  end_add                 *complete instruction printing by printing enter
000013CA  4EB8 127E                546      JSR enter
000013CE  6000 FE9A                547      BRA out
000013D2                           548  
000013D2                           549  print_sub_and_or
000013D2                           550      *determine if instruction is SUB, AND, or OR.
000013D2  3602                     551      MOVE.W D2, D3
000013D4  C67C F0C0                552      AND.W #$F0C0, D3
000013D8  B67C C0C0                553      CMP.W #$C0C0, D3
000013DC  6700 0090                554      BEQ mul_div
000013E0  B67C 80C0                555      CMP.W #$80C0, D3
000013E4  6700 0088                556      BEQ mul_div
000013E8  C67C F000                557      AND.W #$F000,D3
000013EC  B67C 8000                558      CMP.W #$8000, D3
000013F0  6700 0028                559      BEQ print_or
000013F4  B67C 9000                560      CMP.W #$9000, D3
000013F8  6700 000A                561      BEQ print_sub
000013FC  43F8 0476                562      LEA and_ins, A1
00001400  6000 001C                563      BRA print_instruction
00001404                           564  print_sub
00001404  3602                     565      MOVE.W D2, D3
00001406  C67C 00C0                566      AND.W #$00C0, D3
0000140A  B63C 00C0                567      CMP.B #$C0, D3
0000140E  6700 FE3E                568      BEQ invalid
00001412  43F8 047A                569      LEA sub_ins, A1
00001416  6000 0006                570      BRA print_instruction
0000141A                           571  print_or
0000141A  43F8 0473                572      LEA or_ins, A1
0000141E                           573  print_instruction       *print correct instruction
0000141E  4EB8 126C                574      JSR print
00001422  4EB9 000017A0            575      JSR size            *print instruction size
00001428  3602                     576      MOVE.W D2,D3
0000142A                           577  *determine direction of ADD, Dn -> EA or EA -> Dn   
0000142A  C67C 0100                578      AND.W #$0100, D3
0000142E  B67C 0100                579      CMP.W #$0100, D3
00001432  6700 001C                580      BEQ ea_dest_sub_and_or
00001436  4EB9 000017BC            581      JSR addr            *if Direction bit is 0
0000143C  43F8 04C0                582      LEA comma, A1
00001440  4EB8 126C                583      JSR print
00001444  3A02                     584      MOVE.W D2,D5
00001446  4EB9 00001940            585      JSR data_reg_sr
0000144C  6000 FF7C                586      BRA end_add
00001450                           587  ea_dest_sub_and_or      *if Direction bit is 1
00001450  3A02                     588      MOVE.W D2,D5
00001452  4EB9 00001940            589      JSR data_reg_sr
00001458  43F8 04C0                590      LEA comma, A1
0000145C  4EB8 126C                591      JSR print
00001460  4EB9 000017BC            592      JSR addr
00001466                           593      *complete instruction printing by printing enter
00001466  4EB8 127E                594      JSR enter
0000146A  6000 FDFE                595      BRA out
0000146E                           596      
0000146E                           597  mul_div             *deal with MULU and DIVU cases
0000146E  4283                     598      CLR.L D3
00001470  3602                     599      MOVE.W D2,D3
00001472  C67C 00FF                600      AND.W #$00FF, D3
00001476  B6BC 000000F8            601      CMP.L #$00F8, D3
0000147C  6D00 FDD0                602      BLT invalid
00001480  B6BC 000000F9            603      CMP.L #$00F9, D3
00001486  6700 0008                604      BEQ mul_div_long
0000148A  544C                     605      ADDA.W #2,A4
0000148C  6000 FDC0                606      BRA invalid
00001490                           607  mul_div_long
00001490  584C                     608      ADDA.W #4,A4
00001492  6000 FDBA                609      BRA invalid
00001496                           610      
00001496                           611  print_ls_as_ro
00001496                           612      *figure out if shift or rotation are memory or register based               
00001496  3602                     613      MOVE.W D2, D3
00001498  C63C 00C0                614      AND.B #$C0, D3
0000149C  B63C 00C0                615      CMP.B #$C0, D3
000014A0  6700 0072                616      BEQ ls_as_ro_mem
000014A4  3602                     617      MOVE.W D2, D3
000014A6  E60B                     618      LSR.B #3, D3
000014A8                           619      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000014A8  4EB9 00001728            620      JSR print_correct_shift_rotation
000014AE  4EB9 00001706            621      JSR print_direction     *print direction
000014B4  4EB9 000017A0            622      JSR size                *print size
000014BA  3602                     623      MOVE.W D2, D3
000014BC  C63C 0020                624      AND.B #$20,D3
000014C0  B63C 0020                625      CMP.B #$20, D3
000014C4                           626      *determine if instruction is using immediate address or register
000014C4  6700 0030                627      BEQ ls_as_ro_reg     
000014C8  43F8 04C3                628      LEA pound, A1        *if immediate address print '#'
000014CC  4EB8 126C                629      JSR print
000014D0                           630      *print immediate address rotation value
000014D0  3C02                     631      MOVE.W D2,D6
000014D2  EF5E                     632      ROL.W #7,D6
000014D4  CC7C 0007                633      AND.W #$0007, D6
000014D8  43F8 04D3                634      LEA dollar, A1
000014DC  4EB8 126C                635      JSR print
000014E0  4281                     636      CLR.L D1
000014E2  3206                     637      MOVE.W D6, D1
000014E4  3602                     638      MOVE.W D2, D3
000014E6  143C 0010                639      MOVE.B #16, D2
000014EA  103C 000F                640      MOVE.B #15, D0
000014EE  4E4F                     641      TRAP #15
000014F0  3403                     642      MOVE.W D3,D2
000014F2  6000 000A                643      BRA continue_instruction_ls_as_ro
000014F6                           644  ls_as_ro_reg            *if instruction is using register to shift values in another register
000014F6  3A02                     645      MOVE.W D2,D5
000014F8  4EB9 00001940            646      JSR data_reg_sr
000014FE                           647  continue_instruction_ls_as_ro *complete instrcuction
000014FE  43F8 04C0                648      LEA comma, A1       *print comma
00001502  4EB8 126C                649      JSR print
00001506  3A02                     650      MOVE.W D2,D5
00001508  EE5D                     651      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
0000150A  4EB9 00001940            652      JSR data_reg_sr     *determine destination data register to perform instruction on
00001510  6000 0030                653      BRA next_ls_as_ro   *finish printing instruction
00001514                           654  ls_as_ro_mem            *check if immediate address is being shifted or rotated
00001514  3602                     655      MOVE.W D2, D3
00001516  C63C 003F                656      AND.B #$3F, D3
0000151A  B63C 003C                657      CMP.B #$3C, D3
0000151E  6700 FD2E                658      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001522                           659      *if not immediate adress print normally 
00001522  3602                     660      MOVE.W D2, D3
00001524  EF5B                     661      ROL.W #7, D3    
00001526  4EB9 00001728            662      JSR print_correct_shift_rotation
0000152C  3602                     663      MOVE.W D2,D3
0000152E  4EB9 00001706            664      JSR print_direction
00001534  43F8 043D                665      LEA word, A1
00001538  4EB8 126C                666      JSR print
0000153C  4EB9 000017BC            667      JSR addr
00001542                           668  next_ls_as_ro
00001542  4EB8 127E                669      JSR enter
00001546  6000 FD22                670      BRA out
0000154A                           671      
0000154A                           672  print_not
0000154A  43F8 0487                673      LEA not_ins, A1 *print instruction
0000154E  4EB8 126C                674      JSR print
00001552  4EB9 000017A0            675      JSR size
00001558  3602                     676      MOVE.W D2, D3
0000155A  C63C 003F                677      AND.B #$3F, D3
0000155E  B63C 003C                678      CMP.B #$3C, D3
00001562  6700 FCEA                679      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
00001566  4EB9 000017BC            680      JSR addr
0000156C  4EB8 127E                681      JSR enter
00001570  6000 FCF8                682      BRA out
00001574                           683  
00001574                           684  print_jsr
00001574  43F8 048B                685      LEA jsr_ins, A1 *print instruction
00001578  4EB8 126C                686      JSR print
0000157C  4EB9 000017BC            687      JSR addr    *print address
00001582  4EB8 127E                688      JSR enter   *print enter (next line)
00001586  6000 FCE2                689      BRA out
0000158A                           690  
0000158A                           691  print_lea
0000158A  43F8 0490                692      LEA lea_ins, A1 *print instruction
0000158E  4EB8 126C                693      JSR print   
00001592  4EB9 000017BC            694      JSR addr    *print address
00001598  43F8 04C0                695      LEA comma, A1   *print comma
0000159C  4EB8 126C                696      JSR print
000015A0  4EB9 00001958            697      JSR add_reg_sr *print destination address register
000015A6  4EB8 127E                698      JSR enter
000015AA  6000 FCBE                699      BRA out
000015AE                           700  
000015AE                           701  print_addq
000015AE  43F8 046E                702      LEA addq_ins, A1    *print instruction
000015B2  4EB8 126C                703      JSR print
000015B6  4EB9 000017A0            704      JSR size            *print instruction size
000015BC  43F8 04C3                705      LEA pound, A1
000015C0  4EB8 126C                706      JSR print           *print '#' for immediate addressing
000015C4  3C02                     707      MOVE.W D2,D6
000015C6  EF5E                     708      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015C8  CC7C 0007                709      AND.W #$0007, D6
000015CC  4EB9 00001934            710      JSR Xn
000015D2  43F8 04C0                711      LEA comma, A1       *print comma
000015D6  4EB8 126C                712      JSR print
000015DA  4EB9 000017BC            713      JSR addr            *print destination address
000015E0  4EB8 127E                714      JSR enter
000015E4  6000 FC84                715      BRA out
000015E8                           716  
000015E8                           717  print_bra_bcc           *needs comments
000015E8  3602                     718      MOVE.W D2,D3
000015EA  C67C 0F00                719      AND.W #$0F00, D3
000015EE  B67C 0000                720      CMP.W #$0000, D3
000015F2  6700 001E                721      BEQ print_bra
000015F6  B67C 0700                722      CMP.W #$0700, D3
000015FA  6700 0022                723      BEQ print_beq
000015FE  B67C 0E00                724      CMP.W #$0E00, D3
00001602  6700 0032                725      BEQ print_bgt
00001606  B67C 0F00                726      CMP.W #$0F00, D3
0000160A  6700 001E                727      BEQ print_ble
0000160E  6000 FC3E                728      BRA invalid
00001612                           729  print_bra
00001612  43F8 04A6                730      LEA bra_ins, A1
00001616  4EB8 126C                731      JSR print
0000161A  6000 0022                732      BRA next_bra_bcc
0000161E                           733  print_beq
0000161E  43F8 04A2                734      LEA beq_ins, A1
00001622  4EB8 126C                735      JSR print
00001626  6000 0016                736      BRA next_bra_bcc
0000162A                           737  print_ble
0000162A  43F8 049E                738      LEA ble_ins, A1
0000162E  4EB8 126C                739      JSR print
00001632  6000 000A                740      BRA next_bra_bcc
00001636                           741  print_bgt
00001636  43F8 049A                742      LEA bgt_ins, A1
0000163A  4EB8 126C                743      JSR print
0000163E                           744  next_bra_bcc
0000163E  3602                     745      MOVE.W D2, D3
00001640  C67C 00FF                746      AND.W #$00FF, D3
00001644  B67C 0000                747      CMP.W #$0000, D3
00001648  6700 0026                748      BEQ check_word
0000164C  43F8 0441                749      LEA byte, A1
00001650  4EB8 126C                750      JSR print
00001654  43F8 04D3                751      LEA dollar, A1
00001658  4EB8 126C                752      JSR print
0000165C  3203                     753      MOVE.W D3, D1
0000165E  3602                     754      MOVE.W D2, D3
00001660  343C 0010                755      MOVE.W #16, D2
00001664  303C 000F                756      MOVE.W #15,D0
00001668  4E4F                     757      trap #15            *print immediate address value
0000166A  3403                     758      MOVE.W D3, D2
0000166C  6000 0024                759      BRA end_bra_bcc
00001670                           760  check_word
00001670  43F8 043D                761      LEA word, A1
00001674  4EB8 126C                762      JSR print
00001678  43F8 04D3                763      LEA dollar, A1
0000167C  4EB8 126C                764      JSR print
00001680  544C                     765      ADDA.W #2,A4        *update current address
00001682  3214                     766      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001684  3602                     767      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001686  343C 0010                768      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000168A  103C 000F                769      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000168E  4E4F                     770      TRAP #15
00001690  3403                     771      MOVE.W D3,D2        *copy opcode back to register D2
00001692                           772  end_bra_bcc
00001692  4EB8 127E                773      JSR enter
00001696  6000 FBD2                774      BRA out
0000169A                           775  
0000169A                           776  print_movem         *needs comments
0000169A  43F8 0459                777      LEA movem_ins, A1
0000169E  4EB8 126C                778      JSR print
000016A2  3602                     779      MOVE.W D2,D3
000016A4  C67C 0040                780      AND.W #$0040,D3
000016A8  B67C 0040                781      CMP.W #$0040,D3
000016AC  6700 000E                782      BEQ movem_long
000016B0  43F8 043D                783      LEA word, A1
000016B4  4EB8 126C                784      JSR print
000016B8  6000 000A                785      BRA movem_direction
000016BC                           786  movem_long
000016BC  43F8 0439                787      LEA long, A1
000016C0  4EB8 126C                788      JSR print
000016C4                           789  movem_direction
000016C4  3602                     790      MOVE.W D2,D3
000016C6  C67C 0400                791      AND.W #$0400,D3
000016CA  B67C 0400                792      CMP.W #$0400,D3
000016CE  6700 001A                793      BEQ mem_to_reg
000016D2  4EB9 00001970            794      JSR movem_predec
000016D8  43F8 04C0                795      LEA comma, A1
000016DC  4EB8 126C                796      JSR print
000016E0  4EB9 000017BC            797      JSR addr
000016E6  6000 0016                798      BRA end_movem
000016EA                           799  mem_to_reg
000016EA  4EB9 000017BC            800      JSR addr
000016F0  43F8 04C0                801      LEA comma, A1
000016F4  4EB8 126C                802      JSR print
000016F8  4EB9 00001A42            803      JSR movem_postinc
000016FE                           804  end_movem
000016FE  4EB8 127E                805      JSR enter
00001702  6000 FB66                806      BRA out
00001706                           807  
00001706                           808  print_direction:
00001706                           809  *print correct direction given direction bit
00001706  C67C 0100                810      AND.W #$0100, D3
0000170A  B67C 0100                811      CMP.W #$0100, D3
0000170E  6700 000E                812      BEQ print_left  *print left
00001712  43F8 04AA                813      LEA right, A1
00001716  4EB8 126C                814      JSR print
0000171A  6000 FB4E                815      BRA out
0000171E                           816  print_left
0000171E  43F8 04AC                817      LEA left, A1
00001722  4EB8 126C                818      JSR print *print right
00001726  4E75                     819      RTS
00001728                           820      
00001728                           821  print_correct_shift_rotation:
00001728                           822  *determine if instruction is logical, arithmetic, or rotation 
00001728  C63C 0003                823      AND.B #$03, D3
0000172C  B63C 0000                824      CMP.B #$00, D3
00001730  6700 0016                825      BEQ print_as
00001734  B63C 0001                826      CMP.B #$01, D3
00001738  6700 0016                827      BEQ print_ls
0000173C  B63C 0003                828      CMP.B #$03, D3
00001740  43F8 0484                829      LEA ro_ins, A1  print rotation
00001744  6000 000E                830      BRA print_it
00001748                           831  print_as
00001748  43F8 0481                832      LEA as_ins, A1  print arithmetic shift
0000174C  6000 0006                833      BRA print_it
00001750                           834  print_ls
00001750  43F8 047E                835      LEA ls_ins, A1 print logical shift
00001754                           836  print_it
00001754  4EB8 126C                837      JSR print
00001758  4E75                     838      RTS
0000175A                           839  * --------- End Print Instruction ----------*
0000175A                           840  
0000175A                           841  * ------- Instruction sizes ---------*
0000175A                           842  
0000175A                           843  move_size:  *print size for MOVE and MOVEA instruction
0000175A  4284                     844      CLR.L D4
0000175C  3802                     845      MOVE.W D2, D4
0000175E  C87C 3000                846      AND.W #$3000, D4
00001762  B87C 1000                847      CMP.W #$1000, D4
00001766  6700 0014                848      BEQ print_b
0000176A  B87C 3000                849      CMP.W #$3000, D4
0000176E  6700 0018                850      BEQ print_w
00001772  B87C 2000                851      CMP.W #$2000, D4
00001776  6700 001C                852      BEQ print_l
0000177A  4E75                     853      RTS
0000177C                           854      
0000177C                           855  print_b     *print '.B'
0000177C  43F8 0441                856      LEA byte, A1
00001780  4EB8 126C                857      JSR print
00001784  6000 FAE4                858      BRA out
00001788                           859      
00001788                           860  print_w     *print '.W'
00001788  43F8 043D                861      LEA word, A1
0000178C  4EB8 126C                862      JSR print
00001790  6000 FAD8                863      BRA out
00001794                           864      
00001794                           865  print_l:    *print '.L'
00001794  43F8 0439                866      LEA long, A1
00001798  4EB8 126C                867      JSR print
0000179C  6000 FACC                868      BRA out
000017A0                           869  
000017A0                           870  size:       *print size for non "move" instructions
000017A0  4284                     871      CLR.L D4
000017A2  1802                     872      MOVE.B D2,D4
000017A4  C83C 00C0                873      AND.B #$C0, D4
000017A8  B83C 0000                874      CMP.B #$00, D4
000017AC  67CE                     875      BEQ print_b
000017AE  B83C 0040                876      CMP.B #$40,D4
000017B2  67D4                     877      BEQ print_w
000017B4  B83C 0080                878      CMP.B #$80, D4
000017B8  67DA                     879      BEQ print_l
000017BA  4E75                     880      RTS
000017BC                           881      
000017BC                           882  * ------- End Instruction sizes ---------*
000017BC                           883  
000017BC                           884  * ------- Effective Address -------*
000017BC                           885  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000017BC  3A02                     886      MOVE.W D2, D5
000017BE  3C02                     887      MOVE.W D2, D6               
000017C0  BE3C 0001                888      CMP.B #1, D7
000017C4  6700 003A                889      BEQ destination *check if evaluating destination address (used for MOVE)
000017C8                           890  cont
000017C8  CC3C 0038                891      AND.B #$38, D6
000017CC  BC3C 0000                892      CMP.B #0, D6
000017D0  6700 0038                893      BEQ data_reg        *check if EA mode is data register
000017D4  BC3C 0008                894      CMP.B #$08, D6
000017D8  6700 0048                895      BEQ add_reg         *check if EA mode is address register
000017DC  BC3C 0010                896      CMP.B #$10, D6
000017E0  6700 0058                897      BEQ add_indirect    *check if EA mode is address indirect
000017E4  BC3C 0018                898      CMP.B #$18, D6
000017E8  6700 0070                899      BEQ post_increment  *check if EA mode is post increment
000017EC  BC3C 0020                900      CMP.B #$20, D6
000017F0  6700 0088                901      BEQ pre_decrement   *check if EA mode is pre_decrement
000017F4  BC3C 0038                902      CMP.B #$38, D6
000017F8  6700 00A0                903      BEQ absolute_or_immediate
000017FC  6000 FA6C                904      BRA out *needs Immediate, Abs Long, and Abs Word
00001800                           905  destination     *perform correct rotation to retrieve destination address
00001800  3C05                     906      MOVE.W D5,D6
00001802  EF5D                     907      ROL.W #7,D5
00001804  E64E                     908      LSR.W #3,D6
00001806  60C0                     909      BRA cont
00001808  4E75                     910      RTS
0000180A                           911  
0000180A                           912  data_reg    *used with addr sub routine
0000180A  3C05                     913      MOVE.W D5,D6    
0000180C  CC3C 0007                914      AND.B #$07, D6  
00001810  43F8 04AE                915      LEA D_reg, A1   
00001814  4EB8 126C                916      JSR print
00001818  4EB9 00001934            917      JSR Xn
0000181E  6000 FA4A                918      BRA out
00001822                           919  
00001822                           920  add_reg     *used with addr sub routine
00001822  3C05                     921      MOVE.W D5,D6    
00001824  CC3C 0007                922      AND.B #$07, D6
00001828  43F8 04B0                923      LEA A_reg, A1   
0000182C  4EB8 126C                924      JSR print
00001830  4EB9 00001934            925      JSR Xn
00001836  6000 FA32                926      BRA out
0000183A                           927      
0000183A                           928  add_indirect    *used with addr sub routine
0000183A  3C05                     929      MOVE.W D5,D6    
0000183C  CC3C 0007                930      AND.B #$07, D6
00001840  43F8 04B2                931      LEA open_paran, A1  
00001844  4EB8 126C                932      JSR print
00001848  4EB9 00001934            933      JSR Xn
0000184E  43F8 04B5                934      LEA close_paran, A1 
00001852  4EB8 126C                935      JSR print
00001856  6000 FA12                936      BRA out
0000185A                           937      
0000185A                           938  post_increment  *used with addr sub routine
0000185A  3C05                     939      MOVE.W D5,D6    
0000185C  CC3C 0007                940      AND.B #$07, D6
00001860  43F8 04B2                941      LEA open_paran, A1  
00001864  4EB8 126C                942      JSR print
00001868  4EB9 00001934            943      JSR Xn
0000186E  43F8 04B7                944      LEA post_inc, A1    
00001872  4EB8 126C                945      JSR print
00001876  6000 F9F2                946      BRA out
0000187A                           947      
0000187A                           948  pre_decrement   *used with addr sub routine
0000187A  3C05                     949      MOVE.W D5,D6    
0000187C  CC3C 0007                950      AND.B #$07, D6
00001880  43F8 04BA                951      LEA pre_dec, A1 
00001884  4EB8 126C                952      JSR print
00001888  4EB9 00001934            953      JSR Xn
0000188E  43F8 04B5                954      LEA close_paran, A1 
00001892  4EB8 126C                955      JSR print
00001896  6000 F9D2                956      BRA out
0000189A                           957  
0000189A                           958  absolute_or_immediate *check if EA is immediate or absolute address
0000189A  3C05                     959      MOVE.W D5,D6    
0000189C  CC3C 0007                960      AND.B #$07, D6
000018A0  BC3C 0000                961      CMP.B #$00, D6
000018A4  6700 0054                962      BEQ w_imm
000018A8  BC3C 0001                963      CMP.B #$01, D6
000018AC  6700 0068                964      BEQ l_imm
000018B0  BC3C 0004                965      CMP.B #04, D6
000018B4  6700 0002                966      BEQ immediate
000018B8                           967      
000018B8                           968  immediate
000018B8  43F8 04C3                969      LEA pound, A1
000018BC  4EB8 126C                970      JSR print
000018C0  B4BC 00004000            971      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
000018C6  6D00 0016                972      BLT move_movea      *check if instruction is move or movea
000018CA  B8BC 00000040            973      CMP.L #$0040, D4        *if not move or movea
000018D0  6F00 0028                974      BLE w_imm           *byte and word check the next 2 addresses in mem
000018D4  B8BC 00000080            975      CMP.L #$0080, D4
000018DA  6700 003A                976      BEQ l_imm           *long checks the next 4 addresses in mem
000018DE                           977  move_movea              *similar comparisons, but for different bits in OPCODE
000018DE  B87C 1000                978      CMP.W #$1000, D4
000018E2  6700 0016                979      BEQ w_imm
000018E6  B87C 3000                980      CMP.W #$3000, D4
000018EA  6700 000E                981      BEQ w_imm
000018EE  B87C 2000                982      CMP.W #$2000, D4
000018F2  6700 0022                983      BEQ l_imm
000018F6                           984  imm_complete
000018F6  6000 F972                985      BRA out
000018FA                           986      
000018FA                           987  w_imm
000018FA  43F8 04D3                988      LEA dollar, A1      *print '$'
000018FE  4EB8 126C                989      JSR print
00001902  544C                     990      ADDA.W #2,A4        *update current address
00001904  3214                     991      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001906  3602                     992      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001908  343C 0010                993      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000190C  103C 000F                994      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001910  4E4F                     995      TRAP #15
00001912  3403                     996      MOVE.W D3,D2        *copy opcode back to register D2
00001914  60E0                     997      BRA imm_complete    *exit addr subroutine
00001916                           998      
00001916                           999  l_imm
00001916  43F8 04D3               1000      LEA dollar, A1      *print '$'
0000191A  4EB8 126C               1001      JSR print
0000191E  544C                    1002      ADDA.W  #2,A4       *update current address
00001920  2214                    1003      MOVE.L (A4),D1      *retrieve long data stored in the new current address
00001922  3602                    1004      MOVE.W D2, D3
00001924  343C 0010               1005      MOVE.W #16, D2
00001928  103C 000F               1006      MOVE.B #15, D0
0000192C  4E4F                    1007      TRAP #15
0000192E  3403                    1008      MOVE.W D3,D2
00001930  544C                    1009      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
00001932  60C2                    1010      BRA imm_complete    *exit addr subroutine
00001934                          1011  
00001934                          1012  Xn:                     *retieve signed decimal value of data stored in register D6
00001934  4281                    1013      CLR.L D1
00001936  1206                    1014      MOVE.B D6,D1
00001938  103C 0003               1015      MOVE.B #3, D0
0000193C  4E4F                    1016      TRAP #15
0000193E  4E75                    1017      RTS
00001940                          1018  
00001940                          1019  data_reg_sr:    *use if dealing with Dn only
00001940  4286                    1020      CLR.L D6
00001942  3C05                    1021      MOVE.W D5,D6
00001944  EF5E                    1022      ROL.W #7,D6
00001946  CC3C 0007               1023      AND.B #$07, D6  
0000194A  43F8 04AE               1024      LEA D_reg, A1   
0000194E  4EB8 126C               1025      JSR print
00001952  4EB8 1934               1026      JSR Xn
00001956  4E75                    1027      RTS
00001958                          1028      
00001958                          1029  add_reg_sr:     *use if dealing with An only
00001958  4286                    1030      CLR.L D6
0000195A  3C02                    1031      MOVE.W D2,D6
0000195C  EF5E                    1032      ROL.W #7,D6
0000195E  CC3C 0007               1033      AND.B #$07, D6  
00001962  43F8 04B0               1034      LEA A_reg, A1   
00001966  4EB8 126C               1035      JSR print
0000196A  4EB8 1934               1036      JSR Xn
0000196E  4E75                    1037      RTS
00001970                          1038      
00001970                          1039  movem_predec:           *needs to be worked on
00001970  4285                    1040      CLR.L D5
00001972  544C                    1041      ADDA.W  #2,A4       *update current address
00001974  3A14                    1042      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001976  BA3C 0000               1043      CMP.B #$00, D5
0000197A  6700 006C               1044      BEQ predec_skip_to_d
0000197E  3C05                    1045      MOVE.W D5,D6
00001980  4281                    1046      CLR.L D1
00001982  123C 0000               1047      MOVE.B #0, D1
00001986                          1048  a_loop1
00001986  E31E                    1049      ROL.B #1,D6
00001988  6500 0006               1050      BCS a_loop1_done
0000198C  5201                    1051      ADD.B #1,D1
0000198E  60F6                    1052      BRA a_loop1
00001990                          1053  a_loop1_done
00001990  43F8 04B0               1054      LEA A_reg,A1
00001994  4EB8 126C               1055      JSR print
00001998  103C 0003               1056      MOVE.B #3,D0
0000199C  4E4F                    1057      TRAP #15
0000199E  4287                    1058      CLR.L D7
000019A0  1E3C 0000               1059      MOVE.B #0, D7
000019A4                          1060  a_loop2
000019A4  E31E                    1061      ROL.B #1,D6
000019A6  6400 0010               1062      BCC a_loop2_done
000019AA  5207                    1063      ADD.B #1,D7
000019AC  5201                    1064      ADD.B #1,D1
000019AE  B23C 0007               1065      CMP.B #7, D1
000019B2  6700 0004               1066      BEQ a_loop2_done
000019B6  60EC                    1067      BRA a_loop2
000019B8                          1068  a_loop2_done
000019B8  BE3C 0000               1069      CMP.B #0, D7
000019BC  6700 0018               1070      BEQ predec_no_dash
000019C0  43F8 04C5               1071      LEA dash, A1
000019C4  4EB8 126C               1072      JSR print
000019C8  43F8 04B0               1073      LEA A_reg,A1
000019CC  4EB8 126C               1074      JSR print
000019D0  103C 0003               1075      MOVE.B #3,D0
000019D4  4E4F                    1076      TRAP #15
000019D6                          1077  predec_no_dash
000019D6  BABC 000000FF           1078      CMP.L #$00FF,D5
000019DC  6F00 0062               1079      BLE end_movem_predec
000019E0  43F8 04C7               1080      LEA slash, A1
000019E4  4EB8 126C               1081      JSR print
000019E8                          1082  predec_skip_to_d    
000019E8  3C05                    1083      MOVE.W D5,D6
000019EA  E04E                    1084      LSR.W #8,D6
000019EC  4281                    1085      CLR.L D1
000019EE  123C 0000               1086      MOVE.B #0, D1
000019F2                          1087  d_loop1
000019F2  E31E                    1088      ROL.B #1,D6
000019F4  6500 0006               1089      BCS d_loop1_done
000019F8  5201                    1090      ADD.B #1,D1
000019FA  60F6                    1091      BRA d_loop1
000019FC                          1092  d_loop1_done
000019FC  43F8 04AE               1093      LEA D_reg,A1
00001A00  4EB8 126C               1094      JSR print
00001A04  103C 0003               1095      MOVE.B #3,D0
00001A08  4E4F                    1096      TRAP #15
00001A0A  4287                    1097      CLR.L D7
00001A0C  1E3C 0000               1098      MOVE.B #0, D7
00001A10                          1099  d_loop2
00001A10  E31E                    1100      ROL.B #1,D6
00001A12  6400 000E               1101      BCC d_loop2_done
00001A16  5201                    1102      ADD.B #1,D1
00001A18  B23C 0007               1103      CMP.B #7, D1
00001A1C  6700 0004               1104      BEQ d_loop2_done
00001A20  60EE                    1105      BRA d_loop2
00001A22                          1106  d_loop2_done
00001A22  BE3C 0000               1107      CMP.B #0, D7
00001A26  6F00 0018               1108      BLE end_movem_predec
00001A2A  43F8 04C5               1109      LEA dash, A1
00001A2E  4EB8 126C               1110      JSR print
00001A32  43F8 04AE               1111      LEA D_reg,A1
00001A36  4EB8 126C               1112      JSR print
00001A3A  103C 0003               1113      MOVE.B #3,D0
00001A3E  4E4F                    1114      TRAP #15
00001A40                          1115  end_movem_predec
00001A40  4E75                    1116      RTS
00001A42                          1117      
00001A42                          1118  movem_postinc:          *needs to be worked on
00001A42  4285                    1119      CLR.L D5
00001A44  544C                    1120      ADDA.W  #2,A4       *update current address
00001A46  3A14                    1121      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A48  3C05                    1122      MOVE.W D5,D6
00001A4A  E04E                    1123      LSR.W #8,D6
00001A4C  BC3C 0000               1124      CMP.B #$00, D6
00001A50  6700 0068               1125      BEQ postinc_skip_to_d
00001A54  4281                    1126      CLR.L D1
00001A56  123C 0000               1127      MOVE.B #0, D1
00001A5A                          1128  a_loop3
00001A5A  E21E                    1129      ROR.B #1,D6
00001A5C  6500 0006               1130      BCS a_loop3_done
00001A60  5201                    1131      ADD.B #1,D1
00001A62  60F6                    1132      BRA a_loop3
00001A64                          1133  a_loop3_done
00001A64  43F8 04B0               1134      LEA A_reg,A1
00001A68  4EB8 126C               1135      JSR print
00001A6C  103C 0003               1136      MOVE.B #3,D0
00001A70  4E4F                    1137      TRAP #15
00001A72  4287                    1138      CLR.L D7
00001A74  1E3C 0000               1139      MOVE.B #0, D7
00001A78                          1140  a_loop4
00001A78  E21E                    1141      ROR.B #1,D6
00001A7A  6400 0010               1142      BCC a_loop4_done
00001A7E  5207                    1143      ADD.B #1,D7
00001A80  5201                    1144      ADD.B #1,D1
00001A82  B23C 0007               1145      CMP.B #7, D1
00001A86  6700 0004               1146      BEQ a_loop4_done
00001A8A  60EC                    1147      BRA a_loop4
00001A8C                          1148  a_loop4_done
00001A8C  BE3C 0000               1149      CMP.B #0, D7
00001A90  6700 0018               1150      BEQ postinc_no_dash
00001A94  43F8 04C5               1151      LEA dash, A1
00001A98  4EB8 126C               1152      JSR print
00001A9C  43F8 04B0               1153      LEA A_reg,A1
00001AA0  4EB8 126C               1154      JSR print
00001AA4  103C 0003               1155      MOVE.B #3,D0
00001AA8  4E4F                    1156      TRAP #15
00001AAA                          1157  postinc_no_dash
00001AAA  BA3C 0000               1158      CMP.B #$00, D5
00001AAE  6700 0060               1159      BEQ end_movem_postinc
00001AB2  43F8 04C7               1160      LEA slash, A1
00001AB6  4EB8 126C               1161      JSR print
00001ABA                          1162  postinc_skip_to_d   
00001ABA  3C05                    1163      MOVE.W D5,D6
00001ABC  4281                    1164      CLR.L D1
00001ABE  123C 0000               1165      MOVE.B #0, D1
00001AC2                          1166  d_loop3
00001AC2  E21E                    1167      ROR.B #1,D6
00001AC4  6500 0006               1168      BCS d_loop3_done
00001AC8  5201                    1169      ADD.B #1,D1
00001ACA  60F6                    1170      BRA d_loop3
00001ACC                          1171  d_loop3_done
00001ACC  43F8 04AE               1172      LEA D_reg,A1
00001AD0  4EB8 126C               1173      JSR print
00001AD4  103C 0003               1174      MOVE.B #3,D0
00001AD8  4E4F                    1175      TRAP #15
00001ADA  4287                    1176      CLR.L D7
00001ADC  1E3C 0000               1177      MOVE.B #0, D7
00001AE0                          1178  d_loop4
00001AE0  E21E                    1179      ROR.B #1,D6
00001AE2  6400 000E               1180      BCC d_loop4_done
00001AE6  5201                    1181      ADD.B #1,D1
00001AE8  B23C 0007               1182      CMP.B #7, D1
00001AEC  6700 0004               1183      BEQ d_loop4_done
00001AF0  60EE                    1184      BRA d_loop4
00001AF2                          1185  d_loop4_done
00001AF2  BE3C 0000               1186      CMP.B #0, D7
00001AF6  6F00 0018               1187      BLE end_movem_postinc
00001AFA  43F8 04C5               1188      LEA dash, A1
00001AFE  4EB8 126C               1189      JSR print
00001B02  43F8 04AE               1190      LEA D_reg,A1
00001B06  4EB8 126C               1191      JSR print
00001B0A  103C 0003               1192      MOVE.B #3,D0
00001B0E  4E4F                    1193      TRAP #15
00001B10                          1194  end_movem_postinc
00001B10  4E75                    1195      RTS
00001B12                          1196  
00001B12                          1197  
00001B12                          1198  * ------- End Effective Address -------*
00001B12                          1199  
00001B12                          1200  * ----- Hex to ASCII & ASCII to HEX -----*
00001B12                          1201  
00001B12                          1202  ASCIItoHex:
00001B12  4EB9 00001B20           1203          jsr     ASCII2Hex_init  
00001B18  4EB9 00001B26           1204          jsr     conversion_loop
00001B1E  4E75                    1205          rts                    
00001B20                          1206  
00001B20                          1207  ASCII2Hex_init:   
00001B20  143C 0000               1208          move.b  #0,D2       *set up counter    
00001B24  4E75                    1209          rts         
00001B26                          1210          
00001B26                          1211  conversion_loop:            
00001B26  5282                    1212          add.l   #1,D2       *increment counter
00001B28  B4BC 00000009           1213          cmp.l   #9,D2       *ends at 9
00001B2E  6700 004A               1214          BEQ     DONE        *branch when compare is true
00001B32  1819                    1215          move.b  (A1)+,D4    *Get first num
00001B34                          1216          
00001B34  B83C 0040               1217          cmp.b   #$40,D4        
00001B38  6E00 000C               1218          bgt     Letters_Cap  
00001B3C                          1219          
00001B3C  B83C 0039               1220          cmp.b   #$39,D4
00001B40  6F00 0016               1221          BLE     Numbers      
00001B44  4E75                    1222          rts
00001B46                          1223          
00001B46                          1224  Letters_Cap:      
00001B46  B83C 0046               1225          cmp.b   #$46,D4          
00001B4A  6E00 001E               1226          bgt     ERROR  
00001B4E  0404 0037               1227          sub.b   #$37,D4     
00001B52  E986                    1228          asl.l   #4,D6       
00001B54  DC84                    1229          add.l   D4,D6     
00001B56  60CE                    1230          bra     conversion_loop 
00001B58                          1231  Numbers:
00001B58  B83C 0030               1232          cmp.b   #$30,D4         
00001B5C  6D00 000C               1233          blt     ERROR        
00001B60  0404 0030               1234          sub.b   #$30,D4      
00001B64  E986                    1235          asl.l   #4,D6        
00001B66  DC84                    1236          add.l   D4,D6     
00001B68  60BC                    1237          bra     conversion_loop
00001B6A                          1238          
00001B6A                          1239  ERROR:
00001B6A  43F8 011E               1240          lea     ErrorMsg,A1    
00001B6E  103C 000E               1241          move.b  #14,D0
00001B72  4E4F                    1242          trap    #15
00001B74                          1243      
00001B74  103C 0009               1244          move.b  #9,D0
00001B78  4E4F                    1245          trap    #15
00001B7A                          1246          
00001B7A                          1247  DONE:
00001B7A                          1248     
00001B7A  4241                    1249          clr     D1
00001B7C  4242                    1250          clr     D2
00001B7E  4244                    1251          clr     D4
00001B80                          1252      
00001B80  43F8 014F               1253          lea     ASCIItoHexMsg,A1
00001B84  103C 000E               1254          move.b  #14,D0
00001B88  4E4F                    1255          trap    #15
00001B8A                          1256  
00001B8A  4E75                    1257          rts
00001B8C                          1258          
00001B8C                          1259  
00001B8C                          1260          
00001B8C                          1261  * -- End of Hex to ASCII & ASCII to HEX --*
00001B8C                          1262  
00001B8C                          1263  * Put program code here
00001B8C                          1264  
00001B8C  FFFF FFFF               1265      SIMHALT             ; halt simulator
00001B90                          1266  
00001B90                          1267  * Put variables and constants here
00001B90                          1268  
00001B90                          1269      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  189A
ADDA_INS            469
ADDA_SIZE           13AA
ADDQ_INS            46E
ADDR                17BC
ADD_A               1388
ADD_INDIRECT        183A
ADD_INS             465
ADD_REG             1822
ADD_REG_SR          1958
ANDQ_INS            495
AND_INS             476
ASCII2HEX_INIT      1B20
ASCIITOHEX          1B12
ASCIITOHEXMSG       14F
AS_INS              481
A_LOOP1             1986
A_LOOP1_DONE        1990
A_LOOP2             19A4
A_LOOP2_DONE        19B8
A_LOOP3             1A5A
A_LOOP3_DONE        1A64
A_LOOP4             1A78
A_LOOP4_DONE        1A8C
A_REG               4B0
BEQ_INS             4A2
BGT_INS             49A
BLE_INS             49E
BRA_INS             4A6
BYTE                441
CHECKADDRESS        10E8
CHECK_WORD          1670
CLEARDONE           111A
CLEARSCREEN         10EC
CLEARSCREEN_40      1102
CLEAR_REGISTERS     1054
CLOSE_PARAN         4B5
COMMA               4C0
CONT                17C8
CONTINUEORNOTMSG    206
CONTINUE_INSTRUCTION_LS_AS_RO  14FE
CONVERSION_LOOP     1B26
CR                  D
CREATORS            1F
DASH                4C5
DATA                4CC
DATA_REG            180A
DATA_REG_SR         1940
DESTINATION         1800
DOLLAR              4D3
DONE                1B7A
D_LOOP1             19F2
D_LOOP1_DONE        19FC
D_LOOP2             1A10
D_LOOP2_DONE        1A22
D_LOOP3             1AC2
D_LOOP3_DONE        1ACC
D_LOOP4             1AE0
D_LOOP4_DONE        1AF2
D_REG               4AE
EA_DEST_ADD         136E
EA_DEST_SUB_AND_OR  1450
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13CA
END_ADDR_BUFFER     339
END_BRA_BCC         1692
END_MOVEM           16FE
END_MOVEM_POSTINC   1B10
END_MOVEM_PREDEC    1A40
ENTER               127E
ENTER_PRESS_TRUE    11B4
ERROR               1B6A
ERRORMSG            11E
EXITMSG             229
FLUSHSCREEN         1190
FLUSHSCREENMSG      190
FLUSHSCREEN_INPUT   11A2
GETENDADDRESS       10CE
GETSTARTADDRESS     10B4
HELPMSG             1CA
HEXTOASCIIMSG       12D
IMMEDIATE           18B8
IMM_COMPLETE        18F6
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             124E
JSR_INS             48B
LEA_INS             490
LEFT                4AC
LETTERS_CAP         1B46
LF                  A
LONG                439
LS_AS_RO_MEM        1514
LS_AS_RO_REG        14F6
LS_INS              47E
L_IMM               1916
MEMSEARCH           111C
MEMSEARCHLOOP       1130
MEMSEARCH_DONE      116A
MEM_TO_REG          16EA
MENU                1090
MOVEA_INS           45F
MOVEM_DIRECTION     16C4
MOVEM_INS           459
MOVEM_LONG          16BC
MOVEM_POSTINC       1A42
MOVEM_PREDEC        1970
MOVEQ_INS           452
MOVE_A              12FA
MOVE_INS            44D
MOVE_MOVEA          18DE
MOVE_SIZE           175A
MUL_DIV             146E
MUL_DIV_LONG        1490
M_SIZE              1302
NEXT_ADD            13B6
NEXT_BRA_BCC        163E
NEXT_LS_AS_RO       1542
NOP_INS             445
NOT_INS             487
NUMBERS             1B58
OPCODE_DECODE       11B6
OPEN_PARAN          4B2
OR_INS              473
OUT                 126A
POSTINC_NO_DASH     1AAA
POSTINC_SKIP_TO_D   1ABA
POST_INC            4B7
POST_INCREMENT      185A
POUND               4C3
PREDEC_NO_DASH      19D6
PREDEC_SKIP_TO_D    19E8
PRE_DEC             4BA
PRE_DECREMENT       187A
PRINT               126C
PRINTLN             1276
PRINT_ADDQ          15AE
PRINT_ADD_ADDA      132A
PRINT_AS            1748
PRINT_B             177C
PRINT_BEQ           161E
PRINT_BGT           1636
PRINT_BLE           162A
PRINT_BRA           1612
PRINT_BRA_BCC       15E8
PRINT_CORRECT_SHIFT_ROTATION  1728
PRINT_DIRECTION     1706
PRINT_INSTRUCTION   141E
PRINT_IT            1754
PRINT_JSR           1574
PRINT_L             1794
PRINT_LEA           158A
PRINT_LEFT          171E
PRINT_LS            1750
PRINT_LS_AS_RO      1496
PRINT_MOVEM         169A
PRINT_MOVEQ         129C
PRINT_MOVE_MOVEA    12E0
PRINT_NOP           1288
PRINT_NOT           154A
PRINT_OR            141A
PRINT_RTS           1292
PRINT_SUB           1404
PRINT_SUB_AND_OR    13D2
PRINT_W             1788
RETURN              4C9
RIGHT               4AA
RO_INS              484
RTS_INS             449
SCREENFLUSH_CHECK   1186
SIZE                17A0
SLASH               4C7
SPACE               4BE
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   239
SUB_INS             47A
TAB                 9
TERMINATEORCONT     1176
WORD                43D
W_IMM               18FA
XN                  1934
