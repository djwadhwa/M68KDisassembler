00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 3:30:33 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 46 69 6E ...     22  EndOfMemLoop        dc.b    '---Finished Reading Instructions---',CR,LF,0
00000199= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to continue with the next set of instructions',0
000001D3= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
0000020F= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
00000245= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000255                            27  
00000255                            28  *START_ADDR_BUFFER  DS.B    256
00000255                            29  *END_ADDR_BUFFER    DS.B    256
00000255                            30  
00000255                            31  *size
00000255= 2E 4C 20 00               32  long                DC.B    '.L ',0
00000259= 2E 57 20 00               33  word                DC.B    '.W ',0
0000025D= 2E 42 20 00               34  byte                DC.B    '.B ',0
00000261                            35  
00000261                            36  *instructions
00000261= 4E 4F 50 00               37  nop_ins             DC.B    'NOP',0
00000265= 52 54 53 00               38  rts_ins             DC.B    'RTS',0
00000269= 4D 4F 56 45 00            39  move_ins            DC.B    'MOVE',0
0000026E= 4D 4F 56 45 51 20 00      40  moveq_ins           DC.B    'MOVEQ ',0
00000275= 4D 4F 56 45 4D 00         41  movem_ins           DC.B    'MOVEM',0
0000027B= 4D 4F 56 45 41 00         42  movea_ins           DC.B    'MOVEA',0
00000281= 41 44 44 00               43  add_ins             DC.B    'ADD',0
00000285= 41 44 44 41 00            44  adda_ins            DC.B    'ADDA',0
0000028A= 41 44 44 51 00            45  addq_ins            DC.B    'ADDQ',0
0000028F= 4F 52 00                  46  or_ins              DC.B    'OR',0
00000292= 41 4E 44 00               47  and_ins             DC.B    'AND',0
00000296= 53 55 42 00               48  sub_ins             DC.B    'SUB',0
0000029A= 4C 53 00                  49  ls_ins              DC.B    'LS',0
0000029D= 41 53 00                  50  as_ins              DC.B    'AS',0
000002A0= 52 4F 00                  51  ro_ins              DC.B    'RO',0
000002A3= 4E 4F 54 00               52  not_ins             DC.B    'NOT',0
000002A7= 4A 53 52 20 00            53  jsr_ins             DC.B    'JSR ',0
000002AC= 4C 45 41 20 00            54  lea_ins             DC.B    'LEA ',0
000002B1= 41 44 44 51 00            55  andq_ins            DC.B    'ADDQ',0
000002B6= 42 47 54 00               56  bgt_ins             DC.B    'BGT',0
000002BA= 42 4C 45 00               57  ble_ins             DC.B    'BLE',0
000002BE= 42 45 51 00               58  beq_ins             DC.B    'BEQ',0
000002C2= 42 52 41 00               59  bra_ins             DC.B    'BRA',0
000002C6                            60  
000002C6                            61  *direction
000002C6= 52 00                     62  right               DC.B    'R',0
000002C8= 4C 00                     63  left                DC.B    'L',0
000002CA                            64  
000002CA                            65  *EA
000002CA= 44 00                     66  D_reg               DC.B    'D',0
000002CC= 41 00                     67  A_reg               DC.B    'A',0
000002CE= 28 41 00                  68  open_paran          DC.B    '(A',0
000002D1= 29 00                     69  close_paran         DC.B    ')',0
000002D3= 29 2B 00                  70  post_inc            DC.B    ')+',0
000002D6= 2D 28 41 00               71  pre_dec             DC.B    '-(A',0
000002DA                            72  
000002DA                            73  *extra
000002DA= 20 00                     74  space               DC.B    ' ',0
000002DC= 2C 20 00                  75  comma               DC.B    ', ',0
000002DF= 23 00                     76  pound               DC.B    '#',0
000002E1= 2D 00                     77  dash                DC.B    '-',0
000002E3= 2F 00                     78  slash               DC.B    '/',0
000002E5  =00000009                 79  tab                 EQU     $9
000002E5= 0D 0A 00                  80  return              DC.B    CR,LF,0
000002E8= 44 41 54 41 20 24 00      81  data                DC.B    'DATA $',0
000002EF= 24 00                     82  dollar              DC.B    '$',0
00001000                            83      ORG    $1000    *Start at address $1000
00001000                            84  START:                  ; first instruction of program
00001000                            85  
00001000                            86  *---------- Test value, will remove in final build ----------*
00001000                            87  
00001000                            88  *   Move.W #$4E75,$00009234 *RTS
00001000                            89  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            90  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            91  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            92  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            93  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            94  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            95  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            96  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            97  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            98  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            99  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                           100  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           101  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           102  *   MOVE.W #$000C,$00009250
00001000                           103  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           104  *   MOVE.L #$12345678,$00009254
00001000                           105  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           106  *   MOVE.W #$0012,$0000925A
00001000                           107  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           108  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           109  *   MOVE.L #$00009208,$00009260
00001000                           110  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           111  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           112  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           113  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           114  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           115  *    MOVE.W #$FE7A,$0000926E
00001000                           116  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           117  *    MOVE.W #$FE60,$00009272
00001000                           118  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           119  *    MOVE.L #$00009208,$000009276
00001000                           120  *    MOVE.W #$48A1,$0000927A
00001000                           121  *    MOVE.W #$011F,$0000927C
00001000                           122  *    MOVE.W #$4C91,$0000927E
00001000                           123  *    MOVE.W #$FE00,$00009280
00001000                           124  *   MOVE.W #$C2BC, $00009000
00001000                           125  *   MOVE.L #$12345678, $00009002
00001000  33FC 48F9 00009000       126      MOVE.W #$48F9, $00009000
00001008  33FC 0280 00009002       127      MOVE.W #$0280, $00009002 
00001010  23FC 12345678 00009004   128      MOVE.L #$12345678, $00009004
0000101A                           129  *   MOVE.W #$9441, $00009006
0000101A                           130  *   Move.w #$C27C, $00009008
0000101A                           131  *   move.w #$1234, $0000900A
0000101A                           132  *   MOVE.L #$12345678, $00009002
0000101A                           133  *---------- END Test ----------*
0000101A                           134  
0000101A                           135  
0000101A                           136  
0000101A                           137  *---------- Beginning Messages ----------*
0000101A                           138      
0000101A  103C 000E                139      move.b      #14,D0
0000101E  43F8 0000                140      lea         StartingMsg,A1 
00001022  4E4F                     141      trap        #15
00001024                           142      
00001024  103C 000E                143      move.b      #14,D0
00001028  43F8 001F                144      lea         Creators,A1
0000102C  4E4F                     145      trap        #15
0000102E                           146      
0000102E  4EB9 00001080            147      jsr         MENU
00001034                           148      
00001034                           149      
00001034                           150  * ---------- END OF PROGRAM -------------*
00001034                           151  
00001034  103C 000E                152      move.b      #14,D0
00001038  43F8 0245                153      lea         ExitMsg,A1 
0000103C  4E4F                     154      trap        #15
0000103E                           155      
0000103E  103C 0009                156      move.b      #9,D0
00001042  4E4F                     157      trap        #15
00001044                           158  * ---------------------------------------*
00001044                           159      
00001044                           160  *-- End of Opening and Ending Messages --*
00001044                           161  
00001044                           162  *--------- Start of I/O Section ---------*
00001044                           163  
00001044                           164  Clear_Registers:
00001044  4280                     165      clr.l     D0
00001046  4281                     166      clr.l     D1
00001048  4282                     167      clr.l     D2
0000104A  4283                     168      clr.l     D3
0000104C  4284                     169      clr.l     D4
0000104E  4285                     170      clr.l     D5
00001050  4286                     171      clr.l     D6
00001052  4287                     172      clr.l     D7
00001054                           173      
00001054  207C 00000000            174      movea.l   #0,A0
0000105A  227C 00000000            175      movea.l   #0,A1
00001060  247C 00000000            176      movea.l   #0,A2
00001066  267C 00000000            177      movea.l   #0,A3
0000106C  287C 00000000            178      movea.l   #0,A4
00001072  2A7C 00000000            179      movea.l   #0,A5
00001078  2C7C 00000000            180      movea.l   #0,A6
0000107E  4E75                     181      rts
00001080                           182  
00001080                           183  MENU:
00001080  4EB8 1044                184      jsr         Clear_Registers
00001084  4EB9 00001098            185      jsr         GetStartAddress
0000108A  4EB9 000010B8            186      jsr         GetEndAddress
00001090                           187      
00001090  4EB9 00001108            188      jsr         MemSearch
00001096  4E75                     189      rts
00001098                           190      
00001098                           191  GetStartAddress:         *Display input message
00001098  103C 000E                192      move.b  #14, D0
0000109C  43F8 004E                193      lea         InputMsg1,A1
000010A0  4E4F                     194      trap #15
000010A2  227C 00000000            195      MOVEA.L #0, A1
000010A8  103C 0002                196      move.b      #2,D0
000010AC  4E4F                     197      trap        #15
000010AE                           198          
000010AE  4EB9 00001B08            199      jsr ASCIItoHex              *conversion to Hex
000010B4                           200      * Address Located in D6
000010B4  2846                     201      movea.l     D6,A4           *move into address register 4
000010B6  4E75                     202      rts
000010B8                           203      
000010B8                           204      
000010B8                           205  GetEndAddress:
000010B8  103C 000E                206      move.b      #14,D0          *Display input message
000010BC  43F8 008F                207      lea         InputMsg2,A1
000010C0  4E4F                     208      trap        #15
000010C2  227C 00000000            209      MOVEA.L #0, A1
000010C8  103C 0002                210      move.b      #2,D0
000010CC  4E4F                     211      trap        #15
000010CE                           212      
000010CE  4EB9 00001B08            213      jsr         ASCIItoHex      *conversion to hex
000010D4                           214      * Address Located in D6 (overwrite)
000010D4  2A46                     215      movea.l     D6,A5           *move into address register 5
000010D6  4E75                     216      rts
000010D8                           217  
000010D8                           218  
000010D8                           219  ClearScreen:
000010D8  43F8 02E5                220      lea     return,A1
000010DC  103C 000E                221      move.b  #14,D0
000010E0  4E4F                     222      trap    #15
000010E2                           223      
000010E2                           224      *move.b  #9,D0
000010E2                           225      *trap    #15
000010E2                           226      
000010E2  B27C 0028                227      cmp.w   #40,D1
000010E6  6700 001E                228      beq     ClearDone
000010EA  5241                     229      add.w   #1,D1
000010EC  60EA                     230      bra     ClearScreen
000010EE                           231  
000010EE                           232  
000010EE                           233  ClearScreen_40:
000010EE  43F8 02E5                234      lea     return,A1
000010F2  103C 000E                235      move.b  #14,D0
000010F6  4E4F                     236      trap    #15
000010F8                           237      
000010F8  B2BC 00000028            238      cmp.l   #40,D1
000010FE  6700 0006                239      beq     ClearDone
00001102  5281                     240      add.l   #1,D1
00001104  60E8                     241      bra     ClearScreen_40
00001106                           242      
00001106                           243  ClearDone:
00001106  4E75                     244      rts
00001108                           245      
00001108                           246  MemSearch:
00001108  7200                     247      move.l      #0,D1
0000110A  4EB8 10D8                248      jsr         ClearScreen
0000110E                           249      * Set up instruction counter and place onto stack
0000110E  303C 0000                250      move.w      #0,D0
00001112  3F00                     251      move.w      D0,-(SP)
00001114                           252      
00001114  4EB9 0000111C            253      jsr MemSearchLoop
0000111A  4E75                     254      rts
0000111C                           255      
0000111C                           256  MemSearchLoop:
0000111C                           257      
0000111C                           258      * Check if we reached the end address
0000111C  BBCC                     259      cmp.l       A4,A5
0000111E  6700 0036                260      beq         MemSearch_Done
00001122                           261      
00001122                           262      * Get data from memory
00001122  4241                     263      CLR D1
00001124  3414                     264      move.w     (A4),D2
00001126  3602                     265      move.w      D2, D3  mutable copy in D3
00001128                           266      * OPCODE Word Located in D2, mutable copy in D3
00001128  220C                     267      MOVE.L      A4, D1
0000112A  143C 0010                268      MOVE.B      #16, D2
0000112E  103C 000F                269      MOVE.B      #15, D0     print address of instruction
00001132  4E4F                     270      TRAP        #15
00001134  3403                     271      MOVE.W      D3,D2
00001136  43F8 02DA                272      LEA         space,A1
0000113A  4EB9 00001282            273      JSR         print
00001140  4EB9 000011CC            274      jsr         OPCODE_DECODE    
00001146                           275      
00001146  544C                     276      adda.w      #2,A4
00001148                           277      
00001148                           278      * Call back counter from the stack
00001148  301F                     279      move.w      (SP)+,D0
0000114A  5200                     280      add.b       #1,D0
0000114C  4EB9 0000119C            281      jsr         ScreenFlush_Check
00001152  3F00                     282      move.w      D0,-(SP)
00001154                           283      
00001154  60C6                     284      bra         MemSearchLoop
00001156                           285      
00001156                           286      
00001156                           287  MemSearch_Done
00001156  43F8 0173                288      lea         EndOfMemLoop,A1 
0000115A  4EB9 00001282            289      jsr print
00001160  43F8 02E5                290      lea     return, A1
00001164  4EB9 00001282            291      jsr print
0000116A  43F8 020F                292      lea ContinueOrNotMsg, A1
0000116E  4EB9 00001282            293      jsr print
00001174  103C 0005                294      MOVE.B #5, D0
00001178  4E4F                     295      TRAP #15
0000117A  43F8 02E5                296      lea return, A1
0000117E  4EB9 00001282            297      jsr print
00001184  B23C 0079                298      CMP.B #121, D1    
00001188  6700 FEF6                299      beq MENU
0000118C  103C 000E                300      move.b      #14,D0
00001190  43F8 0245                301      lea         ExitMsg,A1 
00001194  4E4F                     302      trap        #15
00001196                           303      
00001196  103C 0009                304      move.b      #9,D0
0000119A  4E4F                     305      trap        #15
0000119C                           306  
0000119C                           307  ScreenFlush_Check:
0000119C  B03C 001F                308      cmp.b       #31,D0 * 31
000011A0  6700 0004                309      beq         FlushScreen
000011A4  4E75                     310      rts 
000011A6                           311  
000011A6                           312  FlushScreen:
000011A6  43F8 0199                313      lea         FlushScreenMsg,A1
000011AA  103C 000E                314      move.b      #14,D0
000011AE  4E4F                     315      trap        #15
000011B0  4EB9 000011B8            316      jsr         FlushScreen_Input
000011B6                           317      *move.l      #0,D1
000011B6                           318      *jsr         ClearScreen_40
000011B6  4E75                     319      rts
000011B8                           320  
000011B8                           321  FlushScreen_Input:
000011B8                           322  
000011B8  4241                     323      clr     D1
000011BA                           324  
000011BA  103C 0005                325      move.b  #5,D0
000011BE  4E4F                     326      trap    #15
000011C0                           327      
000011C0  B23C 000D                328      cmp.b   #13,D1
000011C4  6700 0004                329      beq     Enter_Press_True    
000011C8                           330      
000011C8  60EE                     331      bra     FlushScreen_Input
000011CA                           332      
000011CA                           333  Enter_Press_True:
000011CA  4E75                     334      rts
000011CC                           335      
000011CC                           336  
000011CC                           337      
000011CC                           338  
000011CC                           339  * -------- Start of Opcode Section -------*    
000011CC                           340  
000011CC                           341  OPCODE_DECODE:
000011CC                           342      * Begin OPCODE Decoding here
000011CC                           343      * Check first four bits and begin
000011CC                           344      * if-branch breakdown
000011CC  4284                     345      CLR.L D4
000011CE  4285                     346      CLR.L D5
000011D0  4286                     347      CLR.L D6
000011D2  4287                     348      CLR.L D7
000011D4                           349      
000011D4  B47C 4E71                350      CMP.W #$4E71, D2        
000011D8  6700 00C4                351      BEQ print_nop           *check if value is NOP
000011DC                           352      
000011DC  B47C 4E75                353      CMP.W #$4E75, D2        
000011E0  6700 00C6                354      BEQ print_rts           *check if value is RTS
000011E4                           355      
000011E4                           356      * Mask out only the first 4 bits
000011E4  C67C F000                357      AND.W #$F000,D3
000011E8                           358      
000011E8  B67C 9000                359      CMP.W #$9000,D3
000011EC  6700 01FA                360      BEQ print_sub_and_or    *check if value is SUB
000011F0                           361      
000011F0  B67C 6000                362      CMP.W #$6000,D3
000011F4  6700 0408                363      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000011F8                           364      
000011F8  B67C 8000                365      CMP.W #$8000, D3
000011FC  6700 01EA                366      BEQ print_sub_and_or    *check if value is OR
00001200                           367  
00001200  B67C C000                368      CMP.W #$C000,D3
00001204  6700 01E2                369      BEQ print_sub_and_or    *check if value is AND
00001208                           370      
00001208  B67C D000                371      CMP.W #$D000,D3
0000120C  6700 0132                372      BEQ print_add_adda      *check if value is ADD or ADDA
00001210                           373      
00001210  B67C E000                374      CMP.W #$E000,D3
00001214  6700 0296                375      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001218                           376      
00001218  B67C 7000                377      CMP.W #$7000,D3
0000121C  6700 0094                378      BEQ print_moveq     *check if value is MOVEQ
00001220                           379      
00001220  B47C 1000                380      CMP.W #$1000,D2
00001224  6D00 003E                381      BLT invalid
00001228  B47C 4000                382      CMP.W #$4000,D2
0000122C  6D00 00C8                383      BLT print_move_movea    *check if value is MOVE or MOVEA
00001230                           384      
00001230                           385      * Mask out only the first 8 bits
00001230  3602                     386      MOVE.W D2, D3
00001232  C67C FF00                387      AND.W #$FF00,D3
00001236                           388      
00001236  B67C 4600                389      CMP.W #$4600,D3
0000123A  6700 0324                390      BEQ print_not           *check if value is NOT
0000123E                           391      
0000123E  B67C 4E00                392      CMP.W #$4E00,D3
00001242  6700 0346                393      BEQ print_jsr           *check if value is JSR
00001246                           394      
00001246                           395      * Mask out only the first 4 bits and the 8th bit
00001246  3602                     396      MOVE.W D2,D3
00001248  C67C F100                397      AND.W #$F100, D3
0000124C                           398      
0000124C  B67C 4000                399      CMP.W #$4000, D3
00001250  6700 045E                400      BEQ print_movem         *check if value is MOVEM
00001254                           401      
00001254  B67C 4100                402      CMP.W #$4100, D3
00001258  6700 0346                403      BEQ print_lea           *check if value is LEA
0000125C                           404      
0000125C  B67C 5000                405      CMP.W #$5000,D3
00001260  6700 0362                406      BEQ print_addq          *check if value is ANDQ     
00001264                           407      
00001264                           408      
00001264                           409  invalid 
00001264  43F8 02E8                410      LEA data, A1
00001268  4EB9 00001282            411      JSR print
0000126E  2202                     412      MOVE.L D2, D1
00001270  143C 0010                413      MOVE.B #16, D2
00001274  103C 000F                414      MOVE.B  #15, D0     
00001278  4E4F                     415      TRAP #15
0000127A  4EB9 00001294            416      JSR enter
00001280  4E75                     417  out rts
00001282                           418  
00001282                           419      
00001282                           420  * -------- End of Opcode Section --------*   
00001282                           421  
00001282                           422  * --------- Print Instructions ----------*
00001282                           423  
00001282                           424  
00001282                           425  print:
00001282  4240                     426      CLR D0 
00001284  103C 000E                427      MOVE.B #14,D0
00001288  4E4F                     428      TRAP #15
0000128A  4E75                     429      RTS
0000128C                           430  
0000128C                           431  println:
0000128C  103C 000D                432      MOVE.B #13, D0
00001290  4E4F                     433      TRAP #15
00001292  4E75                     434      RTS
00001294                           435      
00001294                           436  enter: 
00001294  43F8 02E5                437      LEA return, A1
00001298  4EB8 1282                438      JSR print
0000129C  4E75                     439      RTS
0000129E                           440      
0000129E                           441  print_nop
0000129E  43F8 0261                442      LEA nop_ins, A1
000012A2  4EB8 128C                443      JSR println
000012A6  60D8                     444      BRA out
000012A8                           445  
000012A8                           446  print_rts
000012A8  43F8 0265                447      LEA rts_ins, A1
000012AC  4EB8 128C                448      JSR println
000012B0  60CE                     449      BRA out
000012B2                           450      
000012B2                           451  print_moveq
000012B2  43F8 026E                452      lea moveq_ins, A1   *print MOVEQ
000012B6  4EB8 1282                453      jsr print
000012BA  3602                     454      move.w  D2,D3
000012BC  C67C 00FF                455      and.w   #$00FF,D3   * Figure out the immediate address value
000012C0  43F8 02DF                456      lea pound,A1        *print '#'
000012C4  4EB8 1282                457      jsr print
000012C8  43F8 02EF                458      LEA dollar, A1
000012CC  4EB8 1282                459      JSR print
000012D0  3203                     460      move.w  D3,D1
000012D2  3602                     461      MOVE.W D2,D3
000012D4  343C 0010                462      MOVE.W #16, D2
000012D8  103C 000F                463      move.b  #15,D0
000012DC  4E4F                     464      trap    #15         *print immediate address value
000012DE  43F8 02DC                465      lea comma,A1        *print comma
000012E2  4EB8 1282                466      jsr print
000012E6  3403                     467      MOVE.W D3, D2
000012E8  3A02                     468      MOVE.W D2, D5
000012EA  4EB9 00001976            469      JSR data_reg_sr     *figure out data address
000012F0  4EB8 1294                470      jsr enter           *print out enter
000012F4  608A                     471      bra out
000012F6                           472      
000012F6                           473  print_move_movea
000012F6  3602                     474      MOVE.W D2, D3       
000012F8  C67C 01C0                475      AND.W #$01C0, D3
000012FC  B67C 0040                476      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001300  6700 000E                477      BEQ move_a
00001304  43F8 0269                478      LEA move_ins, A1 *print Instruction 
00001308  4EB8 1282                479      JSR print
0000130C  6000 000A                480      BRA m_size
00001310                           481  move_a          *if instruction is MOVEA
00001310  43F8 027B                482      LEA movea_ins, A1
00001314  4EB8 1282                483      JSR print
00001318                           484  m_size              *determine instruction size
00001318  4EB9 00001790            485      JSR move_size
0000131E  4EB9 000017F2            486      JSR addr        *determine the source address
00001324  43F8 02DC                487      LEA comma, A1   *print comma
00001328  4EB8 1282                488      JSR print
0000132C  4207                     489      CLR.B D7
0000132E  1E3C 0001                490      MOVE.B #1, D7   *determine destination address
00001332  4EB9 000017F2            491      JSR addr
00001338  4EB8 1294                492      JSR enter       *print enter
0000133C  6000 FF42                493      BRA out
00001340                           494      
00001340                           495  print_add_adda
00001340  3602                     496      MOVE.W D2, D3   
00001342  C63C 00C0                497      AND.B #$C0, D3
00001346  B63C 00C0                498      CMP.B #$C0, D3      *determine if ADD or ADDA
0000134A  6700 0052                499      BEQ add_a
0000134E                           500      *if just ADD then print instruction
0000134E  43F8 0281                501      LEA add_ins, A1
00001352  4EB8 1282                502      JSR print
00001356                           503      *print instruction size for ADD
00001356  4EB9 000017D6            504      JSR size
0000135C                           505      *determine direction of ADD, Dn -> EA or EA -> Dn
0000135C  3602                     506      MOVE.W D2,D3
0000135E  C67C 0100                507      AND.W #$0100, D3
00001362  B67C 0100                508      CMP.W #$0100, D3
00001366  6700 001C                509      BEQ ea_dest_add 
0000136A  4EB9 000017F2            510      JSR addr            *if Direction bit is 0
00001370  43F8 02DC                511      LEA comma, A1
00001374  4EB8 1282                512      JSR print
00001378  3A02                     513      MOVE.W D2,D5
0000137A  4EB9 00001976            514      JSR data_reg_sr
00001380  6000 005E                515      BRA end_add
00001384                           516  ea_dest_add             *if Direction bit is 1
00001384  3A02                     517      MOVE.W D2,D5
00001386  4EB9 00001976            518      JSR data_reg_sr
0000138C  43F8 02DC                519      LEA comma, A1
00001390  4EB8 1282                520      JSR print
00001394  4EB9 000017F2            521      JSR addr
0000139A  6000 0044                522      BRA end_add
0000139E                           523  add_a                   *if instruction is ADDA
0000139E  43F8 0285                524      LEA adda_ins, A1
000013A2  4EB8 1282                525      JSR print
000013A6                           526      *print instruction size for ADDA (either W or L)
000013A6  3602                     527      MOVE.W D2,D3
000013A8  C67C 0100                528      AND.W #$0100, D3
000013AC  B67C 0100                529      CMP.W #$0100, D3
000013B0  6700 000E                530      BEQ adda_size
000013B4  43F8 0259                531      LEA word, A1
000013B8  4EB8 1282                532      JSR print
000013BC  6000 000E                533      BRA next_add
000013C0                           534  adda_size
000013C0  43F8 0255                535      LEA long,A1
000013C4  4EB8 1282                536      JSR print
000013C8  183C 0080                537      MOVE.B #$80, D4
000013CC                           538  next_add                *print effective address for ADDA
000013CC  4EB9 000017F2            539      JSR addr            
000013D2  43F8 02DC                540      LEA comma, A1
000013D6  4EB8 1282                541      JSR print
000013DA  4EB9 0000198E            542      JSR add_reg_sr
000013E0                           543  end_add                 *complete instruction printing by printing enter
000013E0  4EB8 1294                544      JSR enter
000013E4  6000 FE9A                545      BRA out
000013E8                           546  
000013E8                           547  print_sub_and_or
000013E8                           548      *determine if instruction is SUB, AND, or OR.
000013E8  3602                     549      MOVE.W D2, D3
000013EA  C67C F0C0                550      AND.W #$F0C0, D3
000013EE  B67C C0C0                551      CMP.W #$C0C0, D3
000013F2  6700 0090                552      BEQ mul_div
000013F6  B67C 80C0                553      CMP.W #$80C0, D3
000013FA  6700 0088                554      BEQ mul_div
000013FE  C67C F000                555      AND.W #$F000,D3
00001402  B67C 8000                556      CMP.W #$8000, D3
00001406  6700 0028                557      BEQ print_or
0000140A  B67C 9000                558      CMP.W #$9000, D3
0000140E  6700 000A                559      BEQ print_sub
00001412  43F8 0292                560      LEA and_ins, A1
00001416  6000 001C                561      BRA print_instruction
0000141A                           562  print_sub
0000141A  3602                     563      MOVE.W D2, D3
0000141C  C67C 00C0                564      AND.W #$00C0, D3
00001420  B63C 00C0                565      CMP.B #$C0, D3
00001424  6700 FE3E                566      BEQ invalid
00001428  43F8 0296                567      LEA sub_ins, A1
0000142C  6000 0006                568      BRA print_instruction
00001430                           569  print_or
00001430  43F8 028F                570      LEA or_ins, A1
00001434                           571  print_instruction       *print correct instruction
00001434  4EB8 1282                572      JSR print
00001438  4EB9 000017D6            573      JSR size            *print instruction size
0000143E  3602                     574      MOVE.W D2,D3
00001440                           575  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001440  C67C 0100                576      AND.W #$0100, D3
00001444  B67C 0100                577      CMP.W #$0100, D3
00001448  6700 001C                578      BEQ ea_dest_sub_and_or
0000144C  4EB9 000017F2            579      JSR addr            *if Direction bit is 0
00001452  43F8 02DC                580      LEA comma, A1
00001456  4EB8 1282                581      JSR print
0000145A  3A02                     582      MOVE.W D2,D5
0000145C  4EB9 00001976            583      JSR data_reg_sr
00001462  6000 FF7C                584      BRA end_add
00001466                           585  ea_dest_sub_and_or      *if Direction bit is 1
00001466  3A02                     586      MOVE.W D2,D5
00001468  4EB9 00001976            587      JSR data_reg_sr
0000146E  43F8 02DC                588      LEA comma, A1
00001472  4EB8 1282                589      JSR print
00001476  4EB9 000017F2            590      JSR addr
0000147C                           591      *complete instruction printing by printing enter
0000147C  4EB8 1294                592      JSR enter
00001480  6000 FDFE                593      BRA out
00001484                           594      
00001484                           595  mul_div             *deal with MULU and DIVU cases
00001484  4283                     596      CLR.L D3
00001486  3602                     597      MOVE.W D2,D3
00001488  C67C 00FF                598      AND.W #$00FF, D3
0000148C  B6BC 000000F8            599      CMP.L #$00F8, D3
00001492  6D00 FDD0                600      BLT invalid
00001496  B6BC 000000F9            601      CMP.L #$00F9, D3
0000149C  6700 0008                602      BEQ mul_div_long
000014A0  544C                     603      ADDA.W #2,A4
000014A2  6000 FDC0                604      BRA invalid
000014A6                           605  mul_div_long
000014A6  584C                     606      ADDA.W #4,A4
000014A8  6000 FDBA                607      BRA invalid
000014AC                           608      
000014AC                           609  print_ls_as_ro
000014AC                           610      *figure out if shift or rotation are memory or register based               
000014AC  3602                     611      MOVE.W D2, D3
000014AE  C63C 00C0                612      AND.B #$C0, D3
000014B2  B63C 00C0                613      CMP.B #$C0, D3
000014B6  6700 0072                614      BEQ ls_as_ro_mem
000014BA  3602                     615      MOVE.W D2, D3
000014BC  E60B                     616      LSR.B #3, D3
000014BE                           617      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000014BE  4EB9 0000175E            618      JSR print_correct_shift_rotation
000014C4  4EB9 0000173C            619      JSR print_direction     *print direction
000014CA  4EB9 000017D6            620      JSR size                *print size
000014D0  3602                     621      MOVE.W D2, D3
000014D2  C63C 0020                622      AND.B #$20,D3
000014D6  B63C 0020                623      CMP.B #$20, D3
000014DA                           624      *determine if instruction is using immediate address or register
000014DA  6700 0030                625      BEQ ls_as_ro_reg     
000014DE  43F8 02DF                626      LEA pound, A1        *if immediate address print '#'
000014E2  4EB8 1282                627      JSR print
000014E6                           628      *print immediate address rotation value
000014E6  3C02                     629      MOVE.W D2,D6
000014E8  EF5E                     630      ROL.W #7,D6
000014EA  CC7C 0007                631      AND.W #$0007, D6
000014EE  43F8 02EF                632      LEA dollar, A1
000014F2  4EB8 1282                633      JSR print
000014F6  4281                     634      CLR.L D1
000014F8  3206                     635      MOVE.W D6, D1
000014FA  3602                     636      MOVE.W D2, D3
000014FC  143C 0010                637      MOVE.B #16, D2
00001500  103C 000F                638      MOVE.B #15, D0
00001504  4E4F                     639      TRAP #15
00001506  3403                     640      MOVE.W D3,D2
00001508  6000 000A                641      BRA continue_instruction_ls_as_ro
0000150C                           642  ls_as_ro_reg            *if instruction is using register to shift values in another register
0000150C  3A02                     643      MOVE.W D2,D5
0000150E  4EB9 00001976            644      JSR data_reg_sr
00001514                           645  continue_instruction_ls_as_ro *complete instrcuction
00001514  43F8 02DC                646      LEA comma, A1       *print comma
00001518  4EB8 1282                647      JSR print
0000151C  3A02                     648      MOVE.W D2,D5
0000151E  EE5D                     649      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001520  4EB9 00001976            650      JSR data_reg_sr     *determine destination data register to perform instruction on
00001526  6000 0030                651      BRA next_ls_as_ro   *finish printing instruction
0000152A                           652  ls_as_ro_mem            *check if immediate address is being shifted or rotated
0000152A  3602                     653      MOVE.W D2, D3
0000152C  C63C 003F                654      AND.B #$3F, D3
00001530  B63C 003C                655      CMP.B #$3C, D3
00001534  6700 FD2E                656      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001538                           657      *if not immediate adress print normally 
00001538  3602                     658      MOVE.W D2, D3
0000153A  EF5B                     659      ROL.W #7, D3    
0000153C  4EB9 0000175E            660      JSR print_correct_shift_rotation
00001542  3602                     661      MOVE.W D2,D3
00001544  4EB9 0000173C            662      JSR print_direction
0000154A  43F8 0259                663      LEA word, A1
0000154E  4EB8 1282                664      JSR print
00001552  4EB9 000017F2            665      JSR addr
00001558                           666  next_ls_as_ro
00001558  4EB8 1294                667      JSR enter
0000155C  6000 FD22                668      BRA out
00001560                           669      
00001560                           670  print_not
00001560  43F8 02A3                671      LEA not_ins, A1 *print instruction
00001564  4EB8 1282                672      JSR print
00001568  4EB9 000017D6            673      JSR size
0000156E  3602                     674      MOVE.W D2, D3
00001570  C63C 003F                675      AND.B #$3F, D3
00001574  B63C 003C                676      CMP.B #$3C, D3
00001578  6700 FCEA                677      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
0000157C  4EB9 000017F2            678      JSR addr
00001582  4EB8 1294                679      JSR enter
00001586  6000 FCF8                680      BRA out
0000158A                           681  
0000158A                           682  print_jsr
0000158A  43F8 02A7                683      LEA jsr_ins, A1 *print instruction
0000158E  4EB8 1282                684      JSR print
00001592  4EB9 000017F2            685      JSR addr    *print address
00001598  4EB8 1294                686      JSR enter   *print enter (next line)
0000159C  6000 FCE2                687      BRA out
000015A0                           688  
000015A0                           689  print_lea
000015A0  43F8 02AC                690      LEA lea_ins, A1 *print instruction
000015A4  4EB8 1282                691      JSR print   
000015A8  4EB9 000017F2            692      JSR addr    *print address
000015AE  43F8 02DC                693      LEA comma, A1   *print comma
000015B2  4EB8 1282                694      JSR print
000015B6  4EB9 0000198E            695      JSR add_reg_sr *print destination address register
000015BC  4EB8 1294                696      JSR enter
000015C0  6000 FCBE                697      BRA out
000015C4                           698  
000015C4                           699  print_addq
000015C4  43F8 028A                700      LEA addq_ins, A1    *print instruction
000015C8  4EB8 1282                701      JSR print
000015CC  4EB9 000017D6            702      JSR size            *print instruction size
000015D2  43F8 02DF                703      LEA pound, A1
000015D6  4EB8 1282                704      JSR print           *print '#' for immediate addressing
000015DA  3C02                     705      MOVE.W D2,D6
000015DC  EF5E                     706      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000015DE  CC7C 0007                707      AND.W #$0007, D6
000015E2  4EB9 0000196A            708      JSR Xn
000015E8  43F8 02DC                709      LEA comma, A1       *print comma
000015EC  4EB8 1282                710      JSR print
000015F0  4EB9 000017F2            711      JSR addr            *print destination address
000015F6  4EB8 1294                712      JSR enter
000015FA  6000 FC84                713      BRA out
000015FE                           714  
000015FE                           715  print_bra_bcc           *needs comments
000015FE  3602                     716      MOVE.W D2,D3
00001600  C67C 0F00                717      AND.W #$0F00, D3
00001604  B67C 0000                718      CMP.W #$0000, D3
00001608  6700 001E                719      BEQ print_bra
0000160C  B67C 0700                720      CMP.W #$0700, D3
00001610  6700 0022                721      BEQ print_beq
00001614  B67C 0E00                722      CMP.W #$0E00, D3
00001618  6700 0032                723      BEQ print_bgt
0000161C  B67C 0F00                724      CMP.W #$0F00, D3
00001620  6700 001E                725      BEQ print_ble
00001624  6000 FC3E                726      BRA invalid
00001628                           727  print_bra
00001628  43F8 02C2                728      LEA bra_ins, A1
0000162C  4EB8 1282                729      JSR print
00001630  6000 0022                730      BRA next_bra_bcc
00001634                           731  print_beq
00001634  43F8 02BE                732      LEA beq_ins, A1
00001638  4EB8 1282                733      JSR print
0000163C  6000 0016                734      BRA next_bra_bcc
00001640                           735  print_ble
00001640  43F8 02BA                736      LEA ble_ins, A1
00001644  4EB8 1282                737      JSR print
00001648  6000 000A                738      BRA next_bra_bcc
0000164C                           739  print_bgt
0000164C  43F8 02B6                740      LEA bgt_ins, A1
00001650  4EB8 1282                741      JSR print
00001654                           742  next_bra_bcc
00001654  3602                     743      MOVE.W D2, D3
00001656  C67C 00FF                744      AND.W #$00FF, D3
0000165A  B67C 0000                745      CMP.W #$0000, D3
0000165E  6700 0026                746      BEQ check_word
00001662  43F8 025D                747      LEA byte, A1
00001666  4EB8 1282                748      JSR print
0000166A  43F8 02EF                749      LEA dollar, A1
0000166E  4EB8 1282                750      JSR print
00001672  3203                     751      MOVE.W D3, D1
00001674  3602                     752      MOVE.W D2, D3
00001676  343C 0010                753      MOVE.W #16, D2
0000167A  303C 000F                754      MOVE.W #15,D0
0000167E  4E4F                     755      trap #15            *print immediate address value
00001680  3403                     756      MOVE.W D3, D2
00001682  6000 0024                757      BRA end_bra_bcc
00001686                           758  check_word
00001686  43F8 0259                759      LEA word, A1
0000168A  4EB8 1282                760      JSR print
0000168E  43F8 02EF                761      LEA dollar, A1
00001692  4EB8 1282                762      JSR print
00001696  544C                     763      ADDA.W #2,A4        *update current address
00001698  3214                     764      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000169A  3602                     765      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000169C  343C 0010                766      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
000016A0  103C 000F                767      MOVE.B #15, D0      *use trap instruction that allows use of base 16
000016A4  4E4F                     768      TRAP #15
000016A6  3403                     769      MOVE.W D3,D2        *copy opcode back to register D2
000016A8                           770  end_bra_bcc
000016A8  4EB8 1294                771      JSR enter
000016AC  6000 FBD2                772      BRA out
000016B0                           773  
000016B0                           774  print_movem         *needs comments
000016B0  43F8 0275                775      LEA movem_ins, A1
000016B4  4EB8 1282                776      JSR print
000016B8  3602                     777      MOVE.W D2,D3
000016BA  C67C 0040                778      AND.W #$0040,D3
000016BE  B67C 0040                779      CMP.W #$0040,D3
000016C2  6700 000E                780      BEQ movem_long
000016C6  43F8 0259                781      LEA word, A1
000016CA  4EB8 1282                782      JSR print
000016CE  6000 000A                783      BRA movem_direction
000016D2                           784  movem_long
000016D2  43F8 0255                785      LEA long, A1
000016D6  4EB8 1282                786      JSR print
000016DA                           787  movem_direction
000016DA  3602                     788      MOVE.W D2,D3
000016DC  C67C 0400                789      AND.W #$0400,D3
000016E0  B67C 0400                790      CMP.W #$0400,D3
000016E4                           791      
000016E4  6700 001A                792      BEQ mem_to_reg
000016E8  4EB9 0000171C            793      JSR movem_check_pre_post
000016EE  43F8 02DC                794      LEA comma, A1
000016F2  4EB8 1282                795      JSR print
000016F6  4EB9 000017F2            796      JSR addr
000016FC  6000 0016                797      BRA end_movem
00001700                           798  mem_to_reg
00001700  4EB9 000017F2            799      JSR addr
00001706  43F8 02DC                800      LEA comma, A1
0000170A  4EB8 1282                801      JSR print
0000170E  4EB9 0000171C            802      JSR movem_check_pre_post
00001714                           803  end_movem
00001714  4EB8 1294                804      JSR enter
00001718  6000 FB66                805      BRA out
0000171C                           806      
0000171C                           807  movem_check_pre_post:
0000171C  3602                     808      MOVE.W D2, D3
0000171E  C67C 0038                809      AND.W #$0038, D3
00001722  B67C 0020                810      CMP.W #$0020, D3
00001726  6700 000C                811      BEQ movem_check_pre
0000172A  4EB9 00001A56            812      JSR movem_postinc
00001730  6000 0008                813      BRA movem_check_done
00001734                           814  movem_check_pre
00001734  4EB9 000019A6            815      JSR movem_predec
0000173A                           816  movem_check_done
0000173A  4E75                     817      RTS
0000173C                           818  
0000173C                           819  print_direction:
0000173C                           820  *print correct direction given direction bit
0000173C  C67C 0100                821      AND.W #$0100, D3
00001740  B67C 0100                822      CMP.W #$0100, D3
00001744  6700 000E                823      BEQ print_left  *print left
00001748  43F8 02C6                824      LEA right, A1
0000174C  4EB8 1282                825      JSR print
00001750  6000 FB2E                826      BRA out
00001754                           827  print_left
00001754  43F8 02C8                828      LEA left, A1
00001758  4EB8 1282                829      JSR print *print right
0000175C  4E75                     830      RTS
0000175E                           831      
0000175E                           832  print_correct_shift_rotation:
0000175E                           833  *determine if instruction is logical, arithmetic, or rotation 
0000175E  C63C 0003                834      AND.B #$03, D3
00001762  B63C 0000                835      CMP.B #$00, D3
00001766  6700 0016                836      BEQ print_as
0000176A  B63C 0001                837      CMP.B #$01, D3
0000176E  6700 0016                838      BEQ print_ls
00001772  B63C 0003                839      CMP.B #$03, D3
00001776  43F8 02A0                840      LEA ro_ins, A1  print rotation
0000177A  6000 000E                841      BRA print_it
0000177E                           842  print_as
0000177E  43F8 029D                843      LEA as_ins, A1  print arithmetic shift
00001782  6000 0006                844      BRA print_it
00001786                           845  print_ls
00001786  43F8 029A                846      LEA ls_ins, A1 print logical shift
0000178A                           847  print_it
0000178A  4EB8 1282                848      JSR print
0000178E  4E75                     849      RTS
00001790                           850  * --------- End Print Instruction ----------*
00001790                           851  
00001790                           852  * ------- Instruction sizes ---------*
00001790                           853  
00001790                           854  move_size:  *print size for MOVE and MOVEA instruction
00001790  4284                     855      CLR.L D4
00001792  3802                     856      MOVE.W D2, D4
00001794  C87C 3000                857      AND.W #$3000, D4
00001798  B87C 1000                858      CMP.W #$1000, D4
0000179C  6700 0014                859      BEQ print_b
000017A0  B87C 3000                860      CMP.W #$3000, D4
000017A4  6700 0018                861      BEQ print_w
000017A8  B87C 2000                862      CMP.W #$2000, D4
000017AC  6700 001C                863      BEQ print_l
000017B0  4E75                     864      RTS
000017B2                           865      
000017B2                           866  print_b     *print '.B'
000017B2  43F8 025D                867      LEA byte, A1
000017B6  4EB8 1282                868      JSR print
000017BA  6000 FAC4                869      BRA out
000017BE                           870      
000017BE                           871  print_w     *print '.W'
000017BE  43F8 0259                872      LEA word, A1
000017C2  4EB8 1282                873      JSR print
000017C6  6000 FAB8                874      BRA out
000017CA                           875      
000017CA                           876  print_l:    *print '.L'
000017CA  43F8 0255                877      LEA long, A1
000017CE  4EB8 1282                878      JSR print
000017D2  6000 FAAC                879      BRA out
000017D6                           880  
000017D6                           881  size:       *print size for non "move" instructions
000017D6  4284                     882      CLR.L D4
000017D8  1802                     883      MOVE.B D2,D4
000017DA  C83C 00C0                884      AND.B #$C0, D4
000017DE  B83C 0000                885      CMP.B #$00, D4
000017E2  67CE                     886      BEQ print_b
000017E4  B83C 0040                887      CMP.B #$40,D4
000017E8  67D4                     888      BEQ print_w
000017EA  B83C 0080                889      CMP.B #$80, D4
000017EE  67DA                     890      BEQ print_l
000017F0  4E75                     891      RTS
000017F2                           892      
000017F2                           893  * ------- End Instruction sizes ---------*
000017F2                           894  
000017F2                           895  * ------- Effective Address -------*
000017F2                           896  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000017F2  3A02                     897      MOVE.W D2, D5
000017F4  3C02                     898      MOVE.W D2, D6               
000017F6  BE3C 0001                899      CMP.B #1, D7
000017FA  6700 003A                900      BEQ destination *check if evaluating destination address (used for MOVE)
000017FE                           901  cont
000017FE  CC3C 0038                902      AND.B #$38, D6
00001802  BC3C 0000                903      CMP.B #0, D6
00001806  6700 0038                904      BEQ data_reg        *check if EA mode is data register
0000180A  BC3C 0008                905      CMP.B #$08, D6
0000180E  6700 0048                906      BEQ add_reg         *check if EA mode is address register
00001812  BC3C 0010                907      CMP.B #$10, D6
00001816  6700 0058                908      BEQ add_indirect    *check if EA mode is address indirect
0000181A  BC3C 0018                909      CMP.B #$18, D6
0000181E  6700 0070                910      BEQ post_increment  *check if EA mode is post increment
00001822  BC3C 0020                911      CMP.B #$20, D6
00001826  6700 0088                912      BEQ pre_decrement   *check if EA mode is pre_decrement
0000182A  BC3C 0038                913      CMP.B #$38, D6
0000182E  6700 00A0                914      BEQ absolute_or_immediate
00001832  6000 FA4C                915      BRA out *needs Immediate, Abs Long, and Abs Word
00001836                           916  destination     *perform correct rotation to retrieve destination address
00001836  3C05                     917      MOVE.W D5,D6
00001838  EF5D                     918      ROL.W #7,D5
0000183A  E64E                     919      LSR.W #3,D6
0000183C  60C0                     920      BRA cont
0000183E  4E75                     921      RTS
00001840                           922  
00001840                           923  data_reg    *used with addr sub routine
00001840  3C05                     924      MOVE.W D5,D6    
00001842  CC3C 0007                925      AND.B #$07, D6  
00001846  43F8 02CA                926      LEA D_reg, A1   
0000184A  4EB8 1282                927      JSR print
0000184E  4EB9 0000196A            928      JSR Xn
00001854  6000 FA2A                929      BRA out
00001858                           930  
00001858                           931  add_reg     *used with addr sub routine
00001858  3C05                     932      MOVE.W D5,D6    
0000185A  CC3C 0007                933      AND.B #$07, D6
0000185E  43F8 02CC                934      LEA A_reg, A1   
00001862  4EB8 1282                935      JSR print
00001866  4EB9 0000196A            936      JSR Xn
0000186C  6000 FA12                937      BRA out
00001870                           938      
00001870                           939  add_indirect    *used with addr sub routine
00001870  3C05                     940      MOVE.W D5,D6    
00001872  CC3C 0007                941      AND.B #$07, D6
00001876  43F8 02CE                942      LEA open_paran, A1  
0000187A  4EB8 1282                943      JSR print
0000187E  4EB9 0000196A            944      JSR Xn
00001884  43F8 02D1                945      LEA close_paran, A1 
00001888  4EB8 1282                946      JSR print
0000188C  6000 F9F2                947      BRA out
00001890                           948      
00001890                           949  post_increment  *used with addr sub routine
00001890  3C05                     950      MOVE.W D5,D6    
00001892  CC3C 0007                951      AND.B #$07, D6
00001896  43F8 02CE                952      LEA open_paran, A1  
0000189A  4EB8 1282                953      JSR print
0000189E  4EB9 0000196A            954      JSR Xn
000018A4  43F8 02D3                955      LEA post_inc, A1    
000018A8  4EB8 1282                956      JSR print
000018AC  6000 F9D2                957      BRA out
000018B0                           958      
000018B0                           959  pre_decrement   *used with addr sub routine
000018B0  3C05                     960      MOVE.W D5,D6    
000018B2  CC3C 0007                961      AND.B #$07, D6
000018B6  43F8 02D6                962      LEA pre_dec, A1 
000018BA  4EB8 1282                963      JSR print
000018BE  4EB9 0000196A            964      JSR Xn
000018C4  43F8 02D1                965      LEA close_paran, A1 
000018C8  4EB8 1282                966      JSR print
000018CC  6000 F9B2                967      BRA out
000018D0                           968  
000018D0                           969  absolute_or_immediate *check if EA is immediate or absolute address
000018D0  3C05                     970      MOVE.W D5,D6    
000018D2  CC3C 0007                971      AND.B #$07, D6
000018D6  BC3C 0000                972      CMP.B #$00, D6
000018DA  6700 0054                973      BEQ w_imm
000018DE  BC3C 0001                974      CMP.B #$01, D6
000018E2  6700 0068                975      BEQ l_imm
000018E6  BC3C 0004                976      CMP.B #04, D6
000018EA  6700 0002                977      BEQ immediate
000018EE                           978      
000018EE                           979  immediate
000018EE  43F8 02DF                980      LEA pound, A1
000018F2  4EB8 1282                981      JSR print
000018F6  B4BC 00004000            982      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
000018FC  6D00 0016                983      BLT move_movea      *check if instruction is move or movea
00001900  B8BC 00000040            984      CMP.L #$0040, D4        *if not move or movea
00001906  6F00 0028                985      BLE w_imm           *byte and word check the next 2 addresses in mem
0000190A  B8BC 00000080            986      CMP.L #$0080, D4
00001910  6700 003A                987      BEQ l_imm           *long checks the next 4 addresses in mem
00001914                           988  move_movea              *similar comparisons, but for different bits in OPCODE
00001914  B87C 1000                989      CMP.W #$1000, D4
00001918  6700 0016                990      BEQ w_imm
0000191C  B87C 3000                991      CMP.W #$3000, D4
00001920  6700 000E                992      BEQ w_imm
00001924  B87C 2000                993      CMP.W #$2000, D4
00001928  6700 0022                994      BEQ l_imm
0000192C                           995  imm_complete
0000192C  6000 F952                996      BRA out
00001930                           997      
00001930                           998  w_imm
00001930  43F8 02EF                999      LEA dollar, A1      *print '$'
00001934  4EB8 1282               1000      JSR print
00001938  544C                    1001      ADDA.W #2,A4        *update current address
0000193A  3214                    1002      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000193C  3602                    1003      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000193E  343C 0010               1004      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001942  103C 000F               1005      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001946  4E4F                    1006      TRAP #15
00001948  3403                    1007      MOVE.W D3,D2        *copy opcode back to register D2
0000194A  60E0                    1008      BRA imm_complete    *exit addr subroutine
0000194C                          1009      
0000194C                          1010  l_imm
0000194C  43F8 02EF               1011      LEA dollar, A1      *print '$'
00001950  4EB8 1282               1012      JSR print
00001954  544C                    1013      ADDA.W  #2,A4       *update current address
00001956  2214                    1014      MOVE.L (A4),D1      *retrieve long data stored in the new current address
00001958  3602                    1015      MOVE.W D2, D3
0000195A  343C 0010               1016      MOVE.W #16, D2
0000195E  103C 000F               1017      MOVE.B #15, D0
00001962  4E4F                    1018      TRAP #15
00001964  3403                    1019      MOVE.W D3,D2
00001966  544C                    1020      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
00001968  60C2                    1021      BRA imm_complete    *exit addr subroutine
0000196A                          1022  
0000196A                          1023  Xn:                     *retieve signed decimal value of data stored in register D6
0000196A  4281                    1024      CLR.L D1
0000196C  1206                    1025      MOVE.B D6,D1
0000196E  103C 0003               1026      MOVE.B #3, D0
00001972  4E4F                    1027      TRAP #15
00001974  4E75                    1028      RTS
00001976                          1029  
00001976                          1030  data_reg_sr:    *use if dealing with Dn only
00001976  4286                    1031      CLR.L D6
00001978  3C05                    1032      MOVE.W D5,D6
0000197A  EF5E                    1033      ROL.W #7,D6
0000197C  CC3C 0007               1034      AND.B #$07, D6  
00001980  43F8 02CA               1035      LEA D_reg, A1   
00001984  4EB8 1282               1036      JSR print
00001988  4EB8 196A               1037      JSR Xn
0000198C  4E75                    1038      RTS
0000198E                          1039      
0000198E                          1040  add_reg_sr:     *use if dealing with An only
0000198E  4286                    1041      CLR.L D6
00001990  3C02                    1042      MOVE.W D2,D6
00001992  EF5E                    1043      ROL.W #7,D6
00001994  CC3C 0007               1044      AND.B #$07, D6  
00001998  43F8 02CC               1045      LEA A_reg, A1   
0000199C  4EB8 1282               1046      JSR print
000019A0  4EB8 196A               1047      JSR Xn
000019A4  4E75                    1048      RTS
000019A6                          1049      
000019A6                          1050  movem_predec:           *needs to be worked on
000019A6  4285                    1051      CLR.L D5
000019A8  544C                    1052      ADDA.W  #2,A4       *update current address
000019AA  3A14                    1053      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019AC  3C05                    1054      MOVE.W D5,D6
000019AE  4281                    1055      CLR.L D1
000019B0  4287                    1056      CLR.L D7
000019B2  BA3C 0000               1057      CMP.B #$00, D5
000019B6  6700 005E               1058      BEQ predec_skip_to_d
000019BA  E14E                    1059      LSL #8, D6
000019BC                          1060  predec_loop_a   
000019BC  E34E                    1061      LSL #1, D6
000019BE  6400 0006               1062      BCC predec_inc_loop_a
000019C2  6000 000E               1063      BRA predec_check_first_a
000019C6                          1064  predec_inc_loop_a
000019C6  5201                    1065      ADD.B #1, D1
000019C8  B23C 0008               1066      CMP.B #8, D1
000019CC  66EE                    1067      BNE predec_loop_a
000019CE  6000 0038               1068      BRA predec_loop_a_done  
000019D2                          1069  predec_check_first_a
000019D2  BE3C 0000               1070      CMP.B #0, D7
000019D6  6700 000A               1071      BEQ predec_first_a
000019DA  43F8 02E3               1072      LEA slash, A1
000019DE  4EB8 1282               1073      JSR print
000019E2                          1074  predec_first_a
000019E2  43F8 02CC               1075      LEA A_reg, A1
000019E6  4EB8 1282               1076      JSR print
000019EA  103C 0003               1077      MOVE.B #3, D0
000019EE  4E4F                    1078      TRAP #15
000019F0  5201                    1079      ADD.B #1, D1
000019F2  5207                    1080      ADD.B #1, D7
000019F4  B23C 0008               1081      CMP.B #8, D1
000019F8  66C2                    1082      BNE predec_loop_a
000019FA  3C05                    1083      MOVE.W D5,D6
000019FC  CC7C FF00               1084      AND.W #$FF00, D6
00001A00  BC7C 0000               1085      CMP.W #$00, D6
00001A04  6700 004E               1086      BEQ end_movem_predec
00001A08                          1087  predec_loop_a_done
00001A08  3C05                    1088      MOVE.W D5,D6
00001A0A  43F8 02E3               1089      LEA slash, A1
00001A0E  4EB8 1282               1090      JSR print
00001A12  4281                    1091      CLR.L D1
00001A14  4287                    1092      CLR.L D7
00001A16                          1093  predec_skip_to_d
00001A16                          1094  predec_loop_d   
00001A16  E34E                    1095      LSL #1, D6
00001A18  6400 0006               1096      BCC predec_inc_loop_d
00001A1C  6000 000E               1097      BRA predec_check_first_d
00001A20                          1098  predec_inc_loop_d
00001A20  5201                    1099      ADD.B #1, D1
00001A22  B23C 0008               1100      CMP.B #8, D1
00001A26  66EE                    1101      BNE predec_loop_d   
00001A28  6000 002A               1102      BRA end_movem_predec
00001A2C                          1103  predec_check_first_d
00001A2C  BE3C 0000               1104      CMP.B #0, D7
00001A30  6700 000A               1105      BEQ predec_first_d
00001A34  43F8 02E3               1106      LEA slash, A1
00001A38  4EB8 1282               1107      JSR print
00001A3C                          1108  predec_first_d
00001A3C  43F8 02CA               1109      LEA D_reg, A1
00001A40  4EB8 1282               1110      JSR print
00001A44  103C 0003               1111      MOVE.B #3, D0
00001A48  4E4F                    1112      TRAP #15
00001A4A  5201                    1113      ADD.B #1, D1
00001A4C  5207                    1114      ADD.B #1, D7
00001A4E  B23C 0008               1115      CMP.B #8, D1
00001A52  66C2                    1116      BNE predec_loop_d
00001A54                          1117  end_movem_predec
00001A54  4E75                    1118      RTS
00001A56                          1119      
00001A56                          1120  movem_postinc:          *needs to be worked on
00001A56  4285                    1121      CLR.L D5
00001A58  544C                    1122      ADDA.W  #2,A4       *update current address
00001A5A  3A14                    1123      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A5C  3C05                    1124      MOVE.W D5,D6
00001A5E  4281                    1125      CLR.L D1
00001A60  4287                    1126      CLR.L D7
00001A62  3C05                    1127      MOVE.W D5,D6
00001A64  CC7C FF00               1128      AND.W #$FF00, D6
00001A68  BC7C 0000               1129      CMP.W #$00, D6
00001A6C  6700 0058               1130      BEQ postinc_skip_to_d
00001A70  E04E                    1131      LSR #8, D6
00001A72                          1132  postinc_loop_a  
00001A72  E24E                    1133      LSR #1, D6
00001A74  6400 0006               1134      BCC postinc_inc_loop_a
00001A78  6000 000E               1135      BRA postinc_check_first_a
00001A7C                          1136  postinc_inc_loop_a
00001A7C  5201                    1137      ADD.B #1, D1
00001A7E  B23C 0008               1138      CMP.B #8, D1
00001A82  66EE                    1139      BNE postinc_loop_a
00001A84  6000 0032               1140      BRA postinc_loop_a_done 
00001A88                          1141  postinc_check_first_a
00001A88  BE3C 0000               1142      CMP.B #0, D7
00001A8C  6700 000A               1143      BEQ postinc_first_a
00001A90  43F8 02E3               1144      LEA slash, A1
00001A94  4EB8 1282               1145      JSR print
00001A98                          1146  postinc_first_a
00001A98  43F8 02CC               1147      LEA A_reg, A1
00001A9C  4EB8 1282               1148      JSR print
00001AA0  103C 0003               1149      MOVE.B #3, D0
00001AA4  4E4F                    1150      TRAP #15
00001AA6  5201                    1151      ADD.B #1, D1
00001AA8  5207                    1152      ADD.B #1, D7
00001AAA  B23C 0008               1153      CMP.B #8, D1
00001AAE  66C2                    1154      BNE postinc_loop_a
00001AB0  BA3C 0000               1155      CMP.B #$00, D5
00001AB4  6700 0050               1156      BEQ end_movem_postinc
00001AB8                          1157  postinc_loop_a_done
00001AB8  3C05                    1158      MOVE.W D5,D6
00001ABA  43F8 02E3               1159      LEA slash, A1
00001ABE  4EB8 1282               1160      JSR print
00001AC2  4281                    1161      CLR.L D1
00001AC4  4287                    1162      CLR.L D7
00001AC6                          1163  postinc_skip_to_d
00001AC6  3C05                    1164      MOVE.W D5,D6
00001AC8                          1165  postinc_loop_d  
00001AC8  E24E                    1166      LSR #1, D6
00001ACA  6400 0006               1167      BCC postinc_inc_loop_d
00001ACE  6000 000E               1168      BRA postinc_check_first_d
00001AD2                          1169  postinc_inc_loop_d
00001AD2  5201                    1170      ADD.B #1, D1
00001AD4  B23C 0008               1171      CMP.B #8, D1
00001AD8  66EE                    1172      BNE postinc_loop_d  
00001ADA  6000 002A               1173      BRA end_movem_postinc
00001ADE                          1174  postinc_check_first_d
00001ADE  BE3C 0000               1175      CMP.B #0, D7
00001AE2  6700 000A               1176      BEQ postinc_first_d
00001AE6  43F8 02E3               1177      LEA slash, A1
00001AEA  4EB8 1282               1178      JSR print
00001AEE                          1179  postinc_first_d
00001AEE  43F8 02CA               1180      LEA D_reg, A1
00001AF2  4EB8 1282               1181      JSR print
00001AF6  103C 0003               1182      MOVE.B #3, D0
00001AFA  4E4F                    1183      TRAP #15
00001AFC  5201                    1184      ADD.B #1, D1
00001AFE  5207                    1185      ADD.B #1, D7
00001B00  B23C 0008               1186      CMP.B #8, D1
00001B04  66C2                    1187      BNE postinc_loop_d
00001B06                          1188  end_movem_postinc
00001B06  4E75                    1189      RTS
00001B08                          1190  
00001B08                          1191  
00001B08                          1192  * ------- End Effective Address -------*
00001B08                          1193  
00001B08                          1194  * ----- Hex to ASCII & ASCII to HEX -----*
00001B08                          1195  
00001B08                          1196  ASCIItoHex:
00001B08  4EB9 00001B16           1197          jsr     ASCII2Hex_init  
00001B0E  4EB9 00001B1C           1198          jsr     conversion_loop
00001B14  4E75                    1199          rts                    
00001B16                          1200  
00001B16                          1201  ASCII2Hex_init:   
00001B16  143C 0000               1202          move.b  #0,D2       *set up counter    
00001B1A  4E75                    1203          rts         
00001B1C                          1204          
00001B1C                          1205  conversion_loop:            
00001B1C  5282                    1206          add.l   #1,D2       *increment counter
00001B1E  B4BC 00000009           1207          cmp.l   #9,D2       *ends at 9
00001B24  6700 004A               1208          BEQ     DONE        *branch when compare is true
00001B28  1819                    1209          move.b  (A1)+,D4    *Get first num
00001B2A                          1210          
00001B2A  B83C 0040               1211          cmp.b   #$40,D4        
00001B2E  6E00 000C               1212          bgt     Letters_Cap  
00001B32                          1213          
00001B32  B83C 0039               1214          cmp.b   #$39,D4
00001B36  6F00 0016               1215          BLE     Numbers      
00001B3A  4E75                    1216          rts
00001B3C                          1217          
00001B3C                          1218  Letters_Cap:      
00001B3C  B83C 0046               1219          cmp.b   #$46,D4          
00001B40  6E00 001E               1220          bgt     ERROR  
00001B44  0404 0037               1221          sub.b   #$37,D4     
00001B48  E986                    1222          asl.l   #4,D6       
00001B4A  DC84                    1223          add.l   D4,D6     
00001B4C  60CE                    1224          bra     conversion_loop 
00001B4E                          1225  Numbers:
00001B4E  B83C 0030               1226          cmp.b   #$30,D4         
00001B52  6D00 000C               1227          blt     ERROR        
00001B56  0404 0030               1228          sub.b   #$30,D4      
00001B5A  E986                    1229          asl.l   #4,D6        
00001B5C  DC84                    1230          add.l   D4,D6     
00001B5E  60BC                    1231          bra     conversion_loop
00001B60                          1232          
00001B60                          1233  ERROR:
00001B60  43F8 011E               1234          lea     ErrorMsg,A1    
00001B64  103C 000E               1235          move.b  #14,D0
00001B68  4E4F                    1236          trap    #15
00001B6A                          1237      
00001B6A  103C 0009               1238          move.b  #9,D0
00001B6E  4E4F                    1239          trap    #15
00001B70                          1240          
00001B70                          1241  DONE:
00001B70                          1242     
00001B70  4241                    1243          clr     D1
00001B72  4242                    1244          clr     D2
00001B74  4244                    1245          clr     D4
00001B76                          1246      
00001B76  43F8 014F               1247          lea     ASCIItoHexMsg,A1
00001B7A  103C 000E               1248          move.b  #14,D0
00001B7E  4E4F                    1249          trap    #15
00001B80                          1250  
00001B80  4E75                    1251          rts
00001B82                          1252          
00001B82                          1253  
00001B82                          1254          
00001B82                          1255  * -- End of Hex to ASCII & ASCII to HEX --*
00001B82                          1256  
00001B82                          1257  * Put program code here
00001B82                          1258  
00001B82  FFFF FFFF               1259      SIMHALT             ; halt simulator
00001B86                          1260  
00001B86                          1261  * Put variables and constants here
00001B86                          1262  
00001B86                          1263      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  18D0
ADDA_INS            285
ADDA_SIZE           13C0
ADDQ_INS            28A
ADDR                17F2
ADD_A               139E
ADD_INDIRECT        1870
ADD_INS             281
ADD_REG             1858
ADD_REG_SR          198E
ANDQ_INS            2B1
AND_INS             292
ASCII2HEX_INIT      1B16
ASCIITOHEX          1B08
ASCIITOHEXMSG       14F
AS_INS              29D
A_REG               2CC
BEQ_INS             2BE
BGT_INS             2B6
BLE_INS             2BA
BRA_INS             2C2
BYTE                25D
CHECK_WORD          1686
CLEARDONE           1106
CLEARSCREEN         10D8
CLEARSCREEN_40      10EE
CLEAR_REGISTERS     1044
CLOSE_PARAN         2D1
COMMA               2DC
CONT                17FE
CONTINUEORNOTMSG    20F
CONTINUE_INSTRUCTION_LS_AS_RO  1514
CONVERSION_LOOP     1B1C
CR                  D
CREATORS            1F
DASH                2E1
DATA                2E8
DATA_REG            1840
DATA_REG_SR         1976
DESTINATION         1836
DOLLAR              2EF
DONE                1B70
D_REG               2CA
EA_DEST_ADD         1384
EA_DEST_SUB_AND_OR  1466
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             13E0
END_BRA_BCC         16A8
END_MOVEM           1714
END_MOVEM_POSTINC   1B06
END_MOVEM_PREDEC    1A54
ENTER               1294
ENTER_PRESS_TRUE    11CA
ERROR               1B60
ERRORMSG            11E
EXITMSG             245
FLUSHSCREEN         11A6
FLUSHSCREENMSG      199
FLUSHSCREEN_INPUT   11B8
GETENDADDRESS       10B8
GETSTARTADDRESS     1098
HELPMSG             1D3
HEXTOASCIIMSG       12D
IMMEDIATE           18EE
IMM_COMPLETE        192C
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             1264
JSR_INS             2A7
LEA_INS             2AC
LEFT                2C8
LETTERS_CAP         1B3C
LF                  A
LONG                255
LS_AS_RO_MEM        152A
LS_AS_RO_REG        150C
LS_INS              29A
L_IMM               194C
MEMSEARCH           1108
MEMSEARCHLOOP       111C
MEMSEARCH_DONE      1156
MEM_TO_REG          1700
MENU                1080
MOVEA_INS           27B
MOVEM_CHECK_DONE    173A
MOVEM_CHECK_PRE     1734
MOVEM_CHECK_PRE_POST  171C
MOVEM_DIRECTION     16DA
MOVEM_INS           275
MOVEM_LONG          16D2
MOVEM_POSTINC       1A56
MOVEM_PREDEC        19A6
MOVEQ_INS           26E
MOVE_A              1310
MOVE_INS            269
MOVE_MOVEA          1914
MOVE_SIZE           1790
MUL_DIV             1484
MUL_DIV_LONG        14A6
M_SIZE              1318
NEXT_ADD            13CC
NEXT_BRA_BCC        1654
NEXT_LS_AS_RO       1558
NOP_INS             261
NOT_INS             2A3
NUMBERS             1B4E
OPCODE_DECODE       11CC
OPEN_PARAN          2CE
OR_INS              28F
OUT                 1280
POSTINC_CHECK_FIRST_A  1A88
POSTINC_CHECK_FIRST_D  1ADE
POSTINC_FIRST_A     1A98
POSTINC_FIRST_D     1AEE
POSTINC_INC_LOOP_A  1A7C
POSTINC_INC_LOOP_D  1AD2
POSTINC_LOOP_A      1A72
POSTINC_LOOP_A_DONE  1AB8
POSTINC_LOOP_D      1AC8
POSTINC_SKIP_TO_D   1AC6
POST_INC            2D3
POST_INCREMENT      1890
POUND               2DF
PREDEC_CHECK_FIRST_A  19D2
PREDEC_CHECK_FIRST_D  1A2C
PREDEC_FIRST_A      19E2
PREDEC_FIRST_D      1A3C
PREDEC_INC_LOOP_A   19C6
PREDEC_INC_LOOP_D   1A20
PREDEC_LOOP_A       19BC
PREDEC_LOOP_A_DONE  1A08
PREDEC_LOOP_D       1A16
PREDEC_SKIP_TO_D    1A16
PRE_DEC             2D6
PRE_DECREMENT       18B0
PRINT               1282
PRINTLN             128C
PRINT_ADDQ          15C4
PRINT_ADD_ADDA      1340
PRINT_AS            177E
PRINT_B             17B2
PRINT_BEQ           1634
PRINT_BGT           164C
PRINT_BLE           1640
PRINT_BRA           1628
PRINT_BRA_BCC       15FE
PRINT_CORRECT_SHIFT_ROTATION  175E
PRINT_DIRECTION     173C
PRINT_INSTRUCTION   1434
PRINT_IT            178A
PRINT_JSR           158A
PRINT_L             17CA
PRINT_LEA           15A0
PRINT_LEFT          1754
PRINT_LS            1786
PRINT_LS_AS_RO      14AC
PRINT_MOVEM         16B0
PRINT_MOVEQ         12B2
PRINT_MOVE_MOVEA    12F6
PRINT_NOP           129E
PRINT_NOT           1560
PRINT_OR            1430
PRINT_RTS           12A8
PRINT_SUB           141A
PRINT_SUB_AND_OR    13E8
PRINT_W             17BE
RETURN              2E5
RIGHT               2C6
RO_INS              2A0
RTS_INS             265
SCREENFLUSH_CHECK   119C
SIZE                17D6
SLASH               2E3
SPACE               2DA
START               1000
STARTINGMSG         0
SUB_INS             296
TAB                 9
WORD                259
W_IMM               1930
XN                  196A
