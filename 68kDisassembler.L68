00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 8:23:54 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 49 6E 70 75 74 73 ...     23  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
000001CC= 57 6F 75 6C 64 20 ...     24  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
000001EF= 45 78 69 74 69 6E ...     25  ExitMsg             dc.b    'Exiting Program',0
000001FF                            26  
000001FF                            27  START_ADDR_BUFFER  DS.B    256
000002FF                            28  END_ADDR_BUFFER    DS.B    256
000003FF                            29  
000003FF                            30  *size
000003FF= 2E 4C 20 00               31  long                DC.B    '.L ',0
00000403= 2E 57 20 00               32  word                DC.B    '.W ',0
00000407= 2E 42 20 00               33  byte                DC.B    '.B ',0
0000040B                            34  
0000040B                            35  *instructions
0000040B= 4E 4F 50 00               36  nop_ins             DC.B    'NOP',0
0000040F= 52 54 53 00               37  rts_ins             DC.B    'RTS',0
00000413= 4D 4F 56 45 00            38  move_ins            DC.B    'MOVE',0
00000418= 4D 4F 56 45 51 20 00      39  moveq_ins           DC.B    'MOVEQ ',0
0000041F= 4D 4F 56 45 4D 00         40  movem_ins           DC.B    'MOVEM',0
00000425= 4D 4F 56 45 41 00         41  movea_ins           DC.B    'MOVEA',0
0000042B= 41 44 44 00               42  add_ins             DC.B    'ADD',0
0000042F= 41 44 44 41 00            43  adda_ins            DC.B    'ADDA',0
00000434= 41 44 44 51 00            44  addq_ins            DC.B    'ADDQ',0
00000439= 4F 52 00                  45  or_ins              DC.B    'OR',0
0000043C= 41 4E 44 00               46  and_ins             DC.B    'AND',0
00000440= 53 55 42 00               47  sub_ins             DC.B    'SUB',0
00000444= 4C 53 00                  48  ls_ins              DC.B    'LS',0
00000447= 41 53 00                  49  as_ins              DC.B    'AS',0
0000044A= 52 4F 00                  50  ro_ins              DC.B    'RO',0
0000044D= 4E 4F 54 00               51  not_ins             DC.B    'NOT',0
00000451= 4A 53 52 20 00            52  jsr_ins             DC.B    'JSR ',0
00000456= 4C 45 41 20 00            53  lea_ins             DC.B    'LEA ',0
0000045B= 41 44 44 51 00            54  andq_ins            DC.B    'ADDQ',0
00000460= 42 47 54 00               55  bgt_ins             DC.B    'BGT',0
00000464= 42 4C 45 00               56  ble_ins             DC.B    'BLE',0
00000468= 42 45 51 00               57  beq_ins             DC.B    'BEQ',0
0000046C= 42 52 41 00               58  bra_ins             DC.B    'BRA',0
00000470                            59  
00000470                            60  *direction
00000470= 52 00                     61  right               DC.B    'R',0
00000472= 4C 00                     62  left                DC.B    'L',0
00000474                            63  
00000474                            64  *EA
00000474= 44 00                     65  D_reg               DC.B    'D',0
00000476= 41 00                     66  A_reg               DC.B    'A',0
00000478= 28 41 00                  67  open_paran          DC.B    '(A',0
0000047B= 29 00                     68  close_paran         DC.B    ')',0
0000047D= 29 2B 00                  69  post_inc            DC.B    ')+',0
00000480= 2D 28 41 00               70  pre_dec             DC.B    '-(A',0
00000484                            71  
00000484                            72  *extra
00000484= 20 00                     73  space               DC.B    ' ',0
00000486= 2C 20 00                  74  comma               DC.B    ', ',0
00000489= 23 00                     75  pound               DC.B    '#',0
0000048B= 2D 00                     76  dash                DC.B    '-',0
0000048D= 2F 00                     77  slash               DC.B    '/',0
0000048F  =00000009                 78  tab                 EQU     $9
0000048F= 0D 0A 00                  79  return              DC.B    CR,LF,0
00000492= 44 41 54 41 20 24 00      80  data                DC.B    'DATA $',0
00000499= 24 00                     81  dollar              DC.B    '$',0
00001000                            82      ORG    $1000    *Start at address $1000
00001000                            83  START:                  ; first instruction of program
00001000                            84  
00001000                            85  *---------- Test value, will remove in final build ----------*
00001000                            86  
00001000                            87  *   Move.W #$4E75,$00009234 *RTS
00001000                            88  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            89  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            90  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            91  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            92  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            93  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            94  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            95  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            96  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            97  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            98  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                            99  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           100  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           101  *   MOVE.W #$000C,$00009250
00001000                           102  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           103  *   MOVE.L #$12345678,$00009254
00001000                           104  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           105  *   MOVE.W #$0012,$0000925A
00001000                           106  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           107  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           108  *   MOVE.L #$00009208,$00009260
00001000                           109  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           110  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           111  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           112  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           113  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           114  *    MOVE.W #$FE7A,$0000926E
00001000                           115  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           116  *    MOVE.W #$FE60,$00009272
00001000                           117  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           118  *    MOVE.L #$00009208,$000009276
00001000                           119  *    MOVE.W #$48A1,$0000927A
00001000                           120  *    MOVE.W #$011F,$0000927C
00001000                           121  *    MOVE.W #$4C91,$0000927E
00001000                           122  *    MOVE.W #$FE00,$00009280
00001000                           123  *   MOVE.W #$C2BC, $00009000
00001000                           124  *   MOVE.L #$12345678, $00009002 
00001000  33FC 82C0 00009000       125      MOVE.W #$82C0, $00009000
00001008                           126  *   MOVE.L #$12345678, $00009002
00001008                           127  *---------- END Test ----------*
00001008                           128  
00001008                           129  
00001008                           130  
00001008                           131  *---------- Beginning Messages ----------*
00001008                           132      
00001008  103C 000E                133      move.b      #14,D0
0000100C  43F8 0000                134      lea         StartingMsg,A1 
00001010  4E4F                     135      trap        #15
00001012                           136      
00001012  103C 000E                137      move.b      #14,D0
00001016  43F8 001F                138      lea         Creators,A1
0000101A  4E4F                     139      trap        #15
0000101C                           140      
0000101C  4EB9 0000106E            141      jsr         MENU
00001022                           142      
00001022                           143      
00001022                           144  * ---------- END OF PROGRAM -------------*
00001022                           145  
00001022  103C 000E                146      move.b      #14,D0
00001026  43F8 01EF                147      lea         ExitMsg,A1 
0000102A  4E4F                     148      trap        #15
0000102C                           149      
0000102C  103C 0009                150      move.b      #9,D0
00001030  4E4F                     151      trap        #15
00001032                           152  * ---------------------------------------*
00001032                           153      
00001032                           154  *-- End of Opening and Ending Messages --*
00001032                           155  
00001032                           156  *--------- Start of I/O Section ---------*
00001032                           157  
00001032                           158  Clear_Registers:
00001032  4280                     159      clr.l     D0
00001034  4281                     160      clr.l     D1
00001036  4282                     161      clr.l     D2
00001038  4283                     162      clr.l     D3
0000103A  4284                     163      clr.l     D4
0000103C  4285                     164      clr.l     D5
0000103E  4286                     165      clr.l     D6
00001040  4287                     166      clr.l     D7
00001042                           167      
00001042  207C 00000000            168      movea.l   #0,A0
00001048  227C 00000000            169      movea.l   #0,A1
0000104E  247C 00000000            170      movea.l   #0,A2
00001054  267C 00000000            171      movea.l   #0,A3
0000105A  287C 00000000            172      movea.l   #0,A4
00001060  2A7C 00000000            173      movea.l   #0,A5
00001066  2C7C 00000000            174      movea.l   #0,A6
0000106C  4E75                     175      rts
0000106E                           176  
0000106E                           177  MENU:
0000106E  4EB8 1032                178      jsr         Clear_Registers
00001072  4EB9 0000108C            179      jsr         GetStartAddress
00001078  4EB9 000010A6            180      jsr         GetEndAddress
0000107E  4EB9 000010C0            181      jsr         CheckAddress
00001084                           182      
00001084  4EB9 000010C4            183      jsr         MemSearch
0000108A  4E75                     184      rts
0000108C                           185      
0000108C                           186  GetStartAddress:
0000108C                           187      
0000108C  103C 000E                188      move.b      #14, D0         *Display input message
00001090  43F8 004E                189      lea         InputMsg1,A1
00001094  4E4F                     190      trap        #15
00001096                           191      
00001096  103C 0002                192      move.b      #2,D0
0000109A  4E4F                     193      trap        #15
0000109C                           194          
0000109C  4EB9 00001A20            195      jsr ASCIItoHex              *conversion to Hex
000010A2                           196      * Address Located in D6
000010A2  2846                     197      movea.l     D6,A4           *move into address register 4
000010A4  4E75                     198      rts
000010A6                           199      
000010A6                           200      
000010A6                           201  GetEndAddress:
000010A6  103C 000E                202      move.b      #14,D0          *Display input message
000010AA  43F8 008F                203      lea         InputMsg2,A1
000010AE  4E4F                     204      trap        #15
000010B0                           205      
000010B0  103C 0002                206      move.b      #2,D0
000010B4  4E4F                     207      trap        #15
000010B6                           208      
000010B6  4EB9 00001A20            209      jsr         ASCIItoHex      *conversion to hex
000010BC                           210      * Address Located in D6 (overwrite)
000010BC  2A46                     211      movea.l     D6,A5           *move into address register 5
000010BE  4E75                     212      rts
000010C0                           213      
000010C0                           214  CheckAddress:
000010C0  BBCC                     215      cmp.l       A4,A5
000010C2  67AA                     216      beq         Menu
000010C4                           217  
000010C4                           218      
000010C4                           219  MemSearch:
000010C4  4EB9 000010CC            220      jsr MemSearchLoop
000010CA  4E75                     221      rts
000010CC                           222      
000010CC                           223  MemSearchLoop:
000010CC                           224      
000010CC                           225      * Check if we reached the end address
000010CC  BBCC                     226      cmp.l       A4,A5
000010CE  6700 002A                227      beq         MemSearch_Done
000010D2                           228      
000010D2                           229      * Get data from memory
000010D2  4241                     230      CLR D1
000010D4  3414                     231      move.w     (A4),D2
000010D6  3602                     232      move.w      D2, D3  mutable copy in D3
000010D8                           233      * OPCODE Word Located in D2, mutable copy in D3
000010D8  220C                     234      MOVE.L      A4, D1
000010DA  143C 0010                235      MOVE.B      #16, D2
000010DE  103C 000F                236      MOVE.B      #15, D0     print address of instruction
000010E2  4E4F                     237      TRAP        #15
000010E4  3403                     238      MOVE.W      D3,D2
000010E6  43F8 0484                239      LEA         space,A1
000010EA  4EB9 0000120E            240      JSR         print
000010F0  4EB9 0000111C            241      jsr         OPCODE_DECODE    
000010F6                           242      
000010F6  544C                     243      adda.w      #2,A4
000010F8  60D2                     244      bra         MemSearchLoop
000010FA                           245      
000010FA                           246      
000010FA                           247  MemSearch_Done:
000010FA  103C 000E                248      move.b      #14,D0
000010FE  43F8 0173                249      lea         EndOfMemLoop,A1 
00001102  4E4F                     250      trap        #15
00001104  4E75                     251      rts
00001106                           252      
00001106                           253  TerminateOrCont:
00001106                           254      * Used to check if user would like to terminate the program or continue to disassemble more data
00001106  103C 000E                255      move.b      #14,D0
0000110A  43F8 01CC                256      lea         ContinueOrNotMsg,A1 
0000110E  4E4F                     257      trap        #15
00001110                           258      
00001110  4E75                     259      rts
00001112                           260  
00001112                           261  ScreenFlush:
00001112  B63C 001E                262      cmp.b       #30,D3
00001116  6700 0004                263      beq         FlushScreen
0000111A  4E75                     264      rts 
0000111C                           265  
0000111C                           266  FlushScreen:
0000111C                           267  
0000111C                           268  * -------- Start of Opcode Section -------*    
0000111C                           269  
0000111C                           270  OPCODE_DECODE:
0000111C                           271      * Begin OPCODE Decoding here
0000111C                           272      * Check first four bits and begin
0000111C                           273      * if-branch breakdown
0000111C  4284                     274      CLR.L D4
0000111E  4285                     275      CLR.L D5
00001120  4286                     276      CLR.L D6
00001122  4287                     277      CLR.L D7
00001124                           278      
00001124  B47C 4E71                279      CMP.W #$4E71, D2        
00001128  6700 0100                280      BEQ print_nop           *check if value is NOP
0000112C                           281      
0000112C  B47C 4E75                282      CMP.W #$4E75, D2        
00001130  6700 0102                283      BEQ print_rts           *check if value is RTS
00001134                           284      
00001134                           285      * Mask out only the first 4 bits
00001134  C67C F000                286      AND.W #$F000,D3
00001138                           287      
00001138  B67C 9000                288      CMP.W #$9000,D3
0000113C  6700 01EE                289      BEQ print_sub_and_or    *check if value is SUB
00001140                           290      
00001140  B67C 6000                291      CMP.W #$6000,D3
00001144  6700 03B0                292      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
00001148                           293      
00001148  B67C 8000                294      CMP.W #$8000, D3
0000114C  6700 01DE                295      BEQ print_sub_and_or    *check if value is OR
00001150                           296  
00001150  B67C C000                297      CMP.W #$C000,D3
00001154  6700 01D6                298      BEQ print_sub_and_or    *check if value is AND
00001158                           299      
00001158  B67C D000                300      CMP.W #$D000,D3
0000115C  6700 012A                301      BEQ print_add_adda      *check if value is ADD or ADDA
00001160                           302      
00001160  B67C E000                303      CMP.W #$E000,D3
00001164  6700 0252                304      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001168                           305      
00001168  B67C 7000                306      CMP.W #$7000,D3
0000116C  6700 0064                307      BEQ print_moveq     *check if value is MOVEQ
00001170                           308      
00001170  B47C 1000                309      CMP.W #$1000,D2
00001174  6D00 003E                310      BLT invalid
00001178  B47C 4000                311      CMP.W #$4000,D2
0000117C  6D00 00C0                312      BLT print_move_movea    *check if value is MOVE or MOVEA
00001180                           313      
00001180                           314      * Mask out only the first 8 bits
00001180  3602                     315      MOVE.W D2, D3
00001182  C67C FF00                316      AND.W #$FF00,D3
00001186                           317      
00001186  B67C 4600                318      CMP.W #$4600,D3
0000118A  6700 02CC                319      BEQ print_not           *check if value is NOT
0000118E                           320      
0000118E  B67C 4E00                321      CMP.W #$4E00,D3
00001192  6700 02EE                322      BEQ print_jsr           *check if value is JSR
00001196                           323      
00001196                           324      * Mask out only the first 4 bits and the 8th bit
00001196  3602                     325      MOVE.W D2,D3
00001198  C67C F100                326      AND.W #$F100, D3
0000119C                           327      
0000119C  B67C 4000                328      CMP.W #$4000, D3
000011A0  6700 0406                329      BEQ print_movem         *check if value is MOVEM
000011A4                           330      
000011A4  B67C 4100                331      CMP.W #$4100, D3
000011A8  6700 02EE                332      BEQ print_lea           *check if value is LEA
000011AC                           333      
000011AC  B67C 5000                334      CMP.W #$5000,D3
000011B0  6700 030A                335      BEQ print_addq          *check if value is ANDQ     
000011B4                           336      
000011B4                           337      
000011B4                           338  invalid 
000011B4  43F8 0492                339      LEA data, A1
000011B8  4EB9 0000120E            340      JSR print
000011BE  2202                     341      MOVE.L D2, D1
000011C0  143C 0010                342      MOVE.B #16, D2
000011C4  103C 000F                343      MOVE.B  #15, D0     
000011C8  4E4F                     344      TRAP #15
000011CA  4EB9 00001220            345      JSR enter
000011D0  4E75                     346  out rts
000011D2                           347  
000011D2                           348      
000011D2                           349  * -------- End of Opcode Section --------*   
000011D2                           350  
000011D2                           351  * --------- Print Instructions ----------*
000011D2                           352  
000011D2                           353  print_moveq
000011D2  43F8 0418                354      lea moveq_ins, A1   *print MOVEQ
000011D6  4EB9 0000120E            355      jsr print
000011DC  3602                     356      move.w  D2,D3
000011DE  C67C 00FF                357      and.w   #$00FF,D3   * Figure out the immediate address value
000011E2  43F8 0489                358      lea pound,A1        *print '#'
000011E6  4EB9 0000120E            359      jsr print
000011EC  103C 0003                360      move.b  #3,D0
000011F0  3203                     361      move.w  D3,D1
000011F2  4E4F                     362      trap    #15         *print immediate address value
000011F4  43F8 0486                363      lea comma,A1        *print comma
000011F8  4EB9 0000120E            364      jsr print
000011FE  3A02                     365      MOVE.W D2, D5
00001200  4EB9 0000184E            366      JSR data_reg_sr     *figure out data address
00001206  4EB9 00001220            367      jsr enter           *print out enter
0000120C  60C2                     368      bra out
0000120E                           369  
0000120E                           370  print:
0000120E  4240                     371      CLR D0 
00001210  103C 000E                372      MOVE.B #14,D0
00001214  4E4F                     373      TRAP #15
00001216  4E75                     374      RTS
00001218                           375  
00001218                           376  println:
00001218  103C 000D                377      MOVE.B #13, D0
0000121C  4E4F                     378      TRAP #15
0000121E  4E75                     379      RTS
00001220                           380      
00001220                           381  enter: 
00001220  43F8 048F                382      LEA return, A1
00001224  4EB8 120E                383      JSR print
00001228  4E75                     384      RTS
0000122A                           385      
0000122A                           386  print_nop
0000122A  43F8 040B                387      LEA nop_ins, A1
0000122E  4EB8 1218                388      JSR println
00001232  609C                     389      BRA out
00001234                           390  
00001234                           391  print_rts
00001234  43F8 040F                392      LEA rts_ins, A1
00001238  4EB8 1218                393      JSR println
0000123C  6092                     394      BRA out
0000123E                           395  
0000123E                           396  print_move_movea
0000123E  3602                     397      MOVE.W D2, D3       
00001240  C67C 01C0                398      AND.W #$01C0, D3
00001244  B67C 0040                399      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001248  6700 000E                400      BEQ move_a
0000124C  43F8 0413                401      LEA move_ins, A1 *print Instruction 
00001250  4EB8 120E                402      JSR print
00001254  6000 000A                403      BRA m_size
00001258                           404  move_a          *if instruction is MOVEA
00001258  43F8 0425                405      LEA movea_ins, A1
0000125C  4EB8 120E                406      JSR print
00001260                           407  m_size              *determine instruction size
00001260  4EB9 00001668            408      JSR move_size
00001266  4EB9 000016CA            409      JSR addr        *determine the source address
0000126C  43F8 0486                410      LEA comma, A1   *print comma
00001270  4EB8 120E                411      JSR print
00001274  4207                     412      CLR.B D7
00001276  1E3C 0001                413      MOVE.B #1, D7   *determine destination address
0000127A  4EB9 000016CA            414      JSR addr
00001280  4EB8 1220                415      JSR enter       *print enter
00001284  6000 FF4A                416      BRA out
00001288                           417      
00001288                           418  print_add_adda
00001288  3602                     419      MOVE.W D2, D3   
0000128A  C63C 00C0                420      AND.B #$C0, D3
0000128E  B63C 00C0                421      CMP.B #$C0, D3      *determine if ADD or ADDA
00001292  6700 0052                422      BEQ add_a
00001296                           423      *if just ADD then print instruction
00001296  43F8 042B                424      LEA add_ins, A1
0000129A  4EB8 120E                425      JSR print
0000129E                           426      *print instruction size for ADD
0000129E  4EB9 000016AE            427      JSR size
000012A4                           428      *determine direction of ADD, Dn -> EA or EA -> Dn
000012A4  3602                     429      MOVE.W D2,D3
000012A6  C67C 0100                430      AND.W #$0100, D3
000012AA  B67C 0100                431      CMP.W #$0100, D3
000012AE  6700 001C                432      BEQ ea_dest_add 
000012B2  4EB9 000016CA            433      JSR addr            *if Direction bit is 0
000012B8  43F8 0486                434      LEA comma, A1
000012BC  4EB8 120E                435      JSR print
000012C0  3A02                     436      MOVE.W D2,D5
000012C2  4EB9 0000184E            437      JSR data_reg_sr
000012C8  6000 005A                438      BRA end_add
000012CC                           439  ea_dest_add             *if Direction bit is 1
000012CC  3A02                     440      MOVE.W D2,D5
000012CE  4EB9 0000184E            441      JSR data_reg_sr
000012D4  43F8 0486                442      LEA comma, A1
000012D8  4EB8 120E                443      JSR print
000012DC  4EB9 000016CA            444      JSR addr
000012E2  6000 0040                445      BRA end_add
000012E6                           446  add_a                   *if instruction is ADDA
000012E6  43F8 042F                447      LEA adda_ins, A1
000012EA  4EB8 120E                448      JSR print
000012EE                           449      *print instruction size for ADDA (either W or L)
000012EE  3602                     450      MOVE.W D2,D3
000012F0  C67C 0100                451      AND.W #$0100, D3
000012F4  B67C 0100                452      CMP.W #$0100, D3
000012F8  6700 000E                453      BEQ adda_size
000012FC  43F8 0403                454      LEA word, A1
00001300  4EB8 120E                455      JSR print
00001304  6000 000A                456      BRA next_add
00001308                           457  adda_size
00001308  43F8 03FF                458      LEA long,A1
0000130C  4EB8 120E                459      JSR print
00001310                           460  next_add                *print effective address for ADDA
00001310  4EB9 000016CA            461      JSR addr            
00001316  43F8 0486                462      LEA comma, A1
0000131A  4EB8 120E                463      JSR print
0000131E  4EB9 00001866            464      JSR add_reg_sr
00001324                           465  end_add                 *complete instruction printing by printing enter
00001324  4EB8 1220                466      JSR enter
00001328  6000 FEA6                467      BRA out
0000132C                           468  
0000132C                           469  print_sub_and_or
0000132C                           470      *determine if instruction is SUB, AND, or OR.
0000132C  3602                     471      MOVE.W D2, D3
0000132E  C67C F0C0                472      AND.W #$F0C0, D3
00001332  B67C C0C0                473      CMP.W #$C0C0, D3
00001336  6700 FE7C                474      BEQ invalid
0000133A  B67C 80C0                475      CMP.W #$80C0, D3
0000133E  6700 FE74                476      BEQ invalid
00001342  C67C F000                477      AND.W #$F000,D3
00001346  B67C 8000                478      CMP.W #$8000, D3
0000134A  6700 001A                479      BEQ print_or
0000134E  B67C 9000                480      CMP.W #$9000, D3
00001352  6700 000A                481      BEQ print_sub
00001356  43F8 043C                482      LEA and_ins, A1
0000135A  6000 000E                483      BRA print_instruction
0000135E                           484  print_sub
0000135E  43F8 0440                485      LEA sub_ins, A1
00001362  6000 0006                486      BRA print_instruction
00001366                           487  print_or
00001366  43F8 0439                488      LEA or_ins, A1
0000136A                           489  print_instruction       *print correct instruction
0000136A  4EB8 120E                490      JSR print
0000136E  4EB9 000016AE            491      JSR size            *print instruction size
00001374  3602                     492      MOVE.W D2,D3
00001376                           493  *determine direction of ADD, Dn -> EA or EA -> Dn   
00001376  C67C 0100                494      AND.W #$0100, D3
0000137A  B67C 0100                495      CMP.W #$0100, D3
0000137E  6700 001A                496      BEQ ea_dest_sub_and_or
00001382  4EB9 000016CA            497      JSR addr            *if Direction bit is 0
00001388  43F8 0486                498      LEA comma, A1
0000138C  4EB8 120E                499      JSR print
00001390  3A02                     500      MOVE.W D2,D5
00001392  4EB9 0000184E            501      JSR data_reg_sr
00001398  608A                     502      BRA end_add
0000139A                           503  ea_dest_sub_and_or      *if Direction bit is 1
0000139A  3A02                     504      MOVE.W D2,D5
0000139C  4EB9 0000184E            505      JSR data_reg_sr
000013A2  43F8 0486                506      LEA comma, A1
000013A6  4EB8 120E                507      JSR print
000013AA  4EB9 000016CA            508      JSR addr
000013B0                           509      *complete instruction printing by printing enter
000013B0  4EB8 1220                510      JSR enter
000013B4  6000 FE1A                511      BRA out
000013B8                           512  
000013B8                           513  print_ls_as_ro
000013B8                           514      *figure out if shift or rotation are memory or register based               
000013B8  3602                     515      MOVE.W D2, D3
000013BA  C63C 00C0                516      AND.B #$C0, D3
000013BE  B63C 00C0                517      CMP.B #$C0, D3
000013C2  6700 005E                518      BEQ ls_as_ro_mem
000013C6  3602                     519      MOVE.W D2, D3
000013C8  E60B                     520      LSR.B #3, D3
000013CA                           521      *print correct instruction type (logical shift, arithmetic shift, or rotation)
000013CA  4EB9 00001636            522      JSR print_correct_shift_rotation
000013D0  4EB9 00001614            523      JSR print_direction     *print direction
000013D6  4EB9 000016AE            524      JSR size                *print size
000013DC  3602                     525      MOVE.W D2, D3
000013DE  C63C 0020                526      AND.B #$20,D3
000013E2  B63C 0020                527      CMP.B #$20, D3
000013E6                           528      *determine if instruction is using immediate address or register
000013E6  6700 001C                529      BEQ ls_as_ro_reg     
000013EA  43F8 0489                530      LEA pound, A1        *if immediate address print '#'
000013EE  4EB8 120E                531      JSR print
000013F2                           532      *print immediate address rotation value
000013F2  3C02                     533      MOVE.W D2,D6
000013F4  EF5E                     534      ROL.W #7,D6
000013F6  CC7C 0007                535      AND.W #$0007, D6
000013FA  4EB9 00001842            536      JSR Xn
00001400  6000 000A                537      BRA continue_instruction_ls_as_ro
00001404                           538  ls_as_ro_reg            *if instruction is using register to shift values in another register
00001404  3A02                     539      MOVE.W D2,D5
00001406  4EB9 0000184E            540      JSR data_reg_sr
0000140C                           541  continue_instruction_ls_as_ro *complete instrcuction
0000140C  43F8 0486                542      LEA comma, A1       *print comma
00001410  4EB8 120E                543      JSR print
00001414  3A02                     544      MOVE.W D2,D5
00001416  EE5D                     545      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001418  4EB9 0000184E            546      JSR data_reg_sr     *determine destination data register to perform instruction on
0000141E  6000 0030                547      BRA next_ls_as_ro   *finish printing instruction
00001422                           548  ls_as_ro_mem            *check if immediate address is being shifted or rotated
00001422  3602                     549      MOVE.W D2, D3
00001424  C63C 003F                550      AND.B #$3F, D3
00001428  B63C 003C                551      CMP.B #$3C, D3
0000142C  6700 FD86                552      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
00001430                           553      *if not immediate adress print normally 
00001430  3602                     554      MOVE.W D2, D3
00001432  EF5B                     555      ROL.W #7, D3    
00001434  4EB9 00001636            556      JSR print_correct_shift_rotation
0000143A  3602                     557      MOVE.W D2,D3
0000143C  4EB9 00001614            558      JSR print_direction
00001442  43F8 0403                559      LEA word, A1
00001446  4EB8 120E                560      JSR print
0000144A  4EB9 000016CA            561      JSR addr
00001450                           562  next_ls_as_ro
00001450  4EB8 1220                563      JSR enter
00001454  6000 FD7A                564      BRA out
00001458                           565      
00001458                           566  print_not
00001458  43F8 044D                567      LEA not_ins, A1 *print instruction
0000145C  4EB8 120E                568      JSR print
00001460  4EB9 000016AE            569      JSR size
00001466  3602                     570      MOVE.W D2, D3
00001468  C63C 003F                571      AND.B #$3F, D3
0000146C  B63C 003C                572      CMP.B #$3C, D3
00001470  6700 FD42                573      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
00001474  4EB9 000016CA            574      JSR addr
0000147A  4EB8 1220                575      JSR enter
0000147E  6000 FD50                576      BRA out
00001482                           577  
00001482                           578  print_jsr
00001482  43F8 0451                579      LEA jsr_ins, A1 *print instruction
00001486  4EB8 120E                580      JSR print
0000148A  4EB9 000016CA            581      JSR addr    *print address
00001490  4EB8 1220                582      JSR enter   *print enter (next line)
00001494  6000 FD3A                583      BRA out
00001498                           584  
00001498                           585  print_lea
00001498  43F8 0456                586      LEA lea_ins, A1 *print instruction
0000149C  4EB8 120E                587      JSR print   
000014A0  4EB9 000016CA            588      JSR addr    *print address
000014A6  43F8 0486                589      LEA comma, A1   *print comma
000014AA  4EB8 120E                590      JSR print
000014AE  4EB9 00001866            591      JSR add_reg_sr *print destination address register
000014B4  4EB8 1220                592      JSR enter
000014B8  6000 FD16                593      BRA out
000014BC                           594  
000014BC                           595  print_addq
000014BC  43F8 0434                596      LEA addq_ins, A1    *print instruction
000014C0  4EB8 120E                597      JSR print
000014C4  4EB9 000016AE            598      JSR size            *print instruction size
000014CA  43F8 0489                599      LEA pound, A1
000014CE  4EB8 120E                600      JSR print           *print '#' for immediate addressing
000014D2  3C02                     601      MOVE.W D2,D6
000014D4  EF5E                     602      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
000014D6  CC7C 0007                603      AND.W #$0007, D6
000014DA  4EB9 00001842            604      JSR Xn
000014E0  43F8 0486                605      LEA comma, A1       *print comma
000014E4  4EB8 120E                606      JSR print
000014E8  4EB9 000016CA            607      JSR addr            *print destination address
000014EE  4EB8 1220                608      JSR enter
000014F2  6000 FCDC                609      BRA out
000014F6                           610  
000014F6                           611  print_bra_bcc           *needs comments
000014F6  3602                     612      MOVE.W D2,D3
000014F8  C67C 0F00                613      AND.W #$0F00, D3
000014FC  B67C 0000                614      CMP.W #$0000, D3
00001500  6700 001E                615      BEQ print_bra
00001504  B67C 0700                616      CMP.W #$0700, D3
00001508  6700 0022                617      BEQ print_beq
0000150C  B67C 0E00                618      CMP.W #$0E00, D3
00001510  6700 0032                619      BEQ print_bgt
00001514  B67C 0F00                620      CMP.W #$0F00, D3
00001518  6700 001E                621      BEQ print_ble
0000151C  6000 FC96                622      BRA invalid
00001520                           623  print_bra
00001520  43F8 046C                624      LEA bra_ins, A1
00001524  4EB8 120E                625      JSR print
00001528  6000 0022                626      BRA next_bra_bcc
0000152C                           627  print_beq
0000152C  43F8 0468                628      LEA beq_ins, A1
00001530  4EB8 120E                629      JSR print
00001534  6000 0016                630      BRA next_bra_bcc
00001538                           631  print_ble
00001538  43F8 0464                632      LEA ble_ins, A1
0000153C  4EB8 120E                633      JSR print
00001540  6000 000A                634      BRA next_bra_bcc
00001544                           635  print_bgt
00001544  43F8 0460                636      LEA bgt_ins, A1
00001548  4EB8 120E                637      JSR print
0000154C                           638  next_bra_bcc
0000154C  3602                     639      MOVE.W D2, D3
0000154E  C67C 00FF                640      AND.W #$00FF, D3
00001552  B67C 0000                641      CMP.W #$0000, D3
00001556  6700 0026                642      BEQ check_word
0000155A  43F8 0407                643      LEA byte, A1
0000155E  4EB8 120E                644      JSR print
00001562  43F8 0499                645      LEA dollar, A1
00001566  4EB8 120E                646      JSR print
0000156A  3203                     647      MOVE.W D3, D1
0000156C  3602                     648      MOVE.W D2, D3
0000156E  343C 0010                649      MOVE.W #16, D2
00001572  303C 000F                650      MOVE.W #15,D0
00001576  4E4F                     651      trap #15            *print immediate address value
00001578  3403                     652      MOVE.W D3, D2
0000157A  6000 0024                653      BRA end_bra_bcc
0000157E                           654  check_word
0000157E  43F8 0403                655      LEA word, A1
00001582  4EB8 120E                656      JSR print
00001586  43F8 0499                657      LEA dollar, A1
0000158A  4EB8 120E                658      JSR print
0000158E  544C                     659      ADDA.W #2,A4        *update current address
00001590  3214                     660      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001592  3602                     661      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001594  343C 0010                662      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001598  103C 000F                663      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000159C  4E4F                     664      TRAP #15
0000159E  3403                     665      MOVE.W D3,D2        *copy opcode back to register D2
000015A0                           666  end_bra_bcc
000015A0  4EB8 1220                667      JSR enter
000015A4  6000 FC2A                668      BRA out
000015A8                           669  
000015A8                           670  print_movem         *needs comments
000015A8  43F8 041F                671      LEA movem_ins, A1
000015AC  4EB8 120E                672      JSR print
000015B0  3602                     673      MOVE.W D2,D3
000015B2  C67C 0040                674      AND.W #$0040,D3
000015B6  B67C 0040                675      CMP.W #$0040,D3
000015BA  6700 000E                676      BEQ movem_long
000015BE  43F8 0403                677      LEA word, A1
000015C2  4EB8 120E                678      JSR print
000015C6  6000 000A                679      BRA movem_direction
000015CA                           680  movem_long
000015CA  43F8 03FF                681      LEA long, A1
000015CE  4EB8 120E                682      JSR print
000015D2                           683  movem_direction
000015D2  3602                     684      MOVE.W D2,D3
000015D4  C67C 0400                685      AND.W #$0400,D3
000015D8  B67C 0400                686      CMP.W #$0400,D3
000015DC  6700 001A                687      BEQ mem_to_reg
000015E0  4EB9 0000187E            688      JSR movem_predec
000015E6  43F8 0486                689      LEA comma, A1
000015EA  4EB8 120E                690      JSR print
000015EE  4EB9 000016CA            691      JSR addr
000015F4  6000 0016                692      BRA end_movem
000015F8                           693  mem_to_reg
000015F8  4EB9 000016CA            694      JSR addr
000015FE  43F8 0486                695      LEA comma, A1
00001602  4EB8 120E                696      JSR print
00001606  4EB9 00001950            697      JSR movem_postinc
0000160C                           698  end_movem
0000160C  4EB8 1220                699      JSR enter
00001610  6000 FBBE                700      BRA out
00001614                           701  
00001614                           702  print_direction:
00001614                           703  *print correct direction given direction bit
00001614  C67C 0100                704      AND.W #$0100, D3
00001618  B67C 0100                705      CMP.W #$0100, D3
0000161C  6700 000E                706      BEQ print_left  *print left
00001620  43F8 0470                707      LEA right, A1
00001624  4EB8 120E                708      JSR print
00001628  6000 FBA6                709      BRA out
0000162C                           710  print_left
0000162C  43F8 0472                711      LEA left, A1
00001630  4EB8 120E                712      JSR print *print right
00001634  4E75                     713      RTS
00001636                           714      
00001636                           715  print_correct_shift_rotation:
00001636                           716  *determine if instruction is logical, arithmetic, or rotation 
00001636  C63C 0003                717      AND.B #$03, D3
0000163A  B63C 0000                718      CMP.B #$00, D3
0000163E  6700 0016                719      BEQ print_as
00001642  B63C 0001                720      CMP.B #$01, D3
00001646  6700 0016                721      BEQ print_ls
0000164A  B63C 0003                722      CMP.B #$03, D3
0000164E  43F8 044A                723      LEA ro_ins, A1  print rotation
00001652  6000 000E                724      BRA print_it
00001656                           725  print_as
00001656  43F8 0447                726      LEA as_ins, A1  print arithmetic shift
0000165A  6000 0006                727      BRA print_it
0000165E                           728  print_ls
0000165E  43F8 0444                729      LEA ls_ins, A1 print logical shift
00001662                           730  print_it
00001662  4EB8 120E                731      JSR print
00001666  4E75                     732      RTS
00001668                           733  * --------- End Print Instruction ----------*
00001668                           734  
00001668                           735  * ------- Instruction sizes ---------*
00001668                           736  
00001668                           737  move_size:  *print size for MOVE and MOVEA instruction
00001668  4284                     738      CLR.L D4
0000166A  3802                     739      MOVE.W D2, D4
0000166C  C87C 3000                740      AND.W #$3000, D4
00001670  B87C 1000                741      CMP.W #$1000, D4
00001674  6700 0014                742      BEQ print_b
00001678  B87C 3000                743      CMP.W #$3000, D4
0000167C  6700 0018                744      BEQ print_w
00001680  B87C 2000                745      CMP.W #$2000, D4
00001684  6700 001C                746      BEQ print_l
00001688  4E75                     747      RTS
0000168A                           748      
0000168A                           749  print_b     *print '.B'
0000168A  43F8 0407                750      LEA byte, A1
0000168E  4EB8 120E                751      JSR print
00001692  6000 FB3C                752      BRA out
00001696                           753      
00001696                           754  print_w     *print '.W'
00001696  43F8 0403                755      LEA word, A1
0000169A  4EB8 120E                756      JSR print
0000169E  6000 FB30                757      BRA out
000016A2                           758      
000016A2                           759  print_l:    *print '.L'
000016A2  43F8 03FF                760      LEA long, A1
000016A6  4EB8 120E                761      JSR print
000016AA  6000 FB24                762      BRA out
000016AE                           763  
000016AE                           764  size:       *print size for non "move" instructions
000016AE  4284                     765      CLR.L D4
000016B0  1802                     766      MOVE.B D2,D4
000016B2  C83C 00C0                767      AND.B #$C0, D4
000016B6  B83C 0000                768      CMP.B #$00, D4
000016BA  67CE                     769      BEQ print_b
000016BC  B83C 0040                770      CMP.B #$40,D4
000016C0  67D4                     771      BEQ print_w
000016C2  B83C 0080                772      CMP.B #$80, D4
000016C6  67DA                     773      BEQ print_l
000016C8  4E75                     774      RTS
000016CA                           775      
000016CA                           776  * ------- End Instruction sizes ---------*
000016CA                           777  
000016CA                           778  * ------- Effective Address -------*
000016CA                           779  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000016CA  3A02                     780      MOVE.W D2, D5
000016CC  3C02                     781      MOVE.W D2, D6               
000016CE  BE3C 0001                782      CMP.B #1, D7
000016D2  6700 003A                783      BEQ destination *check if evaluating destination address (used for MOVE)
000016D6                           784  cont
000016D6  CC3C 0038                785      AND.B #$38, D6
000016DA  BC3C 0000                786      CMP.B #0, D6
000016DE  6700 0038                787      BEQ data_reg        *check if EA mode is data register
000016E2  BC3C 0008                788      CMP.B #$08, D6
000016E6  6700 0048                789      BEQ add_reg         *check if EA mode is address register
000016EA  BC3C 0010                790      CMP.B #$10, D6
000016EE  6700 0058                791      BEQ add_indirect    *check if EA mode is address indirect
000016F2  BC3C 0018                792      CMP.B #$18, D6
000016F6  6700 0070                793      BEQ post_increment  *check if EA mode is post increment
000016FA  BC3C 0020                794      CMP.B #$20, D6
000016FE  6700 0088                795      BEQ pre_decrement   *check if EA mode is pre_decrement
00001702  BC3C 0038                796      CMP.B #$38, D6
00001706  6700 00A0                797      BEQ absolute_or_immediate
0000170A  6000 FAC4                798      BRA out *needs Immediate, Abs Long, and Abs Word
0000170E                           799  destination     *perform correct rotation to retrieve destination address
0000170E  3C05                     800      MOVE.W D5,D6
00001710  EF5D                     801      ROL.W #7,D5
00001712  E64E                     802      LSR.W #3,D6
00001714  60C0                     803      BRA cont
00001716  4E75                     804      RTS
00001718                           805  
00001718                           806  data_reg    *used with addr sub routine
00001718  3C05                     807      MOVE.W D5,D6    
0000171A  CC3C 0007                808      AND.B #$07, D6  
0000171E  43F8 0474                809      LEA D_reg, A1   
00001722  4EB8 120E                810      JSR print
00001726  4EB9 00001842            811      JSR Xn
0000172C  6000 FAA2                812      BRA out
00001730                           813  
00001730                           814  add_reg     *used with addr sub routine
00001730  3C05                     815      MOVE.W D5,D6    
00001732  CC3C 0007                816      AND.B #$07, D6
00001736  43F8 0476                817      LEA A_reg, A1   
0000173A  4EB8 120E                818      JSR print
0000173E  4EB9 00001842            819      JSR Xn
00001744  6000 FA8A                820      BRA out
00001748                           821      
00001748                           822  add_indirect    *used with addr sub routine
00001748  3C05                     823      MOVE.W D5,D6    
0000174A  CC3C 0007                824      AND.B #$07, D6
0000174E  43F8 0478                825      LEA open_paran, A1  
00001752  4EB8 120E                826      JSR print
00001756  4EB9 00001842            827      JSR Xn
0000175C  43F8 047B                828      LEA close_paran, A1 
00001760  4EB8 120E                829      JSR print
00001764  6000 FA6A                830      BRA out
00001768                           831      
00001768                           832  post_increment  *used with addr sub routine
00001768  3C05                     833      MOVE.W D5,D6    
0000176A  CC3C 0007                834      AND.B #$07, D6
0000176E  43F8 0478                835      LEA open_paran, A1  
00001772  4EB8 120E                836      JSR print
00001776  4EB9 00001842            837      JSR Xn
0000177C  43F8 047D                838      LEA post_inc, A1    
00001780  4EB8 120E                839      JSR print
00001784  6000 FA4A                840      BRA out
00001788                           841      
00001788                           842  pre_decrement   *used with addr sub routine
00001788  3C05                     843      MOVE.W D5,D6    
0000178A  CC3C 0007                844      AND.B #$07, D6
0000178E  43F8 0480                845      LEA pre_dec, A1 
00001792  4EB8 120E                846      JSR print
00001796  4EB9 00001842            847      JSR Xn
0000179C  43F8 047B                848      LEA close_paran, A1 
000017A0  4EB8 120E                849      JSR print
000017A4  6000 FA2A                850      BRA out
000017A8                           851  
000017A8                           852  absolute_or_immediate *check if EA is immediate or absolute address
000017A8  3C05                     853      MOVE.W D5,D6    
000017AA  CC3C 0007                854      AND.B #$07, D6
000017AE  BC3C 0000                855      CMP.B #$00, D6
000017B2  6700 0054                856      BEQ w_imm
000017B6  BC3C 0001                857      CMP.B #$01, D6
000017BA  6700 0068                858      BEQ l_imm
000017BE  BC3C 0004                859      CMP.B #04, D6
000017C2  6700 0002                860      BEQ immediate
000017C6                           861      
000017C6                           862  immediate
000017C6  43F8 0489                863      LEA pound, A1
000017CA  4EB8 120E                864      JSR print
000017CE  B4BC 00004000            865      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
000017D4  6D00 0016                866      BLT move_movea      *check if instruction is move or movea
000017D8  B8BC 00000040            867      CMP.L #$0040, D4        *if not move or movea
000017DE  6D00 0028                868      BLT w_imm           *byte and word check the next 2 addresses in mem
000017E2  B8BC 00000080            869      CMP.L #$0080, D4
000017E8  6700 003A                870      BEQ l_imm           *long checks the next 4 addresses in mem
000017EC                           871  move_movea              *similar comparisons, but for different bits in OPCODE
000017EC  B87C 1000                872      CMP.W #$1000, D4
000017F0  6700 0016                873      BEQ w_imm
000017F4  B87C 3000                874      CMP.W #$3000, D4
000017F8  6700 000E                875      BEQ w_imm
000017FC  B87C 2000                876      CMP.W #$2000, D4
00001800  6700 0022                877      BEQ l_imm
00001804                           878  imm_complete
00001804  6000 F9CA                879      BRA out
00001808                           880      
00001808                           881  w_imm
00001808  43F8 0499                882      LEA dollar, A1      *print '$'
0000180C  4EB8 120E                883      JSR print
00001810  544C                     884      ADDA.W #2,A4        *update current address
00001812  3214                     885      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001814  3602                     886      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001816  343C 0010                887      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000181A  103C 000F                888      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000181E  4E4F                     889      TRAP #15
00001820  3403                     890      MOVE.W D3,D2        *copy opcode back to register D2
00001822  60E0                     891      BRA imm_complete    *exit addr subroutine
00001824                           892      
00001824                           893  l_imm
00001824  43F8 0499                894      LEA dollar, A1      *print '$'
00001828  4EB8 120E                895      JSR print
0000182C  544C                     896      ADDA.W  #2,A4       *update current address
0000182E  2214                     897      MOVE.L (A4),D1      *retrieve long data stored in the new current address
00001830  3602                     898      MOVE.W D2, D3
00001832  343C 0010                899      MOVE.W #16, D2
00001836  103C 000F                900      MOVE.B #15, D0
0000183A  4E4F                     901      TRAP #15
0000183C  3403                     902      MOVE.W D3,D2
0000183E  544C                     903      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
00001840  60C2                     904      BRA imm_complete    *exit addr subroutine
00001842                           905  
00001842                           906  Xn:                     *retieve signed decimal value of data stored in register D6
00001842  4281                     907      CLR.L D1
00001844  1206                     908      MOVE.B D6,D1
00001846  103C 0003                909      MOVE.B #3, D0
0000184A  4E4F                     910      TRAP #15
0000184C  4E75                     911      RTS
0000184E                           912  
0000184E                           913  data_reg_sr:    *use if dealing with Dn only
0000184E  4286                     914      CLR.L D6
00001850  3C05                     915      MOVE.W D5,D6
00001852  EF5E                     916      ROL.W #7,D6
00001854  CC3C 0007                917      AND.B #$07, D6  
00001858  43F8 0474                918      LEA D_reg, A1   
0000185C  4EB8 120E                919      JSR print
00001860  4EB8 1842                920      JSR Xn
00001864  4E75                     921      RTS
00001866                           922      
00001866                           923  add_reg_sr:     *use if dealing with An only
00001866  4286                     924      CLR.L D6
00001868  3C02                     925      MOVE.W D2,D6
0000186A  EF5E                     926      ROL.W #7,D6
0000186C  CC3C 0007                927      AND.B #$07, D6  
00001870  43F8 0476                928      LEA A_reg, A1   
00001874  4EB8 120E                929      JSR print
00001878  4EB8 1842                930      JSR Xn
0000187C  4E75                     931      RTS
0000187E                           932      
0000187E                           933  movem_predec:           *needs to be worked on
0000187E  4285                     934      CLR.L D5
00001880  544C                     935      ADDA.W  #2,A4       *update current address
00001882  3A14                     936      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001884  BA3C 0000                937      CMP.B #$00, D5
00001888  6700 006C                938      BEQ predec_skip_to_d
0000188C  3C05                     939      MOVE.W D5,D6
0000188E  4281                     940      CLR.L D1
00001890  123C 0000                941      MOVE.B #0, D1
00001894                           942  a_loop1
00001894  E31E                     943      ROL.B #1,D6
00001896  6500 0006                944      BCS a_loop1_done
0000189A  5201                     945      ADD.B #1,D1
0000189C  60F6                     946      BRA a_loop1
0000189E                           947  a_loop1_done
0000189E  43F8 0476                948      LEA A_reg,A1
000018A2  4EB8 120E                949      JSR print
000018A6  103C 0003                950      MOVE.B #3,D0
000018AA  4E4F                     951      TRAP #15
000018AC  4287                     952      CLR.L D7
000018AE  1E3C 0000                953      MOVE.B #0, D7
000018B2                           954  a_loop2
000018B2  E31E                     955      ROL.B #1,D6
000018B4  6400 0010                956      BCC a_loop2_done
000018B8  5207                     957      ADD.B #1,D7
000018BA  5201                     958      ADD.B #1,D1
000018BC  B23C 0007                959      CMP.B #7, D1
000018C0  6700 0004                960      BEQ a_loop2_done
000018C4  60EC                     961      BRA a_loop2
000018C6                           962  a_loop2_done
000018C6  BE3C 0000                963      CMP.B #0, D7
000018CA  6700 0018                964      BEQ predec_no_dash
000018CE  43F8 048B                965      LEA dash, A1
000018D2  4EB8 120E                966      JSR print
000018D6  43F8 0476                967      LEA A_reg,A1
000018DA  4EB8 120E                968      JSR print
000018DE  103C 0003                969      MOVE.B #3,D0
000018E2  4E4F                     970      TRAP #15
000018E4                           971  predec_no_dash
000018E4  BABC 000000FF            972      CMP.L #$00FF,D5
000018EA  6F00 0062                973      BLE end_movem_predec
000018EE  43F8 048D                974      LEA slash, A1
000018F2  4EB8 120E                975      JSR print
000018F6                           976  predec_skip_to_d    
000018F6  3C05                     977      MOVE.W D5,D6
000018F8  E04E                     978      LSR.W #8,D6
000018FA  4281                     979      CLR.L D1
000018FC  123C 0000                980      MOVE.B #0, D1
00001900                           981  d_loop1
00001900  E31E                     982      ROL.B #1,D6
00001902  6500 0006                983      BCS d_loop1_done
00001906  5201                     984      ADD.B #1,D1
00001908  60F6                     985      BRA d_loop1
0000190A                           986  d_loop1_done
0000190A  43F8 0474                987      LEA D_reg,A1
0000190E  4EB8 120E                988      JSR print
00001912  103C 0003                989      MOVE.B #3,D0
00001916  4E4F                     990      TRAP #15
00001918  4287                     991      CLR.L D7
0000191A  1E3C 0000                992      MOVE.B #0, D7
0000191E                           993  d_loop2
0000191E  E31E                     994      ROL.B #1,D6
00001920  6400 000E                995      BCC d_loop2_done
00001924  5201                     996      ADD.B #1,D1
00001926  B23C 0007                997      CMP.B #7, D1
0000192A  6700 0004                998      BEQ d_loop2_done
0000192E  60EE                     999      BRA d_loop2
00001930                          1000  d_loop2_done
00001930  BE3C 0000               1001      CMP.B #0, D7
00001934  6F00 0018               1002      BLE end_movem_predec
00001938  43F8 048B               1003      LEA dash, A1
0000193C  4EB8 120E               1004      JSR print
00001940  43F8 0474               1005      LEA D_reg,A1
00001944  4EB8 120E               1006      JSR print
00001948  103C 0003               1007      MOVE.B #3,D0
0000194C  4E4F                    1008      TRAP #15
0000194E                          1009  end_movem_predec
0000194E  4E75                    1010      RTS
00001950                          1011      
00001950                          1012  movem_postinc:          *needs to be worked on
00001950  4285                    1013      CLR.L D5
00001952  544C                    1014      ADDA.W  #2,A4       *update current address
00001954  3A14                    1015      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001956  3C05                    1016      MOVE.W D5,D6
00001958  E04E                    1017      LSR.W #8,D6
0000195A  BC3C 0000               1018      CMP.B #$00, D6
0000195E  6700 0068               1019      BEQ postinc_skip_to_d
00001962  4281                    1020      CLR.L D1
00001964  123C 0000               1021      MOVE.B #0, D1
00001968                          1022  a_loop3
00001968  E21E                    1023      ROR.B #1,D6
0000196A  6500 0006               1024      BCS a_loop3_done
0000196E  5201                    1025      ADD.B #1,D1
00001970  60F6                    1026      BRA a_loop3
00001972                          1027  a_loop3_done
00001972  43F8 0476               1028      LEA A_reg,A1
00001976  4EB8 120E               1029      JSR print
0000197A  103C 0003               1030      MOVE.B #3,D0
0000197E  4E4F                    1031      TRAP #15
00001980  4287                    1032      CLR.L D7
00001982  1E3C 0000               1033      MOVE.B #0, D7
00001986                          1034  a_loop4
00001986  E21E                    1035      ROR.B #1,D6
00001988  6400 0010               1036      BCC a_loop4_done
0000198C  5207                    1037      ADD.B #1,D7
0000198E  5201                    1038      ADD.B #1,D1
00001990  B23C 0007               1039      CMP.B #7, D1
00001994  6700 0004               1040      BEQ a_loop4_done
00001998  60EC                    1041      BRA a_loop4
0000199A                          1042  a_loop4_done
0000199A  BE3C 0000               1043      CMP.B #0, D7
0000199E  6700 0018               1044      BEQ postinc_no_dash
000019A2  43F8 048B               1045      LEA dash, A1
000019A6  4EB8 120E               1046      JSR print
000019AA  43F8 0476               1047      LEA A_reg,A1
000019AE  4EB8 120E               1048      JSR print
000019B2  103C 0003               1049      MOVE.B #3,D0
000019B6  4E4F                    1050      TRAP #15
000019B8                          1051  postinc_no_dash
000019B8  BA3C 0000               1052      CMP.B #$00, D5
000019BC  6700 0060               1053      BEQ end_movem_postinc
000019C0  43F8 048D               1054      LEA slash, A1
000019C4  4EB8 120E               1055      JSR print
000019C8                          1056  postinc_skip_to_d   
000019C8  3C05                    1057      MOVE.W D5,D6
000019CA  4281                    1058      CLR.L D1
000019CC  123C 0000               1059      MOVE.B #0, D1
000019D0                          1060  d_loop3
000019D0  E21E                    1061      ROR.B #1,D6
000019D2  6500 0006               1062      BCS d_loop3_done
000019D6  5201                    1063      ADD.B #1,D1
000019D8  60F6                    1064      BRA d_loop3
000019DA                          1065  d_loop3_done
000019DA  43F8 0474               1066      LEA D_reg,A1
000019DE  4EB8 120E               1067      JSR print
000019E2  103C 0003               1068      MOVE.B #3,D0
000019E6  4E4F                    1069      TRAP #15
000019E8  4287                    1070      CLR.L D7
000019EA  1E3C 0000               1071      MOVE.B #0, D7
000019EE                          1072  d_loop4
000019EE  E21E                    1073      ROR.B #1,D6
000019F0  6400 000E               1074      BCC d_loop4_done
000019F4  5201                    1075      ADD.B #1,D1
000019F6  B23C 0007               1076      CMP.B #7, D1
000019FA  6700 0004               1077      BEQ d_loop4_done
000019FE  60EE                    1078      BRA d_loop4
00001A00                          1079  d_loop4_done
00001A00  BE3C 0000               1080      CMP.B #0, D7
00001A04  6F00 0018               1081      BLE end_movem_postinc
00001A08  43F8 048B               1082      LEA dash, A1
00001A0C  4EB8 120E               1083      JSR print
00001A10  43F8 0474               1084      LEA D_reg,A1
00001A14  4EB8 120E               1085      JSR print
00001A18  103C 0003               1086      MOVE.B #3,D0
00001A1C  4E4F                    1087      TRAP #15
00001A1E                          1088  end_movem_postinc
00001A1E  4E75                    1089      RTS
00001A20                          1090  
00001A20                          1091  
00001A20                          1092  * ------- End Effective Address -------*
00001A20                          1093  
00001A20                          1094  * ----- Hex to ASCII & ASCII to HEX -----*
00001A20                          1095  
00001A20                          1096  ASCIItoHex:
00001A20  4EB9 00001A2E           1097          jsr     ASCII2Hex_init  
00001A26  4EB9 00001A34           1098          jsr     conversion_loop
00001A2C  4E75                    1099          rts                    
00001A2E                          1100  
00001A2E                          1101  ASCII2Hex_init:   
00001A2E  143C 0000               1102          move.b  #0,D2       *set up counter    
00001A32  4E75                    1103          rts         
00001A34                          1104          
00001A34                          1105  conversion_loop:            
00001A34  5282                    1106          add.l   #1,D2       *increment counter
00001A36  B4BC 00000009           1107          cmp.l   #9,D2       *ends at 9
00001A3C  6700 004A               1108          BEQ     DONE        *branch when compare is true
00001A40  1819                    1109          move.b  (A1)+,D4    *Get first num
00001A42                          1110          
00001A42  B83C 0040               1111          cmp.b   #$40,D4        
00001A46  6E00 000C               1112          bgt     Letters_Cap  
00001A4A                          1113          
00001A4A  B83C 0039               1114          cmp.b   #$39,D4
00001A4E  6F00 0016               1115          BLE     Numbers      
00001A52  4E75                    1116          rts
00001A54                          1117          
00001A54                          1118  Letters_Cap:      
00001A54  B83C 0046               1119          cmp.b   #$46,D4          
00001A58  6E00 001E               1120          bgt     ERROR  
00001A5C  0404 0037               1121          sub.b   #$37,D4     
00001A60  E986                    1122          asl.l   #4,D6       
00001A62  DC84                    1123          add.l   D4,D6     
00001A64  60CE                    1124          bra     conversion_loop 
00001A66                          1125  Numbers:
00001A66  B83C 0030               1126          cmp.b   #$30,D4         
00001A6A  6D00 000C               1127          blt     ERROR        
00001A6E  0404 0030               1128          sub.b   #$30,D4      
00001A72  E986                    1129          asl.l   #4,D6        
00001A74  DC84                    1130          add.l   D4,D6     
00001A76  60BC                    1131          bra     conversion_loop
00001A78                          1132          
00001A78                          1133  ERROR:
00001A78  43F8 011E               1134          lea     ErrorMsg,A1    
00001A7C  103C 000E               1135          move.b  #14,D0
00001A80  4E4F                    1136          trap    #15
00001A82                          1137      
00001A82  103C 0009               1138          move.b  #9,D0
00001A86  4E4F                    1139          trap    #15
00001A88                          1140          
00001A88                          1141  DONE:
00001A88                          1142     
00001A88  4241                    1143          clr     D1
00001A8A  4242                    1144          clr     D2
00001A8C  4244                    1145          clr     D4
00001A8E                          1146      
00001A8E  43F8 014F               1147          lea     ASCIItoHexMsg,A1
00001A92  103C 000E               1148          move.b  #14,D0
00001A96  4E4F                    1149          trap    #15
00001A98                          1150  
00001A98  4E75                    1151          rts
00001A9A                          1152          
00001A9A                          1153  
00001A9A                          1154          
00001A9A                          1155  * -- End of Hex to ASCII & ASCII to HEX --*
00001A9A                          1156  
00001A9A                          1157  * Put program code here
00001A9A                          1158  
00001A9A  FFFF FFFF               1159      SIMHALT             ; halt simulator
00001A9E                          1160  
00001A9E                          1161  * Put variables and constants here
00001A9E                          1162  
00001A9E                          1163      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  17A8
ADDA_INS            42F
ADDA_SIZE           1308
ADDQ_INS            434
ADDR                16CA
ADD_A               12E6
ADD_INDIRECT        1748
ADD_INS             42B
ADD_REG             1730
ADD_REG_SR          1866
ANDQ_INS            45B
AND_INS             43C
ASCII2HEX_INIT      1A2E
ASCIITOHEX          1A20
ASCIITOHEXMSG       14F
AS_INS              447
A_LOOP1             1894
A_LOOP1_DONE        189E
A_LOOP2             18B2
A_LOOP2_DONE        18C6
A_LOOP3             1968
A_LOOP3_DONE        1972
A_LOOP4             1986
A_LOOP4_DONE        199A
A_REG               476
BEQ_INS             468
BGT_INS             460
BLE_INS             464
BRA_INS             46C
BYTE                407
CHECKADDRESS        10C0
CHECK_WORD          157E
CLEAR_REGISTERS     1032
CLOSE_PARAN         47B
COMMA               486
CONT                16D6
CONTINUEORNOTMSG    1CC
CONTINUE_INSTRUCTION_LS_AS_RO  140C
CONVERSION_LOOP     1A34
CR                  D
CREATORS            1F
DASH                48B
DATA                492
DATA_REG            1718
DATA_REG_SR         184E
DESTINATION         170E
DOLLAR              499
DONE                1A88
D_LOOP1             1900
D_LOOP1_DONE        190A
D_LOOP2             191E
D_LOOP2_DONE        1930
D_LOOP3             19D0
D_LOOP3_DONE        19DA
D_LOOP4             19EE
D_LOOP4_DONE        1A00
D_REG               474
EA_DEST_ADD         12CC
EA_DEST_SUB_AND_OR  139A
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             1324
END_ADDR_BUFFER     2FF
END_BRA_BCC         15A0
END_MOVEM           160C
END_MOVEM_POSTINC   1A1E
END_MOVEM_PREDEC    194E
ENTER               1220
ERROR               1A78
ERRORMSG            11E
EXITMSG             1EF
FLUSHSCREEN         111C
GETENDADDRESS       10A6
GETSTARTADDRESS     108C
HELPMSG             190
HEXTOASCIIMSG       12D
IMMEDIATE           17C6
IMM_COMPLETE        1804
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             11B4
JSR_INS             451
LEA_INS             456
LEFT                472
LETTERS_CAP         1A54
LF                  A
LONG                3FF
LS_AS_RO_MEM        1422
LS_AS_RO_REG        1404
LS_INS              444
L_IMM               1824
MEMSEARCH           10C4
MEMSEARCHLOOP       10CC
MEMSEARCH_DONE      10FA
MEM_TO_REG          15F8
MENU                106E
MOVEA_INS           425
MOVEM_DIRECTION     15D2
MOVEM_INS           41F
MOVEM_LONG          15CA
MOVEM_POSTINC       1950
MOVEM_PREDEC        187E
MOVEQ_INS           418
MOVE_A              1258
MOVE_INS            413
MOVE_MOVEA          17EC
MOVE_SIZE           1668
M_SIZE              1260
NEXT_ADD            1310
NEXT_BRA_BCC        154C
NEXT_LS_AS_RO       1450
NOP_INS             40B
NOT_INS             44D
NUMBERS             1A66
OPCODE_DECODE       111C
OPEN_PARAN          478
OR_INS              439
OUT                 11D0
POSTINC_NO_DASH     19B8
POSTINC_SKIP_TO_D   19C8
POST_INC            47D
POST_INCREMENT      1768
POUND               489
PREDEC_NO_DASH      18E4
PREDEC_SKIP_TO_D    18F6
PRE_DEC             480
PRE_DECREMENT       1788
PRINT               120E
PRINTLN             1218
PRINT_ADDQ          14BC
PRINT_ADD_ADDA      1288
PRINT_AS            1656
PRINT_B             168A
PRINT_BEQ           152C
PRINT_BGT           1544
PRINT_BLE           1538
PRINT_BRA           1520
PRINT_BRA_BCC       14F6
PRINT_CORRECT_SHIFT_ROTATION  1636
PRINT_DIRECTION     1614
PRINT_INSTRUCTION   136A
PRINT_IT            1662
PRINT_JSR           1482
PRINT_L             16A2
PRINT_LEA           1498
PRINT_LEFT          162C
PRINT_LS            165E
PRINT_LS_AS_RO      13B8
PRINT_MOVEM         15A8
PRINT_MOVEQ         11D2
PRINT_MOVE_MOVEA    123E
PRINT_NOP           122A
PRINT_NOT           1458
PRINT_OR            1366
PRINT_RTS           1234
PRINT_SUB           135E
PRINT_SUB_AND_OR    132C
PRINT_W             1696
RETURN              48F
RIGHT               470
RO_INS              44A
RTS_INS             40F
SCREENFLUSH         1112
SIZE                16AE
SLASH               48D
SPACE               484
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   1FF
SUB_INS             440
TAB                 9
TERMINATEORCONT     1106
WORD                403
W_IMM               1808
XN                  1842
