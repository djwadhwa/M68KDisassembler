00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/10/2020 10:53:45 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius Hartanto',CR,LF,0
00000057                            12  
00000057= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
00000098= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000D0= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000ED= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
00000127= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
00000136                            18  
00000136= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
00000158= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
0000017C                            21  
0000017C= 2D 2D 2D 46 69 6E ...     22  EndOfMemLoop        dc.b    '---Finished Reading Instructions---',CR,LF,0
000001A2= 50 72 65 73 73 20 ...     23  FlushScreenMsg      dc.b    'Press ENTER to view the next set of instructions',0
000001D3= 49 6E 70 75 74 73 ...     24  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
0000020F= 57 6F 75 6C 64 20 ...     25  ContinueOrNotMsg    dc.b    'Would you like to Disassemble more data or quit (y/n)',0
00000245= 45 78 69 74 69 6E ...     26  ExitMsg             dc.b    'Exiting Program',0
00000255                            27  
00000255                            28  *size
00000255= 2E 4C 20 00               29  long                DC.B    '.L ',0
00000259= 2E 57 20 00               30  word                DC.B    '.W ',0
0000025D= 2E 42 20 00               31  byte                DC.B    '.B ',0
00000261                            32  
00000261                            33  *instructions
00000261= 4E 4F 50 00               34  nop_ins             DC.B    'NOP',0
00000265= 52 54 53 00               35  rts_ins             DC.B    'RTS',0
00000269= 4D 4F 56 45 00            36  move_ins            DC.B    'MOVE',0
0000026E= 4D 4F 56 45 51 20 00      37  moveq_ins           DC.B    'MOVEQ ',0
00000275= 4D 4F 56 45 4D 00         38  movem_ins           DC.B    'MOVEM',0
0000027B= 4D 4F 56 45 41 00         39  movea_ins           DC.B    'MOVEA',0
00000281= 41 44 44 00               40  add_ins             DC.B    'ADD',0
00000285= 41 44 44 41 00            41  adda_ins            DC.B    'ADDA',0
0000028A= 41 44 44 51 00            42  addq_ins            DC.B    'ADDQ',0
0000028F= 4F 52 00                  43  or_ins              DC.B    'OR',0
00000292= 41 4E 44 00               44  and_ins             DC.B    'AND',0
00000296= 53 55 42 00               45  sub_ins             DC.B    'SUB',0
0000029A= 4C 53 00                  46  ls_ins              DC.B    'LS',0
0000029D= 41 53 00                  47  as_ins              DC.B    'AS',0
000002A0= 52 4F 00                  48  ro_ins              DC.B    'RO',0
000002A3= 4E 4F 54 00               49  not_ins             DC.B    'NOT',0
000002A7= 4A 53 52 20 00            50  jsr_ins             DC.B    'JSR ',0
000002AC= 4C 45 41 20 00            51  lea_ins             DC.B    'LEA ',0
000002B1= 41 44 44 51 00            52  andq_ins            DC.B    'ADDQ',0
000002B6= 42 47 54 00               53  bgt_ins             DC.B    'BGT',0
000002BA= 42 4C 45 00               54  ble_ins             DC.B    'BLE',0
000002BE= 42 45 51 00               55  beq_ins             DC.B    'BEQ',0
000002C2= 42 52 41 00               56  bra_ins             DC.B    'BRA',0
000002C6                            57  
000002C6                            58  *direction
000002C6= 52 00                     59  right               DC.B    'R',0
000002C8= 4C 00                     60  left                DC.B    'L',0
000002CA                            61  
000002CA                            62  *EA
000002CA= 44 00                     63  D_reg               DC.B    'D',0
000002CC= 41 00                     64  A_reg               DC.B    'A',0
000002CE= 28 41 00                  65  open_paran          DC.B    '(A',0
000002D1= 29 00                     66  close_paran         DC.B    ')',0
000002D3= 29 2B 00                  67  post_inc            DC.B    ')+',0
000002D6= 2D 28 41 00               68  pre_dec             DC.B    '-(A',0
000002DA                            69  
000002DA                            70  *extra
000002DA= 20 00                     71  space               DC.B    ' ',0
000002DC= 2C 20 00                  72  comma               DC.B    ', ',0
000002DF= 23 00                     73  pound               DC.B    '#',0
000002E1= 2D 00                     74  dash                DC.B    '-',0
000002E3= 2F 00                     75  slash               DC.B    '/',0
000002E5  =00000009                 76  tab                 EQU     $9
000002E5= 0D 0A 00                  77  return              DC.B    CR,LF,0
000002E8= 44 41 54 41 20 24 00      78  data                DC.B    'DATA $',0
000002EF= 49 6E 76 61 6C 69 ...     79  ea                  DC.B    'Invalid Effective Address', 0
00000309= 24 00                     80  dollar              DC.B    '$',0
0000030B                            81      
00001000                            82      ORG    $1000    *Start at address $1000
00001000                            83  START:                  ; first instruction of program
00001000                            84  *----- Testing specific opcodes------*
00001000                            85  
00001000                            86  
00001000  33FC 467C 00009500        87      MOVE.W #$467C, $00009500 *NOT.W #1234
00001008  33FC 1234 00009502        88      MOVE.W #$1234, $00009502
00001010  33FC E7FC 00009504        89      MOVE.W #$E7FC, $00009504 *ROL #$5678
00001018  33FC 5678 00009506        90      MOVE.W #$5678, $00009506
00001020  33FC E1FC 00009508        91      MOVE.W #$E1FC, $00009508 *ASL #$9ABC
00001028  33FC 9ABC 0000950A        92      MOVE.W #$9ABC, $0000950A
00001030  33FC E2FC 0000950C        93      MOVE.W #$E2FC, $0000950C *LSR #$DEF1
00001038  33FC DEF1 0000950E        94      MOVE.W #$DEF1, $0000950E
00001040                            95      
00001040                            96      
00001040  33FC 82F8 00009600        97      MOVE.W #$82F8, $00009600 *DIVU.W    $12,D1
00001048  33FC 0012 00009602        98      MOVE.W #$0012, $00009602 
00001050  33FC C3F9 00009604        99      MOVE.W #$C3F9, $00009604 *MULS.W  $12345678,D1
00001058  23FC 12345678 00009606   100      MOVE.L #$12345678, $00009606 
00001062  33FC 92C1 0000960A       101      MOVE.W #$92C1, $0000960A *SUBA.W     D1,A1G
0000106A                           102      
0000106A                           103      
0000106A                           104  *---------- Beginning Messages ----------*
0000106A                           105      
0000106A  103C 000E                106      move.b      #14,D0
0000106E  43F8 0000                107      lea         StartingMsg,A1 
00001072  4E4F                     108      trap        #15
00001074                           109      
00001074  103C 000E                110      move.b      #14,D0
00001078  43F8 001F                111      lea         Creators,A1
0000107C  4E4F                     112      trap        #15
0000107E                           113      
0000107E  4EB9 000010D0            114      jsr         MENU
00001084                           115      
00001084                           116  * ---------- END OF PROGRAM -------------*
00001084                           117  
00001084  103C 000E                118      move.b      #14,D0
00001088  43F8 0245                119      lea         ExitMsg,A1 
0000108C  4E4F                     120      trap        #15
0000108E                           121      
0000108E  103C 0009                122      move.b      #9,D0
00001092  4E4F                     123      trap        #15
00001094                           124  * ---------------------------------------*
00001094                           125      
00001094                           126  *-- End of Opening and Ending Messages --*
00001094                           127  
00001094                           128  
00001094                           129  
00001094                           130  *--------- Start of I/O Section ---------*
00001094                           131  
00001094                           132  Clear_Registers:
00001094  4280                     133      clr.l     D0
00001096  4281                     134      clr.l     D1
00001098  4282                     135      clr.l     D2
0000109A  4283                     136      clr.l     D3
0000109C  4284                     137      clr.l     D4
0000109E  4285                     138      clr.l     D5
000010A0  4286                     139      clr.l     D6
000010A2  4287                     140      clr.l     D7
000010A4                           141      
000010A4  207C 00000000            142      movea.l   #0,A0
000010AA  227C 00000000            143      movea.l   #0,A1
000010B0  247C 00000000            144      movea.l   #0,A2
000010B6  267C 00000000            145      movea.l   #0,A3
000010BC  287C 00000000            146      movea.l   #0,A4
000010C2  2A7C 00000000            147      movea.l   #0,A5
000010C8  2C7C 00000000            148      movea.l   #0,A6
000010CE  4E75                     149      rts
000010D0                           150  
000010D0                           151  MENU:
000010D0  4EB8 1094                152      jsr         Clear_Registers
000010D4  4EB9 00001124            153      jsr         GetStartAddress
000010DA  4EB9 00001144            154      jsr         GetEndAddress 
000010E0  BBCC                     155      cmp.l       A4, A5
000010E2  6F00 0006                156      ble         invalid_input
000010E6  6000 0014                157      bra         menu_cont
000010EA                           158  invalid_input
000010EA  43F8 00ED                159      lea         EndAddressInc, A1
000010EE  103C 000E                160      move.b      #14, D0
000010F2  4E4F                     161      trap        #15
000010F4  4EB9 0000131A            162      jsr         enter
000010FA  60D4                     163      bra         MENU
000010FC                           164  menu_cont
000010FC  B9FC 00009000            165      cmp.l #$00009000, A4
00001102  6D00 0006                166      blt invalid_address_provided
00001106  6000 0014                167      bra resume
0000110A                           168  invalid_address_provided
0000110A  43F8 00D0                169      lea         InputIsInc, A1
0000110E  103C 000E                170      move.b      #14, D0
00001112  4E4F                     171      trap        #15
00001114  4EB9 0000131A            172      jsr         enter
0000111A  60B4                     173      bra         MENU
0000111C                           174  resume
0000111C  4EB9 0000117C            175      jsr         MemSearch
00001122  4E75                     176      rts
00001124                           177      
00001124                           178  GetStartAddress:         *Display input message
00001124  103C 000E                179      move.b      #14, D0
00001128  43F8 0057                180      lea         InputMsg1,A1
0000112C  4E4F                     181      trap        #15
0000112E  227C 00000000            182      MOVEA.L     #0, A1
00001134  103C 0002                183      move.b      #2,D0
00001138  4E4F                     184      trap        #15   
0000113A  4EB9 00001BD2            185      jsr         ASCIItoHex              *conversion to Hex
00001140                           186      * Address Located in D6
00001140  2846                     187      movea.l     D6,A4           *move into address register 4
00001142  4E75                     188      rts
00001144                           189      
00001144                           190  GetEndAddress:
00001144  103C 000E                191      move.b      #14,D0          *Display input message
00001148  43F8 0098                192      lea         InputMsg2,A1
0000114C  4E4F                     193      trap        #15
0000114E  227C 00000000            194      MOVEA.L     #0, A1
00001154  103C 0002                195      move.b      #2,D0
00001158  4E4F                     196      trap        #15
0000115A                           197      
0000115A  4EB9 00001BD2            198      jsr         ASCIItoHex      *conversion to hex
00001160                           199      * Address Located in D6 (overwrite)
00001160  2A46                     200      movea.l     D6,A5           *move into address register 5
00001162  4E75                     201      rts
00001164                           202  
00001164                           203  
00001164                           204  ClearScreen:
00001164  43F8 02E5                205      lea         return,A1
00001168  103C 000E                206      move.b      #14,D0
0000116C  4E4F                     207      trap        #15
0000116E  B27C 0028                208      cmp.w       #40,D1
00001172  6700 0006                209      beq         ClearDone
00001176  5241                     210      add.w       #1,D1
00001178  60EA                     211      bra         ClearScreen
0000117A                           212      
0000117A                           213  ClearDone:
0000117A  4E75                     214      rts
0000117C                           215      
0000117C                           216  MemSearch:
0000117C  7200                     217      move.l      #0,D1
0000117E  4EB8 1164                218      jsr         ClearScreen
00001182                           219      * Set up instruction counter and place onto stack
00001182  303C 0000                220      move.w      #0,D0
00001186  3F00                     221      move.w      D0,-(SP)
00001188  4EB9 00001190            222      jsr         MemSearchLoop
0000118E  4E75                     223      rts
00001190                           224      
00001190                           225  MemSearchLoop:
00001190                           226      
00001190                           227      * Check if we reached the end address
00001190  BBCC                     228      cmp.l       A4,A5
00001192  6700 0036                229      beq         MemSearch_Done
00001196                           230      
00001196                           231      * Get data from memory
00001196  4241                     232      CLR D1
00001198  3414                     233      move.w      (A4),D2
0000119A  3602                     234      move.w      D2, D3  mutable copy in D3
0000119C                           235      * OPCODE Word Located in D2, mutable copy in D3
0000119C  220C                     236      MOVE.L      A4, D1
0000119E  143C 0010                237      MOVE.B      #16, D2
000011A2  103C 000F                238      MOVE.B      #15, D0     print address of instruction
000011A6  4E4F                     239      TRAP        #15
000011A8  3403                     240      MOVE.W      D3,D2
000011AA  43F8 02DA                241      LEA         space,A1
000011AE  4EB9 00001308            242      JSR         print
000011B4  4EB9 0000123C            243      jsr         OPCODE_DECODE    
000011BA                           244      
000011BA  544C                     245      adda.w      #2,A4
000011BC                           246      
000011BC                           247      * Call back counter from the stack
000011BC  301F                     248      move.w      (SP)+,D0
000011BE  5200                     249      add.b       #1,D0
000011C0  4EB9 0000120C            250      jsr         ScreenFlush_Check
000011C6  3F00                     251      move.w      D0,-(SP)
000011C8                           252      
000011C8  60C6                     253      bra         MemSearchLoop
000011CA                           254      
000011CA                           255  MemSearch_Done
000011CA  43F8 017C                256      lea         EndOfMemLoop,A1 
000011CE  4EB9 00001308            257      jsr         print
000011D4  43F8 02E5                258      lea         return, A1
000011D8  4EB9 00001308            259      jsr         print
000011DE  43F8 020F                260      lea         ContinueOrNotMsg, A1
000011E2  4EB9 00001308            261      jsr         print
000011E8  103C 0005                262      MOVE.B      #5, D0
000011EC  4E4F                     263      TRAP        #15
000011EE  4EB9 0000131A            264      jsr         enter
000011F4  B23C 0079                265      CMP.B       #121, D1    
000011F8  6700 FED6                266      beq         MENU
000011FC  103C 000E                267      move.b      #14,D0
00001200  43F8 0245                268      lea         ExitMsg, A1 
00001204  4E4F                     269      trap        #15
00001206  103C 0009                270      move.b      #9,D0
0000120A  4E4F                     271      trap        #15
0000120C                           272  
0000120C                           273  ScreenFlush_Check:
0000120C  B03C 0024                274      cmp.b       #36,D0 * 31
00001210  6700 0004                275      beq         FlushScreen
00001214  4E75                     276      rts 
00001216                           277  
00001216                           278  FlushScreen:
00001216  43F8 01A2                279      lea         FlushScreenMsg,A1
0000121A  103C 000E                280      move.b      #14,D0
0000121E  4E4F                     281      trap        #15
00001220  4EB9 00001228            282      jsr         FlushScreen_Input
00001226  4E75                     283      rts
00001228                           284  
00001228                           285  FlushScreen_Input:
00001228  4241                     286      clr     D1
0000122A  103C 0005                287      move.b  #5,D0
0000122E  4E4F                     288      trap    #15
00001230  B23C 000D                289      cmp.b   #13,D1
00001234  6700 0004                290      beq     Enter_Press_True    
00001238  60EE                     291      bra     FlushScreen_Input
0000123A                           292      
0000123A                           293  Enter_Press_True:
0000123A  4E75                     294      rts
0000123C                           295  
0000123C                           296  * -------- Start of Opcode Section -------*    
0000123C                           297  
0000123C                           298  OPCODE_DECODE:
0000123C                           299      * Begin OPCODE Decoding here
0000123C                           300      * Check first four bits and begin
0000123C                           301      * if-branch breakdown
0000123C  4284                     302      CLR.L D4
0000123E  4285                     303      CLR.L D5
00001240  4286                     304      CLR.L D6
00001242  4287                     305      CLR.L D7
00001244                           306  
00001244                           307      
00001244  B47C 4E71                308      CMP.W #$4E71, D2        
00001248  6700 00DA                309      BEQ print_nop           *check if value is NOP
0000124C                           310      
0000124C  B47C 4E75                311      CMP.W #$4E75, D2        
00001250  6700 00DC                312      BEQ print_rts           *check if value is RTS
00001254                           313      
00001254                           314      * Mask out only the first 4 bits
00001254  C67C F000                315      AND.W #$F000,D3
00001258                           316      
00001258  B67C 9000                317      CMP.W #$9000,D3
0000125C  6700 0210                318      BEQ print_sub_and_or    *check if value is SUB
00001260                           319      
00001260  B67C 6000                320      CMP.W #$6000,D3
00001264  6700 041E                321      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
00001268                           322      
00001268  B67C 8000                323      CMP.W #$8000, D3
0000126C  6700 0200                324      BEQ print_sub_and_or    *check if value is OR
00001270                           325  
00001270  B67C C000                326      CMP.W #$C000,D3
00001274  6700 01F8                327      BEQ print_sub_and_or    *check if value is AND
00001278                           328      
00001278  B67C D000                329      CMP.W #$D000,D3
0000127C  6700 0148                330      BEQ print_add_adda      *check if value is ADD or ADDA
00001280                           331      
00001280  B67C E000                332      CMP.W #$E000,D3
00001284  6700 02AC                333      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
00001288                           334      
00001288  B67C 7000                335      CMP.W #$7000,D3
0000128C  6700 00AA                336      BEQ print_moveq     *check if value is MOVEQ
00001290                           337      
00001290  B47C 1000                338      CMP.W #$1000,D2
00001294  6D00 003E                339      BLT invalid
00001298  B47C 4000                340      CMP.W #$4000,D2
0000129C  6D00 00DE                341      BLT print_move_movea    *check if value is MOVE or MOVEA
000012A0                           342      
000012A0                           343      * Mask out only the first 8 bits
000012A0  3602                     344      MOVE.W D2, D3
000012A2  C67C FF00                345      AND.W #$FF00,D3
000012A6                           346      
000012A6  B67C 4600                347      CMP.W #$4600,D3
000012AA  6700 033A                348      BEQ print_not           *check if value is NOT
000012AE                           349      
000012AE  B67C 4E00                350      CMP.W #$4E00,D3
000012B2  6700 035C                351      BEQ print_jsr           *check if value is JSR
000012B6                           352      
000012B6                           353      * Mask out only the first 4 bits and the 8th bit
000012B6  3602                     354      MOVE.W D2,D3
000012B8  C67C F100                355      AND.W #$F100, D3
000012BC                           356      
000012BC  B67C 4000                357      CMP.W #$4000, D3
000012C0  6700 0474                358      BEQ print_movem         *check if value is MOVEM
000012C4                           359      
000012C4  B67C 4100                360      CMP.W #$4100, D3
000012C8  6700 035C                361      BEQ print_lea           *check if value is LEA
000012CC                           362      
000012CC  B67C 5000                363      CMP.W #$5000,D3
000012D0  6700 0378                364      BEQ print_addq          *check if value is ANDQ     
000012D4                           365   
000012D4                           366  invalid 
000012D4  43F8 02E8                367      LEA data, A1
000012D8  4EB9 00001308            368      JSR print
000012DE  2202                     369      MOVE.L D2, D1
000012E0  143C 0010                370      MOVE.B #16, D2
000012E4  103C 000F                371      MOVE.B  #15, D0     
000012E8  4E4F                     372      TRAP #15
000012EA  4EB9 0000131A            373      JSR enter
000012F0  6000 0014                374      BRA out
000012F4                           375  invalid_ea
000012F4  43F8 02EF                376      LEA ea, A1
000012F8  548C                     377      ADD.L #2, A4
000012FA  4EB9 00001308            378      JSR print
00001300  4EB9 0000131A            379      JSR enter
00001306  4E75                     380  out rts
00001308                           381    
00001308                           382  * -------- End of Opcode Section --------*   
00001308                           383  
00001308                           384  * --------- Print Instructions ----------*
00001308                           385  
00001308                           386  print:
00001308  4240                     387      CLR D0 
0000130A  103C 000E                388      MOVE.B #14,D0
0000130E  4E4F                     389      TRAP #15
00001310  4E75                     390      RTS
00001312                           391  
00001312                           392  println:
00001312  103C 000D                393      MOVE.B #13, D0
00001316  4E4F                     394      TRAP #15
00001318  4E75                     395      RTS
0000131A                           396      
0000131A                           397  enter: 
0000131A  43F8 02E5                398      LEA return, A1
0000131E  4EB8 1308                399      JSR print
00001322  4E75                     400      RTS
00001324                           401      
00001324                           402  print_nop
00001324  43F8 0261                403      LEA nop_ins, A1
00001328  4EB8 1312                404      JSR println
0000132C  60D8                     405      BRA out
0000132E                           406  
0000132E                           407  print_rts
0000132E  43F8 0265                408      LEA rts_ins, A1
00001332  4EB8 1312                409      JSR println
00001336  60CE                     410      BRA out
00001338                           411      
00001338                           412  print_moveq
00001338  43F8 026E                413      lea moveq_ins, A1   *print MOVEQ
0000133C  4EB8 1308                414      jsr print
00001340  3602                     415      move.w  D2,D3
00001342  C67C 00FF                416      and.w   #$00FF,D3   * Figure out the immediate address value
00001346  43F8 02DF                417      lea pound,A1        *print '#'
0000134A  4EB8 1308                418      jsr print
0000134E  43F8 0309                419      LEA dollar, A1
00001352  4EB8 1308                420      JSR print
00001356  3203                     421      move.w  D3,D1
00001358  3602                     422      MOVE.W D2,D3
0000135A  343C 0010                423      MOVE.W #16, D2
0000135E  103C 000F                424      move.b  #15,D0
00001362  4E4F                     425      trap    #15         *print immediate address value
00001364  43F8 02DC                426      lea comma,A1        *print comma
00001368  4EB8 1308                427      jsr print
0000136C  3403                     428      MOVE.W D3, D2
0000136E  3A02                     429      MOVE.W D2, D5
00001370  4EB9 00001A40            430      JSR data_reg_sr     *figure out data address
00001376  4EB8 131A                431      jsr enter           *print out enter
0000137A  608A                     432      bra out
0000137C                           433      
0000137C                           434  print_move_movea
0000137C  3602                     435      MOVE.W D2, D3       
0000137E  C67C 01C0                436      AND.W #$01C0, D3
00001382  B67C 0040                437      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001386  6700 000E                438      BEQ move_a
0000138A  43F8 0269                439      LEA move_ins, A1 *print Instruction 
0000138E  4EB8 1308                440      JSR print
00001392  6000 000A                441      BRA m_size
00001396                           442  move_a          *if instruction is MOVEA
00001396  43F8 027B                443      LEA movea_ins, A1
0000139A  4EB8 1308                444      JSR print
0000139E                           445  m_size              *determine instruction size
0000139E  4EB9 0000185A            446      JSR move_size
000013A4  4EB9 000018BC            447      JSR addr        *determine the source address
000013AA  43F8 02DC                448      LEA comma, A1   *print comma
000013AE  4EB8 1308                449      JSR print
000013B2  4207                     450      CLR.B D7
000013B4  1E3C 0001                451      MOVE.B #1, D7   *determine destination address
000013B8  4EB9 000018BC            452      JSR addr
000013BE  4EB8 131A                453      JSR enter       *print enter
000013C2  6000 FF42                454      BRA out
000013C6                           455      
000013C6                           456  print_add_adda
000013C6  3602                     457      MOVE.W D2, D3   
000013C8  C63C 00C0                458      AND.B #$C0, D3
000013CC  B63C 00C0                459      CMP.B #$C0, D3      *determine if ADD or ADDA
000013D0  6700 0052                460      BEQ add_a
000013D4                           461      *if just ADD then print instruction
000013D4  43F8 0281                462      LEA add_ins, A1
000013D8  4EB8 1308                463      JSR print
000013DC                           464      *print instruction size for ADD
000013DC  4EB9 000018A0            465      JSR size
000013E2                           466      *determine direction of ADD, Dn -> EA or EA -> Dn
000013E2  3602                     467      MOVE.W D2,D3
000013E4  C67C 0100                468      AND.W #$0100, D3
000013E8  B67C 0100                469      CMP.W #$0100, D3
000013EC  6700 001C                470      BEQ ea_dest_add 
000013F0  4EB9 000018BC            471      JSR addr            *if Direction bit is 0
000013F6  43F8 02DC                472      LEA comma, A1
000013FA  4EB8 1308                473      JSR print
000013FE  3A02                     474      MOVE.W D2,D5
00001400  4EB9 00001A40            475      JSR data_reg_sr
00001406  6000 005E                476      BRA end_add
0000140A                           477  ea_dest_add             *if Direction bit is 1
0000140A  3A02                     478      MOVE.W D2,D5
0000140C  4EB9 00001A40            479      JSR data_reg_sr
00001412  43F8 02DC                480      LEA comma, A1
00001416  4EB8 1308                481      JSR print
0000141A  4EB9 000018BC            482      JSR addr
00001420  6000 0044                483      BRA end_add
00001424                           484  add_a                   *if instruction is ADDA
00001424  43F8 0285                485      LEA adda_ins, A1
00001428  4EB8 1308                486      JSR print
0000142C                           487      *print instruction size for ADDA (either W or L)
0000142C  3602                     488      MOVE.W D2,D3
0000142E  C67C 0100                489      AND.W #$0100, D3
00001432  B67C 0100                490      CMP.W #$0100, D3
00001436  6700 000E                491      BEQ adda_size
0000143A  43F8 0259                492      LEA word, A1
0000143E  4EB8 1308                493      JSR print
00001442  6000 000E                494      BRA next_add
00001446                           495  adda_size
00001446  43F8 0255                496      LEA long,A1
0000144A  4EB8 1308                497      JSR print
0000144E  183C 0080                498      MOVE.B #$80, D4
00001452                           499  next_add                *print effective address for ADDA
00001452  4EB9 000018BC            500      JSR addr            
00001458  43F8 02DC                501      LEA comma, A1
0000145C  4EB8 1308                502      JSR print
00001460  4EB9 00001A58            503      JSR add_reg_sr
00001466                           504  end_add                 *complete instruction printing by printing enter
00001466  4EB8 131A                505      JSR enter
0000146A  6000 FE9A                506      BRA out
0000146E                           507  
0000146E                           508  print_sub_and_or
0000146E                           509      *determine if instruction is SUB, AND, or OR.
0000146E  3602                     510      MOVE.W D2, D3
00001470  C67C F0C0                511      AND.W #$F0C0, D3
00001474  B67C C0C0                512      CMP.W #$C0C0, D3
00001478  6700 0090                513      BEQ mul_div
0000147C  B67C 80C0                514      CMP.W #$80C0, D3
00001480  6700 0088                515      BEQ mul_div
00001484  C67C F000                516      AND.W #$F000,D3
00001488  B67C 8000                517      CMP.W #$8000, D3
0000148C  6700 0028                518      BEQ print_or
00001490  B67C 9000                519      CMP.W #$9000, D3
00001494  6700 000A                520      BEQ print_sub
00001498  43F8 0292                521      LEA and_ins, A1
0000149C  6000 001C                522      BRA print_instruction
000014A0                           523  print_sub
000014A0  3602                     524      MOVE.W D2, D3
000014A2  C67C 00C0                525      AND.W #$00C0, D3
000014A6  B63C 00C0                526      CMP.B #$C0, D3
000014AA  6700 FE28                527      BEQ invalid
000014AE  43F8 0296                528      LEA sub_ins, A1
000014B2  6000 0006                529      BRA print_instruction
000014B6                           530  print_or
000014B6  43F8 028F                531      LEA or_ins, A1
000014BA                           532  print_instruction       *print correct instruction
000014BA  4EB8 1308                533      JSR print
000014BE  4EB9 000018A0            534      JSR size            *print instruction size
000014C4  3602                     535      MOVE.W D2,D3
000014C6                           536  *determine direction of ADD, Dn -> EA or EA -> Dn   
000014C6  C67C 0100                537      AND.W #$0100, D3
000014CA  B67C 0100                538      CMP.W #$0100, D3
000014CE  6700 001C                539      BEQ ea_dest_sub_and_or
000014D2  4EB9 000018BC            540      JSR addr            *if Direction bit is 0
000014D8  43F8 02DC                541      LEA comma, A1
000014DC  4EB8 1308                542      JSR print
000014E0  3A02                     543      MOVE.W D2,D5
000014E2  4EB9 00001A40            544      JSR data_reg_sr
000014E8  6000 FF7C                545      BRA end_add
000014EC                           546  ea_dest_sub_and_or      *if Direction bit is 1
000014EC  3A02                     547      MOVE.W D2,D5
000014EE  4EB9 00001A40            548      JSR data_reg_sr
000014F4  43F8 02DC                549      LEA comma, A1
000014F8  4EB8 1308                550      JSR print
000014FC  4EB9 000018BC            551      JSR addr
00001502                           552      *complete instruction printing by printing enter
00001502  4EB8 131A                553      JSR enter
00001506  6000 FDFE                554      BRA out
0000150A                           555      
0000150A                           556  mul_div             *deal with MULU and DIVU cases
0000150A  4283                     557      CLR.L D3
0000150C  3602                     558      MOVE.W D2,D3
0000150E  C67C 00FF                559      AND.W #$00FF, D3
00001512  B6BC 000000F8            560      CMP.L #$00F8, D3
00001518  6D00 FDBA                561      BLT invalid
0000151C  B6BC 000000F9            562      CMP.L #$00F9, D3
00001522  6700 0008                563      BEQ mul_div_long
00001526  544C                     564      ADDA.W #2,A4
00001528  6000 FDAA                565      BRA invalid
0000152C                           566  mul_div_long
0000152C  584C                     567      ADDA.W #4,A4
0000152E  6000 FDA4                568      BRA invalid
00001532                           569      
00001532                           570  print_ls_as_ro
00001532                           571      *figure out if shift or rotation are memory or register based               
00001532  3602                     572      MOVE.W D2, D3
00001534  C63C 00C0                573      AND.B #$C0, D3
00001538  B63C 00C0                574      CMP.B #$C0, D3
0000153C  6700 0072                575      BEQ ls_as_ro_mem
00001540  3602                     576      MOVE.W D2, D3
00001542  E60B                     577      LSR.B #3, D3
00001544                           578      *print correct instruction type (logical shift, arithmetic shift, or rotation)
00001544  4EB9 00001828            579      JSR print_correct_shift_rotation
0000154A  4EB9 00001806            580      JSR print_direction     *print direction
00001550  4EB9 000018A0            581      JSR size                *print size
00001556  3602                     582      MOVE.W D2, D3
00001558  C63C 0020                583      AND.B #$20,D3
0000155C  B63C 0020                584      CMP.B #$20, D3
00001560                           585      *determine if instruction is using immediate address or register
00001560  6700 0030                586      BEQ ls_as_ro_reg     
00001564  43F8 02DF                587      LEA pound, A1        *if immediate address print '#'
00001568  4EB8 1308                588      JSR print
0000156C                           589      *print immediate address rotation value
0000156C  3C02                     590      MOVE.W D2,D6
0000156E  EF5E                     591      ROL.W #7,D6
00001570  CC7C 0007                592      AND.W #$0007, D6
00001574  43F8 0309                593      LEA dollar, A1
00001578  4EB8 1308                594      JSR print
0000157C  4281                     595      CLR.L D1
0000157E  3206                     596      MOVE.W D6, D1
00001580  3602                     597      MOVE.W D2, D3
00001582  143C 0010                598      MOVE.B #16, D2
00001586  103C 000F                599      MOVE.B #15, D0
0000158A  4E4F                     600      TRAP #15
0000158C  3403                     601      MOVE.W D3,D2
0000158E  6000 000A                602      BRA continue_instruction_ls_as_ro
00001592                           603  ls_as_ro_reg            *if instruction is using register to shift values in another register
00001592  3A02                     604      MOVE.W D2,D5
00001594  4EB9 00001A40            605      JSR data_reg_sr
0000159A                           606  continue_instruction_ls_as_ro *complete instrcuction
0000159A  43F8 02DC                607      LEA comma, A1       *print comma
0000159E  4EB8 1308                608      JSR print
000015A2  3A02                     609      MOVE.W D2,D5
000015A4  EE5D                     610      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
000015A6  4EB9 00001A40            611      JSR data_reg_sr     *determine destination data register to perform instruction on
000015AC  6000 0030                612      BRA next_ls_as_ro   *finish printing instruction
000015B0                           613  ls_as_ro_mem            *check if immediate address is being shifted or rotated
000015B0  3602                     614      MOVE.W D2, D3
000015B2  C63C 003F                615      AND.B #$3F, D3
000015B6  B63C 003C                616      CMP.B #$3C, D3
000015BA  6700 FD38                617      BEQ invalid_ea  *ROL #4 <- not allowed (immediate addressing)
000015BE                           618      *if not immediate adress print normally 
000015BE  3602                     619      MOVE.W D2, D3
000015C0  EF5B                     620      ROL.W #7, D3    
000015C2  4EB9 00001828            621      JSR print_correct_shift_rotation
000015C8  3602                     622      MOVE.W D2,D3
000015CA  4EB9 00001806            623      JSR print_direction
000015D0  43F8 0259                624      LEA word, A1
000015D4  4EB8 1308                625      JSR print
000015D8  4EB9 000018BC            626      JSR addr
000015DE                           627  next_ls_as_ro
000015DE  4EB8 131A                628      JSR enter
000015E2  6000 FD22                629      BRA out
000015E6                           630      
000015E6                           631  print_not
000015E6  3602                     632      MOVE.W D2, D3
000015E8  C63C 003F                633      AND.B #$3F, D3
000015EC  B63C 003C                634      CMP.B #$3C, D3
000015F0  6700 FD02                635      BEQ invalid_ea  *NOT #4 <- not allowed (immediate addressing)
000015F4  43F8 02A3                636      LEA not_ins, A1 *print instruction
000015F8  4EB8 1308                637      JSR print
000015FC  4EB9 000018A0            638      JSR size
00001602  4EB9 000018BC            639      JSR addr
00001608  4EB8 131A                640      JSR enter
0000160C  6000 FCF8                641      BRA out
00001610                           642  
00001610                           643  print_jsr
00001610  43F8 02A7                644      LEA jsr_ins, A1 *print instruction
00001614  4EB8 1308                645      JSR print
00001618  4EB9 000018BC            646      JSR addr    *print address
0000161E  4EB8 131A                647      JSR enter   *print enter (next line)
00001622  6000 FCE2                648      BRA out
00001626                           649  
00001626                           650  print_lea
00001626  43F8 02AC                651      LEA lea_ins, A1 *print instruction
0000162A  4EB8 1308                652      JSR print   
0000162E  4EB9 000018BC            653      JSR addr    *print address
00001634  43F8 02DC                654      LEA comma, A1   *print comma
00001638  4EB8 1308                655      JSR print
0000163C  4EB9 00001A58            656      JSR add_reg_sr *print destination address register
00001642  4EB8 131A                657      JSR enter
00001646  6000 FCBE                658      BRA out
0000164A                           659  
0000164A                           660  print_addq
0000164A  43F8 028A                661      LEA addq_ins, A1    *print instruction
0000164E  4EB8 1308                662      JSR print
00001652  4EB9 000018A0            663      JSR size            *print instruction size
00001658  43F8 02DF                664      LEA pound, A1
0000165C  4EB8 1308                665      JSR print           *print '#' for immediate addressing
00001660  3C02                     666      MOVE.W D2,D6
00001662  EF5E                     667      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
00001664  CC7C 0007                668      AND.W #$0007, D6
00001668  4EB9 00001A34            669      JSR Xn
0000166E  43F8 02DC                670      LEA comma, A1       *print comma
00001672  4EB8 1308                671      JSR print
00001676  4EB9 000018BC            672      JSR addr            *print destination address
0000167C  4EB8 131A                673      JSR enter
00001680  6000 FC84                674      BRA out
00001684                           675  
00001684                           676  print_bra_bcc           *needs comments
00001684  3602                     677      MOVE.W D2,D3
00001686  C67C 0F00                678      AND.W #$0F00, D3
0000168A  B67C 0000                679      CMP.W #$0000, D3
0000168E  6700 001E                680      BEQ print_bra
00001692  B67C 0700                681      CMP.W #$0700, D3
00001696  6700 0022                682      BEQ print_beq
0000169A  B67C 0E00                683      CMP.W #$0E00, D3
0000169E  6700 0032                684      BEQ print_bgt
000016A2  B67C 0F00                685      CMP.W #$0F00, D3
000016A6  6700 001E                686      BEQ print_ble
000016AA  6000 FC28                687      BRA invalid
000016AE                           688  print_bra
000016AE  43F8 02C2                689      LEA bra_ins, A1
000016B2  4EB8 1308                690      JSR print
000016B6  6000 0022                691      BRA next_bra_bcc
000016BA                           692  print_beq
000016BA  43F8 02BE                693      LEA beq_ins, A1
000016BE  4EB8 1308                694      JSR print
000016C2  6000 0016                695      BRA next_bra_bcc
000016C6                           696  print_ble
000016C6  43F8 02BA                697      LEA ble_ins, A1
000016CA  4EB8 1308                698      JSR print
000016CE  6000 000A                699      BRA next_bra_bcc
000016D2                           700  print_bgt
000016D2  43F8 02B6                701      LEA bgt_ins, A1
000016D6  4EB8 1308                702      JSR print
000016DA                           703  next_bra_bcc
000016DA  3602                     704      MOVE.W D2, D3
000016DC  C67C 00FF                705      AND.W #$00FF, D3
000016E0  B67C 0000                706      CMP.W #$0000, D3
000016E4  6700 0026                707      BEQ check_word
000016E8  43F8 025D                708      LEA byte, A1
000016EC  4EB8 1308                709      JSR print
000016F0  43F8 0309                710      LEA dollar, A1
000016F4  4EB8 1308                711      JSR print
000016F8  3203                     712      MOVE.W D3, D1
000016FA  3602                     713      MOVE.W D2, D3
000016FC  343C 0010                714      MOVE.W #16, D2
00001700  303C 000F                715      MOVE.W #15,D0
00001704  4E4F                     716      trap #15            *print immediate address value
00001706  3403                     717      MOVE.W D3, D2
00001708  6000 0024                718      BRA end_bra_bcc
0000170C                           719  check_word
0000170C  43F8 0259                720      LEA word, A1
00001710  4EB8 1308                721      JSR print
00001714  43F8 0309                722      LEA dollar, A1
00001718  4EB8 1308                723      JSR print
0000171C  544C                     724      ADDA.W #2,A4        *update current address
0000171E  3214                     725      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001720  3602                     726      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001722  343C 0010                727      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001726  103C 000F                728      MOVE.B #15, D0      *use trap instruction that allows use of base 16
0000172A  4E4F                     729      TRAP #15
0000172C  3403                     730      MOVE.W D3,D2        *copy opcode back to register D2
0000172E                           731  end_bra_bcc
0000172E  4EB8 131A                732      JSR enter
00001732  6000 FBD2                733      BRA out
00001736                           734  
00001736                           735  print_movem         *needs comments
00001736  43F8 0275                736      LEA movem_ins, A1
0000173A  4EB8 1308                737      JSR print
0000173E  3602                     738      MOVE.W D2,D3
00001740  C67C 0040                739      AND.W #$0040,D3
00001744  B67C 0040                740      CMP.W #$0040,D3
00001748  6700 000E                741      BEQ movem_long
0000174C  43F8 0259                742      LEA word, A1
00001750  4EB8 1308                743      JSR print
00001754  6000 000A                744      BRA movem_direction
00001758                           745  movem_long
00001758  43F8 0255                746      LEA long, A1
0000175C  4EB8 1308                747      JSR print
00001760                           748  movem_direction
00001760  3602                     749      MOVE.W D2,D3
00001762  C67C 0400                750      AND.W #$0400,D3
00001766  B67C 0400                751      CMP.W #$0400,D3
0000176A  6700 001A                752      BEQ mem_to_reg
0000176E  4EB9 000017E2            753      JSR movem_check_pre_post
00001774  43F8 02DC                754      LEA comma, A1
00001778  4EB8 1308                755      JSR print
0000177C  4EB9 000018BC            756      JSR addr
00001782  6000 0056                757      BRA end_movem
00001786                           758  mem_to_reg
00001786  3602                     759      MOVE.W D2, D3
00001788  C67C 003F                760      AND.W #$003F, D3
0000178C  B67C 0038                761      CMP.W #$0038, D3
00001790  6700 000E                762      BEQ fix_mem_order_word
00001794  B67C 0039                763      CMP.W #$0039, D3
00001798  6700 0016                764      BEQ fix_mem_order_long
0000179C  6000 0028                765      BRA movem_cont
000017A0                           766  fix_mem_order_word
000017A0  2C4C                     767      MOVE.L A4, A6
000017A2  584E                     768      ADD.W #4, A6
000017A4  2A16                     769      MOVE.L (A6),D5
000017A6  4845                     770      SWAP D5
000017A8  2C85                     771      MOVE.L D5, (A6)
000017AA  4285                     772      CLR.L D5
000017AC  6000 0018                773      BRA movem_cont
000017B0                           774  fix_mem_order_long
000017B0  2C4C                     775      MOVE.L A4, A6
000017B2  544E                     776      ADD.W #2, A6
000017B4  3A16                     777      MOVE.W (A6),D5
000017B6  544E                     778      ADD.W #2, A6
000017B8  2C16                     779      MOVE.L (A6),D6
000017BA  554E                     780      SUB.W #2, A6
000017BC  2C86                     781      MOVE.L D6, (A6)
000017BE  584E                     782      ADD.W #4, A6
000017C0  3C85                     783      MOVE.W D5, (A6)
000017C2  4285                     784      CLR.L D5
000017C4  4286                     785      CLR.L D6
000017C6                           786  movem_cont
000017C6  4EB9 000018BC            787      JSR addr
000017CC  43F8 02DC                788      LEA comma, A1
000017D0  4EB8 1308                789      JSR print
000017D4  4EB9 000017E2            790      JSR movem_check_pre_post
000017DA                           791  end_movem
000017DA  4EB8 131A                792      JSR enter
000017DE  6000 FB26                793      BRA out
000017E2                           794      
000017E2                           795  movem_check_pre_post:
000017E2  3602                     796      MOVE.W D2, D3
000017E4  C67C 0038                797      AND.W #$0038, D3
000017E8  B67C 0020                798      CMP.W #$0020, D3
000017EC  6700 000C                799      BEQ movem_check_pre
000017F0  4EB9 00001B20            800      JSR movem_postinc
000017F6  6000 0008                801      BRA movem_check_done
000017FA                           802  movem_check_pre
000017FA  4EB9 00001A70            803      JSR movem_predec
00001800                           804  movem_check_done
00001800  4287                     805      CLR.L D7
00001802  4281                     806      CLR.L D1
00001804  4E75                     807      RTS
00001806                           808  
00001806                           809  print_direction:
00001806                           810  *print correct direction given direction bit
00001806  C67C 0100                811      AND.W #$0100, D3
0000180A  B67C 0100                812      CMP.W #$0100, D3
0000180E  6700 000E                813      BEQ print_left  *print left
00001812  43F8 02C6                814      LEA right, A1
00001816  4EB8 1308                815      JSR print
0000181A  6000 FAEA                816      BRA out
0000181E                           817  print_left
0000181E  43F8 02C8                818      LEA left, A1
00001822  4EB8 1308                819      JSR print *print right
00001826  4E75                     820      RTS
00001828                           821      
00001828                           822  print_correct_shift_rotation:
00001828                           823  *determine if instruction is logical, arithmetic, or rotation 
00001828  C63C 0003                824      AND.B #$03, D3
0000182C  B63C 0000                825      CMP.B #$00, D3
00001830  6700 0016                826      BEQ print_as
00001834  B63C 0001                827      CMP.B #$01, D3
00001838  6700 0016                828      BEQ print_ls
0000183C  B63C 0003                829      CMP.B #$03, D3
00001840  43F8 02A0                830      LEA ro_ins, A1  print rotation
00001844  6000 000E                831      BRA print_it
00001848                           832  print_as
00001848  43F8 029D                833      LEA as_ins, A1  print arithmetic shift
0000184C  6000 0006                834      BRA print_it
00001850                           835  print_ls
00001850  43F8 029A                836      LEA ls_ins, A1 print logical shift
00001854                           837  print_it
00001854  4EB8 1308                838      JSR print
00001858  4E75                     839      RTS
0000185A                           840  * --------- End Print Instruction ----------*
0000185A                           841  
0000185A                           842  * ------- Instruction sizes ---------*
0000185A                           843  
0000185A                           844  move_size:  *print size for MOVE and MOVEA instruction
0000185A  4284                     845      CLR.L D4
0000185C  3802                     846      MOVE.W D2, D4
0000185E  C87C 3000                847      AND.W #$3000, D4
00001862  B87C 1000                848      CMP.W #$1000, D4
00001866  6700 0014                849      BEQ print_b
0000186A  B87C 3000                850      CMP.W #$3000, D4
0000186E  6700 0018                851      BEQ print_w
00001872  B87C 2000                852      CMP.W #$2000, D4
00001876  6700 001C                853      BEQ print_l
0000187A  4E75                     854      RTS
0000187C                           855      
0000187C                           856  print_b     *print '.B'
0000187C  43F8 025D                857      LEA byte, A1
00001880  4EB8 1308                858      JSR print
00001884  6000 FA80                859      BRA out
00001888                           860      
00001888                           861  print_w     *print '.W'
00001888  43F8 0259                862      LEA word, A1
0000188C  4EB8 1308                863      JSR print
00001890  6000 FA74                864      BRA out
00001894                           865      
00001894                           866  print_l:    *print '.L'
00001894  43F8 0255                867      LEA long, A1
00001898  4EB8 1308                868      JSR print
0000189C  6000 FA68                869      BRA out
000018A0                           870  
000018A0                           871  size:       *print size for non "move" instructions
000018A0  4284                     872      CLR.L D4
000018A2  1802                     873      MOVE.B D2,D4
000018A4  C83C 00C0                874      AND.B #$C0, D4
000018A8  B83C 0000                875      CMP.B #$00, D4
000018AC  67CE                     876      BEQ print_b
000018AE  B83C 0040                877      CMP.B #$40,D4
000018B2  67D4                     878      BEQ print_w
000018B4  B83C 0080                879      CMP.B #$80, D4
000018B8  67DA                     880      BEQ print_l
000018BA  4E75                     881      RTS
000018BC                           882      
000018BC                           883  * ------- End Instruction sizes ---------*
000018BC                           884  
000018BC                           885  * ------- Effective Address -------*
000018BC                           886  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
000018BC  3A02                     887      MOVE.W D2, D5
000018BE  3C02                     888      MOVE.W D2, D6               
000018C0  BE3C 0001                889      CMP.B #1, D7
000018C4  6700 003A                890      BEQ destination *check if evaluating destination address (used for MOVE)
000018C8                           891  cont
000018C8  CC3C 0038                892      AND.B #$38, D6
000018CC  BC3C 0000                893      CMP.B #0, D6
000018D0  6700 0038                894      BEQ data_reg        *check if EA mode is data register
000018D4  BC3C 0008                895      CMP.B #$08, D6
000018D8  6700 0048                896      BEQ add_reg         *check if EA mode is address register
000018DC  BC3C 0010                897      CMP.B #$10, D6
000018E0  6700 0058                898      BEQ add_indirect    *check if EA mode is address indirect
000018E4  BC3C 0018                899      CMP.B #$18, D6
000018E8  6700 0070                900      BEQ post_increment  *check if EA mode is post increment
000018EC  BC3C 0020                901      CMP.B #$20, D6
000018F0  6700 0088                902      BEQ pre_decrement   *check if EA mode is pre_decrement
000018F4  BC3C 0038                903      CMP.B #$38, D6
000018F8  6700 00A0                904      BEQ absolute_or_immediate
000018FC  6000 FA08                905      BRA out *needs Immediate, Abs Long, and Abs Word
00001900                           906  destination     *perform correct rotation to retrieve destination address
00001900  3C05                     907      MOVE.W D5,D6
00001902  EF5D                     908      ROL.W #7,D5
00001904  E64E                     909      LSR.W #3,D6
00001906  60C0                     910      BRA cont
00001908  4E75                     911      RTS
0000190A                           912  
0000190A                           913  data_reg    *used with addr sub routine
0000190A  3C05                     914      MOVE.W D5,D6    
0000190C  CC3C 0007                915      AND.B #$07, D6  
00001910  43F8 02CA                916      LEA D_reg, A1   
00001914  4EB8 1308                917      JSR print
00001918  4EB9 00001A34            918      JSR Xn
0000191E  6000 F9E6                919      BRA out
00001922                           920  
00001922                           921  add_reg     *used with addr sub routine
00001922  3C05                     922      MOVE.W D5,D6    
00001924  CC3C 0007                923      AND.B #$07, D6
00001928  43F8 02CC                924      LEA A_reg, A1   
0000192C  4EB8 1308                925      JSR print
00001930  4EB9 00001A34            926      JSR Xn
00001936  6000 F9CE                927      BRA out
0000193A                           928      
0000193A                           929  add_indirect    *used with addr sub routine
0000193A  3C05                     930      MOVE.W D5,D6    
0000193C  CC3C 0007                931      AND.B #$07, D6
00001940  43F8 02CE                932      LEA open_paran, A1  
00001944  4EB8 1308                933      JSR print
00001948  4EB9 00001A34            934      JSR Xn
0000194E  43F8 02D1                935      LEA close_paran, A1 
00001952  4EB8 1308                936      JSR print
00001956  6000 F9AE                937      BRA out
0000195A                           938      
0000195A                           939  post_increment  *used with addr sub routine
0000195A  3C05                     940      MOVE.W D5,D6    
0000195C  CC3C 0007                941      AND.B #$07, D6
00001960  43F8 02CE                942      LEA open_paran, A1  
00001964  4EB8 1308                943      JSR print
00001968  4EB9 00001A34            944      JSR Xn
0000196E  43F8 02D3                945      LEA post_inc, A1    
00001972  4EB8 1308                946      JSR print
00001976  6000 F98E                947      BRA out
0000197A                           948      
0000197A                           949  pre_decrement   *used with addr sub routine
0000197A  3C05                     950      MOVE.W D5,D6    
0000197C  CC3C 0007                951      AND.B #$07, D6
00001980  43F8 02D6                952      LEA pre_dec, A1 
00001984  4EB8 1308                953      JSR print
00001988  4EB9 00001A34            954      JSR Xn
0000198E  43F8 02D1                955      LEA close_paran, A1 
00001992  4EB8 1308                956      JSR print
00001996  6000 F96E                957      BRA out
0000199A                           958  
0000199A                           959  absolute_or_immediate *check if EA is immediate or absolute address
0000199A  3C05                     960      MOVE.W D5,D6    
0000199C  CC3C 0007                961      AND.B #$07, D6
000019A0  BC3C 0000                962      CMP.B #$00, D6
000019A4  6700 0054                963      BEQ w_imm
000019A8  BC3C 0001                964      CMP.B #$01, D6
000019AC  6700 0068                965      BEQ l_imm
000019B0  BC3C 0004                966      CMP.B #04, D6
000019B4  6700 0002                967      BEQ immediate
000019B8                           968      
000019B8                           969  immediate
000019B8  43F8 02DF                970      LEA pound, A1
000019BC  4EB8 1308                971      JSR print
000019C0  B4BC 00004000            972      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
000019C6  6D00 0016                973      BLT move_movea      *check if instruction is move or movea
000019CA  B8BC 00000040            974      CMP.L #$0040, D4        *if not move or movea
000019D0  6F00 0028                975      BLE w_imm           *byte and word check the next 2 addresses in mem
000019D4  B8BC 00000080            976      CMP.L #$0080, D4
000019DA  6700 003A                977      BEQ l_imm           *long checks the next 4 addresses in mem
000019DE                           978  move_movea              *similar comparisons, but for different bits in OPCODE
000019DE  B87C 1000                979      CMP.W #$1000, D4
000019E2  6700 0016                980      BEQ w_imm
000019E6  B87C 3000                981      CMP.W #$3000, D4
000019EA  6700 000E                982      BEQ w_imm
000019EE  B87C 2000                983      CMP.W #$2000, D4
000019F2  6700 0022                984      BEQ l_imm
000019F6                           985  imm_complete
000019F6  6000 F90E                986      BRA out
000019FA                           987      
000019FA                           988  w_imm
000019FA  43F8 0309                989      LEA dollar, A1      *print '$'
000019FE  4EB8 1308                990      JSR print
00001A02  544C                     991      ADDA.W #2,A4        *update current address
00001A04  3214                     992      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001A06  3602                     993      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001A08  343C 0010                994      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001A0C  103C 000F                995      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001A10  4E4F                     996      TRAP #15
00001A12  3403                     997      MOVE.W D3,D2        *copy opcode back to register D2
00001A14  60E0                     998      BRA imm_complete    *exit addr subroutine
00001A16                           999      
00001A16                          1000  l_imm
00001A16  43F8 0309               1001      LEA dollar, A1      *print '$'
00001A1A  4EB8 1308               1002      JSR print
00001A1E  544C                    1003      ADDA.W  #2,A4       *update current address
00001A20  2214                    1004      MOVE.L (A4),D1      *retrieve long data stored in the new current address
00001A22  3602                    1005      MOVE.W D2, D3
00001A24  343C 0010               1006      MOVE.W #16, D2
00001A28  103C 000F               1007      MOVE.B #15, D0
00001A2C  4E4F                    1008      TRAP #15
00001A2E  3403                    1009      MOVE.W D3,D2
00001A30  544C                    1010      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
00001A32  60C2                    1011      BRA imm_complete    *exit addr subroutine
00001A34                          1012  
00001A34                          1013  Xn:                     *retieve signed decimal value of data stored in register D6
00001A34  4281                    1014      CLR.L D1
00001A36  1206                    1015      MOVE.B D6,D1
00001A38  103C 0003               1016      MOVE.B #3, D0
00001A3C  4E4F                    1017      TRAP #15
00001A3E  4E75                    1018      RTS
00001A40                          1019  
00001A40                          1020  data_reg_sr:    *use if dealing with Dn only
00001A40  4286                    1021      CLR.L D6
00001A42  3C05                    1022      MOVE.W D5,D6
00001A44  EF5E                    1023      ROL.W #7,D6
00001A46  CC3C 0007               1024      AND.B #$07, D6  
00001A4A  43F8 02CA               1025      LEA D_reg, A1   
00001A4E  4EB8 1308               1026      JSR print
00001A52  4EB8 1A34               1027      JSR Xn
00001A56  4E75                    1028      RTS
00001A58                          1029      
00001A58                          1030  add_reg_sr:     *use if dealing with An only
00001A58  4286                    1031      CLR.L D6
00001A5A  3C02                    1032      MOVE.W D2,D6
00001A5C  EF5E                    1033      ROL.W #7,D6
00001A5E  CC3C 0007               1034      AND.B #$07, D6  
00001A62  43F8 02CC               1035      LEA A_reg, A1   
00001A66  4EB8 1308               1036      JSR print
00001A6A  4EB8 1A34               1037      JSR Xn
00001A6E  4E75                    1038      RTS
00001A70                          1039      
00001A70                          1040  movem_predec:           *needs to be worked on
00001A70  4285                    1041      CLR.L D5
00001A72  544C                    1042      ADDA.W  #2,A4       *update current address
00001A74  3A14                    1043      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001A76  3C05                    1044      MOVE.W D5,D6
00001A78  4281                    1045      CLR.L D1
00001A7A  4287                    1046      CLR.L D7
00001A7C  BA3C 0000               1047      CMP.B #$00, D5
00001A80  6700 005E               1048      BEQ predec_skip_to_d
00001A84  E14E                    1049      LSL #8, D6
00001A86                          1050  predec_loop_a   
00001A86  E34E                    1051      LSL #1, D6
00001A88  6400 0006               1052      BCC predec_inc_loop_a
00001A8C  6000 000E               1053      BRA predec_check_first_a
00001A90                          1054  predec_inc_loop_a
00001A90  5201                    1055      ADD.B #1, D1
00001A92  B23C 0008               1056      CMP.B #8, D1
00001A96  66EE                    1057      BNE predec_loop_a
00001A98  6000 0038               1058      BRA predec_loop_a_done  
00001A9C                          1059  predec_check_first_a
00001A9C  BE3C 0000               1060      CMP.B #0, D7
00001AA0  6700 000A               1061      BEQ predec_first_a
00001AA4  43F8 02E3               1062      LEA slash, A1
00001AA8  4EB8 1308               1063      JSR print
00001AAC                          1064  predec_first_a
00001AAC  43F8 02CC               1065      LEA A_reg, A1
00001AB0  4EB8 1308               1066      JSR print
00001AB4  103C 0003               1067      MOVE.B #3, D0
00001AB8  4E4F                    1068      TRAP #15
00001ABA  5201                    1069      ADD.B #1, D1
00001ABC  5207                    1070      ADD.B #1, D7
00001ABE  B23C 0008               1071      CMP.B #8, D1
00001AC2  66C2                    1072      BNE predec_loop_a
00001AC4  3C05                    1073      MOVE.W D5,D6
00001AC6  CC7C FF00               1074      AND.W #$FF00, D6
00001ACA  BC7C 0000               1075      CMP.W #$00, D6
00001ACE  6700 004E               1076      BEQ end_movem_predec
00001AD2                          1077  predec_loop_a_done
00001AD2  3C05                    1078      MOVE.W D5,D6
00001AD4  43F8 02E3               1079      LEA slash, A1
00001AD8  4EB8 1308               1080      JSR print
00001ADC  4281                    1081      CLR.L D1
00001ADE  4287                    1082      CLR.L D7
00001AE0                          1083  predec_skip_to_d
00001AE0                          1084  predec_loop_d   
00001AE0  E34E                    1085      LSL #1, D6
00001AE2  6400 0006               1086      BCC predec_inc_loop_d
00001AE6  6000 000E               1087      BRA predec_check_first_d
00001AEA                          1088  predec_inc_loop_d
00001AEA  5201                    1089      ADD.B #1, D1
00001AEC  B23C 0008               1090      CMP.B #8, D1
00001AF0  66EE                    1091      BNE predec_loop_d   
00001AF2  6000 002A               1092      BRA end_movem_predec
00001AF6                          1093  predec_check_first_d
00001AF6  BE3C 0000               1094      CMP.B #0, D7
00001AFA  6700 000A               1095      BEQ predec_first_d
00001AFE  43F8 02E3               1096      LEA slash, A1
00001B02  4EB8 1308               1097      JSR print
00001B06                          1098  predec_first_d
00001B06  43F8 02CA               1099      LEA D_reg, A1
00001B0A  4EB8 1308               1100      JSR print
00001B0E  103C 0003               1101      MOVE.B #3, D0
00001B12  4E4F                    1102      TRAP #15
00001B14  5201                    1103      ADD.B #1, D1
00001B16  5207                    1104      ADD.B #1, D7
00001B18  B23C 0008               1105      CMP.B #8, D1
00001B1C  66C2                    1106      BNE predec_loop_d
00001B1E                          1107  end_movem_predec
00001B1E  4E75                    1108      RTS
00001B20                          1109      
00001B20                          1110  movem_postinc:          *needs to be worked on
00001B20  4285                    1111      CLR.L D5
00001B22  544C                    1112      ADDA.W  #2,A4       *update current address
00001B24  3A14                    1113      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001B26  3C05                    1114      MOVE.W D5,D6
00001B28  4281                    1115      CLR.L D1
00001B2A  4287                    1116      CLR.L D7
00001B2C  3C05                    1117      MOVE.W D5,D6
00001B2E  CC7C FF00               1118      AND.W #$FF00, D6
00001B32  BC7C 0000               1119      CMP.W #$00, D6
00001B36  6700 0058               1120      BEQ postinc_skip_to_d
00001B3A  E04E                    1121      LSR #8, D6
00001B3C                          1122  postinc_loop_a  
00001B3C  E24E                    1123      LSR #1, D6
00001B3E  6400 0006               1124      BCC postinc_inc_loop_a
00001B42  6000 000E               1125      BRA postinc_check_first_a
00001B46                          1126  postinc_inc_loop_a
00001B46  5201                    1127      ADD.B #1, D1
00001B48  B23C 0008               1128      CMP.B #8, D1
00001B4C  66EE                    1129      BNE postinc_loop_a
00001B4E  6000 0032               1130      BRA postinc_loop_a_done 
00001B52                          1131  postinc_check_first_a
00001B52  BE3C 0000               1132      CMP.B #0, D7
00001B56  6700 000A               1133      BEQ postinc_first_a
00001B5A  43F8 02E3               1134      LEA slash, A1
00001B5E  4EB8 1308               1135      JSR print
00001B62                          1136  postinc_first_a
00001B62  43F8 02CC               1137      LEA A_reg, A1
00001B66  4EB8 1308               1138      JSR print
00001B6A  103C 0003               1139      MOVE.B #3, D0
00001B6E  4E4F                    1140      TRAP #15
00001B70  5201                    1141      ADD.B #1, D1
00001B72  5207                    1142      ADD.B #1, D7
00001B74  B23C 0008               1143      CMP.B #8, D1
00001B78  66C2                    1144      BNE postinc_loop_a
00001B7A  BA3C 0000               1145      CMP.B #$00, D5
00001B7E  6700 0050               1146      BEQ end_movem_postinc
00001B82                          1147  postinc_loop_a_done
00001B82  3C05                    1148      MOVE.W D5,D6
00001B84  43F8 02E3               1149      LEA slash, A1
00001B88  4EB8 1308               1150      JSR print
00001B8C  4281                    1151      CLR.L D1
00001B8E  4287                    1152      CLR.L D7
00001B90                          1153  postinc_skip_to_d
00001B90  3C05                    1154      MOVE.W D5,D6
00001B92                          1155  postinc_loop_d  
00001B92  E24E                    1156      LSR #1, D6
00001B94  6400 0006               1157      BCC postinc_inc_loop_d
00001B98  6000 000E               1158      BRA postinc_check_first_d
00001B9C                          1159  postinc_inc_loop_d
00001B9C  5201                    1160      ADD.B #1, D1
00001B9E  B23C 0008               1161      CMP.B #8, D1
00001BA2  66EE                    1162      BNE postinc_loop_d  
00001BA4  6000 002A               1163      BRA end_movem_postinc
00001BA8                          1164  postinc_check_first_d
00001BA8  BE3C 0000               1165      CMP.B #0, D7
00001BAC  6700 000A               1166      BEQ postinc_first_d
00001BB0  43F8 02E3               1167      LEA slash, A1
00001BB4  4EB8 1308               1168      JSR print
00001BB8                          1169  postinc_first_d
00001BB8  43F8 02CA               1170      LEA D_reg, A1
00001BBC  4EB8 1308               1171      JSR print
00001BC0  103C 0003               1172      MOVE.B #3, D0
00001BC4  4E4F                    1173      TRAP #15
00001BC6  5201                    1174      ADD.B #1, D1
00001BC8  5207                    1175      ADD.B #1, D7
00001BCA  B23C 0008               1176      CMP.B #8, D1
00001BCE  66C2                    1177      BNE postinc_loop_d
00001BD0                          1178  end_movem_postinc
00001BD0  4E75                    1179      RTS
00001BD2                          1180  
00001BD2                          1181  
00001BD2                          1182  * ------- End Effective Address -------*
00001BD2                          1183  
00001BD2                          1184  * ----- Hex to ASCII & ASCII to HEX -----*
00001BD2                          1185  
00001BD2                          1186  ASCIItoHex:
00001BD2  4EB9 00001BE0           1187          jsr     ASCII2Hex_init  
00001BD8  4EB9 00001BE6           1188          jsr     conversion_loop
00001BDE  4E75                    1189          rts                    
00001BE0                          1190  
00001BE0                          1191  ASCII2Hex_init:   
00001BE0  143C 0000               1192          move.b  #0,D2       *set up counter    
00001BE4  4E75                    1193          rts         
00001BE6                          1194          
00001BE6                          1195  conversion_loop:            
00001BE6  5282                    1196          add.l   #1,D2       *increment counter
00001BE8  B4BC 00000009           1197          cmp.l   #9,D2       *ends at 9
00001BEE  6700 004A               1198          BEQ     DONE        *branch when compare is true
00001BF2  1819                    1199          move.b  (A1)+,D4    *Get first num
00001BF4                          1200          
00001BF4  B83C 0040               1201          cmp.b   #$40,D4        
00001BF8  6E00 000C               1202          bgt     Letters_Cap  
00001BFC                          1203          
00001BFC  B83C 0039               1204          cmp.b   #$39,D4
00001C00  6F00 0016               1205          BLE     Numbers      
00001C04  4E75                    1206          rts
00001C06                          1207          
00001C06                          1208  Letters_Cap:      
00001C06  B83C 0046               1209          cmp.b   #$46,D4          
00001C0A  6E00 001E               1210          bgt     ERROR  
00001C0E  0404 0037               1211          sub.b   #$37,D4     
00001C12  E986                    1212          asl.l   #4,D6       
00001C14  DC84                    1213          add.l   D4,D6     
00001C16  60CE                    1214          bra     conversion_loop 
00001C18                          1215  Numbers:
00001C18  B83C 0030               1216          cmp.b   #$30,D4         
00001C1C  6D00 000C               1217          blt     ERROR        
00001C20  0404 0030               1218          sub.b   #$30,D4      
00001C24  E986                    1219          asl.l   #4,D6        
00001C26  DC84                    1220          add.l   D4,D6     
00001C28  60BC                    1221          bra     conversion_loop
00001C2A                          1222          
00001C2A                          1223  ERROR:
00001C2A  43F8 0127               1224          lea     ErrorMsg,A1    
00001C2E  103C 000E               1225          move.b  #14,D0
00001C32  4E4F                    1226          trap    #15
00001C34                          1227      
00001C34  103C 0009               1228          move.b  #9,D0
00001C38  4E4F                    1229          trap    #15
00001C3A                          1230          
00001C3A                          1231  DONE:
00001C3A                          1232     
00001C3A  4241                    1233          clr     D1
00001C3C  4242                    1234          clr     D2
00001C3E  4244                    1235          clr     D4
00001C40                          1236      
00001C40  43F8 0158               1237          lea     ASCIItoHexMsg,A1
00001C44  103C 000E               1238          move.b  #14,D0
00001C48  4E4F                    1239          trap    #15
00001C4A                          1240  
00001C4A  4E75                    1241          rts
00001C4C                          1242          
00001C4C                          1243  * -- End of Hex to ASCII & ASCII to HEX --*
00001C4C                          1244  
00001C4C                          1245  * Put program code here
00001C4C                          1246  
00001C4C  FFFF FFFF               1247      SIMHALT             ; halt simulator
00001C50                          1248  
00001C50                          1249  * Put variables and constants here 
00001C50                          1250  
00001C50                          1251      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  199A
ADDA_INS            285
ADDA_SIZE           1446
ADDQ_INS            28A
ADDR                18BC
ADD_A               1424
ADD_INDIRECT        193A
ADD_INS             281
ADD_REG             1922
ADD_REG_SR          1A58
ANDQ_INS            2B1
AND_INS             292
ASCII2HEX_INIT      1BE0
ASCIITOHEX          1BD2
ASCIITOHEXMSG       158
AS_INS              29D
A_REG               2CC
BEQ_INS             2BE
BGT_INS             2B6
BLE_INS             2BA
BRA_INS             2C2
BYTE                25D
CHECK_WORD          170C
CLEARDONE           117A
CLEARSCREEN         1164
CLEAR_REGISTERS     1094
CLOSE_PARAN         2D1
COMMA               2DC
CONT                18C8
CONTINUEORNOTMSG    20F
CONTINUE_INSTRUCTION_LS_AS_RO  159A
CONVERSION_LOOP     1BE6
CR                  D
CREATORS            1F
DASH                2E1
DATA                2E8
DATA_REG            190A
DATA_REG_SR         1A40
DESTINATION         1900
DOLLAR              309
DONE                1C3A
D_REG               2CA
EA                  2EF
EA_DEST_ADD         140A
EA_DEST_SUB_AND_OR  14EC
ENDADDRESSINC       ED
ENDOFMEMLOOP        17C
END_ADD             1466
END_BRA_BCC         172E
END_MOVEM           17DA
END_MOVEM_POSTINC   1BD0
END_MOVEM_PREDEC    1B1E
ENTER               131A
ENTER_PRESS_TRUE    123A
ERROR               1C2A
ERRORMSG            127
EXITMSG             245
FIX_MEM_ORDER_LONG  17B0
FIX_MEM_ORDER_WORD  17A0
FLUSHSCREEN         1216
FLUSHSCREENMSG      1A2
FLUSHSCREEN_INPUT   1228
GETENDADDRESS       1144
GETSTARTADDRESS     1124
HELPMSG             1D3
HEXTOASCIIMSG       136
IMMEDIATE           19B8
IMM_COMPLETE        19F6
INPUTISINC          D0
INPUTMSG1           57
INPUTMSG2           98
INVALID             12D4
INVALID_ADDRESS_PROVIDED  110A
INVALID_EA          12F4
INVALID_INPUT       10EA
JSR_INS             2A7
LEA_INS             2AC
LEFT                2C8
LETTERS_CAP         1C06
LF                  A
LONG                255
LS_AS_RO_MEM        15B0
LS_AS_RO_REG        1592
LS_INS              29A
L_IMM               1A16
MEMSEARCH           117C
MEMSEARCHLOOP       1190
MEMSEARCH_DONE      11CA
MEM_TO_REG          1786
MENU                10D0
MENU_CONT           10FC
MOVEA_INS           27B
MOVEM_CHECK_DONE    1800
MOVEM_CHECK_PRE     17FA
MOVEM_CHECK_PRE_POST  17E2
MOVEM_CONT          17C6
MOVEM_DIRECTION     1760
MOVEM_INS           275
MOVEM_LONG          1758
MOVEM_POSTINC       1B20
MOVEM_PREDEC        1A70
MOVEQ_INS           26E
MOVE_A              1396
MOVE_INS            269
MOVE_MOVEA          19DE
MOVE_SIZE           185A
MUL_DIV             150A
MUL_DIV_LONG        152C
M_SIZE              139E
NEXT_ADD            1452
NEXT_BRA_BCC        16DA
NEXT_LS_AS_RO       15DE
NOP_INS             261
NOT_INS             2A3
NUMBERS             1C18
OPCODE_DECODE       123C
OPEN_PARAN          2CE
OR_INS              28F
OUT                 1306
POSTINC_CHECK_FIRST_A  1B52
POSTINC_CHECK_FIRST_D  1BA8
POSTINC_FIRST_A     1B62
POSTINC_FIRST_D     1BB8
POSTINC_INC_LOOP_A  1B46
POSTINC_INC_LOOP_D  1B9C
POSTINC_LOOP_A      1B3C
POSTINC_LOOP_A_DONE  1B82
POSTINC_LOOP_D      1B92
POSTINC_SKIP_TO_D   1B90
POST_INC            2D3
POST_INCREMENT      195A
POUND               2DF
PREDEC_CHECK_FIRST_A  1A9C
PREDEC_CHECK_FIRST_D  1AF6
PREDEC_FIRST_A      1AAC
PREDEC_FIRST_D      1B06
PREDEC_INC_LOOP_A   1A90
PREDEC_INC_LOOP_D   1AEA
PREDEC_LOOP_A       1A86
PREDEC_LOOP_A_DONE  1AD2
PREDEC_LOOP_D       1AE0
PREDEC_SKIP_TO_D    1AE0
PRE_DEC             2D6
PRE_DECREMENT       197A
PRINT               1308
PRINTLN             1312
PRINT_ADDQ          164A
PRINT_ADD_ADDA      13C6
PRINT_AS            1848
PRINT_B             187C
PRINT_BEQ           16BA
PRINT_BGT           16D2
PRINT_BLE           16C6
PRINT_BRA           16AE
PRINT_BRA_BCC       1684
PRINT_CORRECT_SHIFT_ROTATION  1828
PRINT_DIRECTION     1806
PRINT_INSTRUCTION   14BA
PRINT_IT            1854
PRINT_JSR           1610
PRINT_L             1894
PRINT_LEA           1626
PRINT_LEFT          181E
PRINT_LS            1850
PRINT_LS_AS_RO      1532
PRINT_MOVEM         1736
PRINT_MOVEQ         1338
PRINT_MOVE_MOVEA    137C
PRINT_NOP           1324
PRINT_NOT           15E6
PRINT_OR            14B6
PRINT_RTS           132E
PRINT_SUB           14A0
PRINT_SUB_AND_OR    146E
PRINT_W             1888
RESUME              111C
RETURN              2E5
RIGHT               2C6
RO_INS              2A0
RTS_INS             265
SCREENFLUSH_CHECK   120C
SIZE                18A0
SLASH               2E3
SPACE               2DA
START               1000
STARTINGMSG         0
SUB_INS             296
TAB                 9
WORD                259
W_IMM               19FA
XN                  1A34
