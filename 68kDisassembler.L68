00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 9:51:58 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 49 6E 70 75 74 73 ...     23  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
000001CC= 57 6F 75 6C 64 20 ...     24  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
000001EF= 45 78 69 74 69 6E ...     25  ExitMsg             dc.b    'Exiting Program',0
000001FF                            26  
000001FF                            27  START_ADDR_BUFFER  DS.B    256
000002FF                            28  END_ADDR_BUFFER    DS.B    256
000003FF                            29  
000003FF                            30  *size
000003FF= 2E 4C 20 00               31  long                DC.B    '.L ',0
00000403= 2E 57 20 00               32  word                DC.B    '.W ',0
00000407= 2E 42 20 00               33  byte                DC.B    '.B ',0
0000040B                            34  
0000040B                            35  *instructions
0000040B= 4E 4F 50 00               36  nop_ins             DC.B    'NOP',0
0000040F= 52 54 53 00               37  rts_ins             DC.B    'RTS',0
00000413= 4D 4F 56 45 00            38  move_ins            DC.B    'MOVE',0
00000418= 4D 4F 56 45 51 20 00      39  moveq_ins           DC.B    'MOVEQ ',0
0000041F= 4D 4F 56 45 4D 00         40  movem_ins           DC.B    'MOVEM',0
00000425= 4D 4F 56 45 41 00         41  movea_ins           DC.B    'MOVEA',0
0000042B= 41 44 44 00               42  add_ins             DC.B    'ADD',0
0000042F= 41 44 44 41 00            43  adda_ins            DC.B    'ADDA',0
00000434= 41 44 44 51 00            44  addq_ins            DC.B    'ADDQ',0
00000439= 4F 52 00                  45  or_ins              DC.B    'OR',0
0000043C= 41 4E 44 00               46  and_ins             DC.B    'AND',0
00000440= 53 55 42 00               47  sub_ins             DC.B    'SUB',0
00000444= 4C 53 00                  48  ls_ins              DC.B    'LS',0
00000447= 41 53 00                  49  as_ins              DC.B    'AS',0
0000044A= 52 4F 00                  50  ro_ins              DC.B    'RO',0
0000044D= 4E 4F 54 00               51  not_ins             DC.B    'NOT',0
00000451= 4A 53 52 20 00            52  jsr_ins             DC.B    'JSR ',0
00000456= 4C 45 41 20 00            53  lea_ins             DC.B    'LEA ',0
0000045B= 41 44 44 51 00            54  andq_ins            DC.B    'ADDQ',0
00000460= 42 47 54 00               55  bgt_ins             DC.B    'BGT',0
00000464= 42 4C 45 00               56  ble_ins             DC.B    'BLE',0
00000468= 42 45 51 00               57  beq_ins             DC.B    'BEQ',0
0000046C= 42 52 41 00               58  bra_ins             DC.B    'BRA',0
00000470                            59  
00000470                            60  *direction
00000470= 52 00                     61  right               DC.B    'R',0
00000472= 4C 00                     62  left                DC.B    'L',0
00000474                            63  
00000474                            64  *EA
00000474= 44 00                     65  D_reg               DC.B    'D',0
00000476= 41 00                     66  A_reg               DC.B    'A',0
00000478= 28 41 00                  67  open_paran          DC.B    '(A',0
0000047B= 29 00                     68  close_paran         DC.B    ')',0
0000047D= 29 2B 00                  69  post_inc            DC.B    ')+',0
00000480= 2D 28 41 00               70  pre_dec             DC.B    '-(A',0
00000484                            71  
00000484                            72  *extra
00000484= 20 00                     73  space               DC.B    ' ',0
00000486= 2C 20 00                  74  comma               DC.B    ', ',0
00000489= 23 00                     75  pound               DC.B    '#',0
0000048B= 2D 00                     76  dash                DC.B    '-',0
0000048D= 2F 00                     77  slash               DC.B    '/',0
0000048F  =00000009                 78  tab                 EQU     $9
0000048F= 0D 0A 00                  79  return              DC.B    CR,LF,0
00000492= 44 41 54 41 20 24 00      80  data                DC.B    'DATA $',0
00000499= 24 00                     81  dollar              DC.B    '$',0
00001000                            82      ORG    $1000    *Start at address $1000
00001000                            83  START:                  ; first instruction of program
00001000                            84  
00001000                            85  *---------- Test value, will remove in final build ----------*
00001000                            86  
00001000                            87  *   Move.W #$4E75,$00009234 *RTS
00001000                            88  *   MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001000                            89  *   MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001000                            90  *   MOVE.W #$4E71,$0000923A *NOP
00001000                            91  *   MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001000                            92  *   MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001000                            93  *   MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001000                            94  *   MOVE.W #$C246,$00009242 *AND.W D6,D1
00001000                            95  *   MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001000                            96  *   MOVE.W #$E0C7,$00009246 *ASR D7
00001000                            97  *   MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001000                            98  *   MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001000                            99  *   MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001000                           100  *   MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001000                           101  *   MOVE.W #$000C,$00009250
00001000                           102  *   MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001000                           103  *   MOVE.L #$12345678,$00009254
00001000                           104  *   MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001000                           105  *   MOVE.W #$0012,$0000925A
00001000                           106  *   MOVE.W #$4607,$0000925C *NOT.B D7
00001000                           107  *   MOVE.W #$4EB9,$0000925E *JSR $9208
00001000                           108  *   MOVE.L #$00009208,$00009260
00001000                           109  *   MOVE.W #$4E90,$00009264 *JSR (A0)
00001000                           110  *   MOVE.W #$41D0,$00009266 *LEA (A0), A0 
00001000                           111  *   MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
00001000                           112  *    MOVE.W #$6EFE,$0000926A *BGT.B FE
00001000                           113  *    MOVE.W #$6F00,$0000926C *BLE.W FE7A
00001000                           114  *    MOVE.W #$FE7A,$0000926E
00001000                           115  *    MOVE.W #$6700,$00009270 *BEQ.W FE60
00001000                           116  *    MOVE.W #$FE60,$00009272
00001000                           117  *    MOVE.W #$4EB9,$00009274 *JSR 00009208
00001000                           118  *    MOVE.L #$00009208,$000009276
00001000                           119  *    MOVE.W #$48A1,$0000927A
00001000                           120  *    MOVE.W #$011F,$0000927C
00001000                           121  *    MOVE.W #$4C91,$0000927E
00001000                           122  *    MOVE.W #$FE00,$00009280
00001000                           123  *   MOVE.W #$C2BC, $00009000
00001000                           124  *   MOVE.L #$12345678, $00009002
00001000  33FC 82F9 00009000       125      MOVE.W #$82F9 , $00009000
00001008  23FC 12345678 00009002   126      MOVE.L #$12345678, $00009002 
00001012  33FC 9441 00009006       127      MOVE.W #$9441, $00009006
0000101A                           128  *   MOVE.L #$12345678, $00009002
0000101A                           129  *---------- END Test ----------*
0000101A                           130  
0000101A                           131  
0000101A                           132  
0000101A                           133  *---------- Beginning Messages ----------*
0000101A                           134      
0000101A  103C 000E                135      move.b      #14,D0
0000101E  43F8 0000                136      lea         StartingMsg,A1 
00001022  4E4F                     137      trap        #15
00001024                           138      
00001024  103C 000E                139      move.b      #14,D0
00001028  43F8 001F                140      lea         Creators,A1
0000102C  4E4F                     141      trap        #15
0000102E                           142      
0000102E  4EB9 00001080            143      jsr         MENU
00001034                           144      
00001034                           145      
00001034                           146  * ---------- END OF PROGRAM -------------*
00001034                           147  
00001034  103C 000E                148      move.b      #14,D0
00001038  43F8 01EF                149      lea         ExitMsg,A1 
0000103C  4E4F                     150      trap        #15
0000103E                           151      
0000103E  103C 0009                152      move.b      #9,D0
00001042  4E4F                     153      trap        #15
00001044                           154  * ---------------------------------------*
00001044                           155      
00001044                           156  *-- End of Opening and Ending Messages --*
00001044                           157  
00001044                           158  *--------- Start of I/O Section ---------*
00001044                           159  
00001044                           160  Clear_Registers:
00001044  4280                     161      clr.l     D0
00001046  4281                     162      clr.l     D1
00001048  4282                     163      clr.l     D2
0000104A  4283                     164      clr.l     D3
0000104C  4284                     165      clr.l     D4
0000104E  4285                     166      clr.l     D5
00001050  4286                     167      clr.l     D6
00001052  4287                     168      clr.l     D7
00001054                           169      
00001054  207C 00000000            170      movea.l   #0,A0
0000105A  227C 00000000            171      movea.l   #0,A1
00001060  247C 00000000            172      movea.l   #0,A2
00001066  267C 00000000            173      movea.l   #0,A3
0000106C  287C 00000000            174      movea.l   #0,A4
00001072  2A7C 00000000            175      movea.l   #0,A5
00001078  2C7C 00000000            176      movea.l   #0,A6
0000107E  4E75                     177      rts
00001080                           178  
00001080                           179  MENU:
00001080  4EB8 1044                180      jsr         Clear_Registers
00001084  4EB9 0000109E            181      jsr         GetStartAddress
0000108A  4EB9 000010B8            182      jsr         GetEndAddress
00001090  4EB9 000010D2            183      jsr         CheckAddress
00001096                           184      
00001096  4EB9 000010D6            185      jsr         MemSearch
0000109C  4E75                     186      rts
0000109E                           187      
0000109E                           188  GetStartAddress:
0000109E                           189      
0000109E  103C 000E                190      move.b      #14, D0         *Display input message
000010A2  43F8 004E                191      lea         InputMsg1,A1
000010A6  4E4F                     192      trap        #15
000010A8                           193      
000010A8  103C 0002                194      move.b      #2,D0
000010AC  4E4F                     195      trap        #15
000010AE                           196          
000010AE  4EB9 00001A8A            197      jsr ASCIItoHex              *conversion to Hex
000010B4                           198      * Address Located in D6
000010B4  2846                     199      movea.l     D6,A4           *move into address register 4
000010B6  4E75                     200      rts
000010B8                           201      
000010B8                           202      
000010B8                           203  GetEndAddress:
000010B8  103C 000E                204      move.b      #14,D0          *Display input message
000010BC  43F8 008F                205      lea         InputMsg2,A1
000010C0  4E4F                     206      trap        #15
000010C2                           207      
000010C2  103C 0002                208      move.b      #2,D0
000010C6  4E4F                     209      trap        #15
000010C8                           210      
000010C8  4EB9 00001A8A            211      jsr         ASCIItoHex      *conversion to hex
000010CE                           212      * Address Located in D6 (overwrite)
000010CE  2A46                     213      movea.l     D6,A5           *move into address register 5
000010D0  4E75                     214      rts
000010D2                           215      
000010D2                           216  CheckAddress:
000010D2  BBCC                     217      cmp.l       A4,A5
000010D4  67AA                     218      beq         Menu
000010D6                           219  
000010D6                           220      
000010D6                           221  MemSearch:
000010D6  4EB9 000010DE            222      jsr MemSearchLoop
000010DC  4E75                     223      rts
000010DE                           224      
000010DE                           225  MemSearchLoop:
000010DE                           226      
000010DE                           227      * Check if we reached the end address
000010DE  BBCC                     228      cmp.l       A4,A5
000010E0  6700 002A                229      beq         MemSearch_Done
000010E4                           230      
000010E4                           231      * Get data from memory
000010E4  4241                     232      CLR D1
000010E6  3414                     233      move.w     (A4),D2
000010E8  3602                     234      move.w      D2, D3  mutable copy in D3
000010EA                           235      * OPCODE Word Located in D2, mutable copy in D3
000010EA  220C                     236      MOVE.L      A4, D1
000010EC  143C 0010                237      MOVE.B      #16, D2
000010F0  103C 000F                238      MOVE.B      #15, D0     print address of instruction
000010F4  4E4F                     239      TRAP        #15
000010F6  3403                     240      MOVE.W      D3,D2
000010F8  43F8 0484                241      LEA         space,A1
000010FC  4EB9 000011E4            242      JSR         print
00001102  4EB9 0000112E            243      jsr         OPCODE_DECODE    
00001108                           244      
00001108  544C                     245      adda.w      #2,A4
0000110A  60D2                     246      bra         MemSearchLoop
0000110C                           247      
0000110C                           248      
0000110C                           249  MemSearch_Done:
0000110C  103C 000E                250      move.b      #14,D0
00001110  43F8 0173                251      lea         EndOfMemLoop,A1 
00001114  4E4F                     252      trap        #15
00001116  4E75                     253      rts
00001118                           254      
00001118                           255  TerminateOrCont:
00001118                           256      * Used to check if user would like to terminate the program or continue to disassemble more data
00001118  103C 000E                257      move.b      #14,D0
0000111C  43F8 01CC                258      lea         ContinueOrNotMsg,A1 
00001120  4E4F                     259      trap        #15
00001122                           260      
00001122  4E75                     261      rts
00001124                           262  
00001124                           263  ScreenFlush:
00001124  B63C 001E                264      cmp.b       #30,D3
00001128  6700 0004                265      beq         FlushScreen
0000112C  4E75                     266      rts 
0000112E                           267  
0000112E                           268  FlushScreen:
0000112E                           269  
0000112E                           270  * -------- Start of Opcode Section -------*    
0000112E                           271  
0000112E                           272  OPCODE_DECODE:
0000112E                           273      * Begin OPCODE Decoding here
0000112E                           274      * Check first four bits and begin
0000112E                           275      * if-branch breakdown
0000112E  4284                     276      CLR.L D4
00001130  4285                     277      CLR.L D5
00001132  4286                     278      CLR.L D6
00001134  4287                     279      CLR.L D7
00001136                           280      
00001136  B47C 4E71                281      CMP.W #$4E71, D2        
0000113A  6700 00C4                282      BEQ print_nop           *check if value is NOP
0000113E                           283      
0000113E  B47C 4E75                284      CMP.W #$4E75, D2        
00001142  6700 00C6                285      BEQ print_rts           *check if value is RTS
00001146                           286      
00001146                           287      * Mask out only the first 4 bits
00001146  C67C F000                288      AND.W #$F000,D3
0000114A                           289      
0000114A  B67C 9000                290      CMP.W #$9000,D3
0000114E  6700 01FA                291      BEQ print_sub_and_or    *check if value is SUB
00001152                           292      
00001152  B67C 6000                293      CMP.W #$6000,D3
00001156  6700 0408                294      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
0000115A                           295      
0000115A  B67C 8000                296      CMP.W #$8000, D3
0000115E  6700 01EA                297      BEQ print_sub_and_or    *check if value is OR
00001162                           298  
00001162  B67C C000                299      CMP.W #$C000,D3
00001166  6700 01E2                300      BEQ print_sub_and_or    *check if value is AND
0000116A                           301      
0000116A  B67C D000                302      CMP.W #$D000,D3
0000116E  6700 0132                303      BEQ print_add_adda      *check if value is ADD or ADDA
00001172                           304      
00001172  B67C E000                305      CMP.W #$E000,D3
00001176  6700 0296                306      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
0000117A                           307      
0000117A  B67C 7000                308      CMP.W #$7000,D3
0000117E  6700 0094                309      BEQ print_moveq     *check if value is MOVEQ
00001182                           310      
00001182  B47C 1000                311      CMP.W #$1000,D2
00001186  6D00 003E                312      BLT invalid
0000118A  B47C 4000                313      CMP.W #$4000,D2
0000118E  6D00 00C8                314      BLT print_move_movea    *check if value is MOVE or MOVEA
00001192                           315      
00001192                           316      * Mask out only the first 8 bits
00001192  3602                     317      MOVE.W D2, D3
00001194  C67C FF00                318      AND.W #$FF00,D3
00001198                           319      
00001198  B67C 4600                320      CMP.W #$4600,D3
0000119C  6700 0324                321      BEQ print_not           *check if value is NOT
000011A0                           322      
000011A0  B67C 4E00                323      CMP.W #$4E00,D3
000011A4  6700 0346                324      BEQ print_jsr           *check if value is JSR
000011A8                           325      
000011A8                           326      * Mask out only the first 4 bits and the 8th bit
000011A8  3602                     327      MOVE.W D2,D3
000011AA  C67C F100                328      AND.W #$F100, D3
000011AE                           329      
000011AE  B67C 4000                330      CMP.W #$4000, D3
000011B2  6700 045E                331      BEQ print_movem         *check if value is MOVEM
000011B6                           332      
000011B6  B67C 4100                333      CMP.W #$4100, D3
000011BA  6700 0346                334      BEQ print_lea           *check if value is LEA
000011BE                           335      
000011BE  B67C 5000                336      CMP.W #$5000,D3
000011C2  6700 0362                337      BEQ print_addq          *check if value is ANDQ     
000011C6                           338      
000011C6                           339      
000011C6                           340  invalid 
000011C6  43F8 0492                341      LEA data, A1
000011CA  4EB9 000011E4            342      JSR print
000011D0  2202                     343      MOVE.L D2, D1
000011D2  143C 0010                344      MOVE.B #16, D2
000011D6  103C 000F                345      MOVE.B  #15, D0     
000011DA  4E4F                     346      TRAP #15
000011DC  4EB9 000011F6            347      JSR enter
000011E2  4E75                     348  out rts
000011E4                           349  
000011E4                           350      
000011E4                           351  * -------- End of Opcode Section --------*   
000011E4                           352  
000011E4                           353  * --------- Print Instructions ----------*
000011E4                           354  
000011E4                           355  
000011E4                           356  print:
000011E4  4240                     357      CLR D0 
000011E6  103C 000E                358      MOVE.B #14,D0
000011EA  4E4F                     359      TRAP #15
000011EC  4E75                     360      RTS
000011EE                           361  
000011EE                           362  println:
000011EE  103C 000D                363      MOVE.B #13, D0
000011F2  4E4F                     364      TRAP #15
000011F4  4E75                     365      RTS
000011F6                           366      
000011F6                           367  enter: 
000011F6  43F8 048F                368      LEA return, A1
000011FA  4EB8 11E4                369      JSR print
000011FE  4E75                     370      RTS
00001200                           371      
00001200                           372  print_nop
00001200  43F8 040B                373      LEA nop_ins, A1
00001204  4EB8 11EE                374      JSR println
00001208  60D8                     375      BRA out
0000120A                           376  
0000120A                           377  print_rts
0000120A  43F8 040F                378      LEA rts_ins, A1
0000120E  4EB8 11EE                379      JSR println
00001212  60CE                     380      BRA out
00001214                           381      
00001214                           382  print_moveq
00001214  43F8 0418                383      lea moveq_ins, A1   *print MOVEQ
00001218  4EB8 11E4                384      jsr print
0000121C  3602                     385      move.w  D2,D3
0000121E  C67C 00FF                386      and.w   #$00FF,D3   * Figure out the immediate address value
00001222  43F8 0489                387      lea pound,A1        *print '#'
00001226  4EB8 11E4                388      jsr print
0000122A  43F8 0499                389      LEA dollar, A1
0000122E  4EB8 11E4                390      JSR print
00001232  3203                     391      move.w  D3,D1
00001234  3602                     392      MOVE.W D2,D3
00001236  343C 0010                393      MOVE.W #16, D2
0000123A  103C 000F                394      move.b  #15,D0
0000123E  4E4F                     395      trap    #15         *print immediate address value
00001240  43F8 0486                396      lea comma,A1        *print comma
00001244  4EB8 11E4                397      jsr print
00001248  3403                     398      MOVE.W D3, D2
0000124A  3A02                     399      MOVE.W D2, D5
0000124C  4EB9 000018B8            400      JSR data_reg_sr     *figure out data address
00001252  4EB8 11F6                401      jsr enter           *print out enter
00001256  608A                     402      bra out
00001258                           403      
00001258                           404  print_move_movea
00001258  3602                     405      MOVE.W D2, D3       
0000125A  C67C 01C0                406      AND.W #$01C0, D3
0000125E  B67C 0040                407      CMP.W #$0040, D3    *determine if MOVE or MOVEA
00001262  6700 000E                408      BEQ move_a
00001266  43F8 0413                409      LEA move_ins, A1 *print Instruction 
0000126A  4EB8 11E4                410      JSR print
0000126E  6000 000A                411      BRA m_size
00001272                           412  move_a          *if instruction is MOVEA
00001272  43F8 0425                413      LEA movea_ins, A1
00001276  4EB8 11E4                414      JSR print
0000127A                           415  m_size              *determine instruction size
0000127A  4EB9 000016D2            416      JSR move_size
00001280  4EB9 00001734            417      JSR addr        *determine the source address
00001286  43F8 0486                418      LEA comma, A1   *print comma
0000128A  4EB8 11E4                419      JSR print
0000128E  4207                     420      CLR.B D7
00001290  1E3C 0001                421      MOVE.B #1, D7   *determine destination address
00001294  4EB9 00001734            422      JSR addr
0000129A  4EB8 11F6                423      JSR enter       *print enter
0000129E  6000 FF42                424      BRA out
000012A2                           425      
000012A2                           426  print_add_adda
000012A2  3602                     427      MOVE.W D2, D3   
000012A4  C63C 00C0                428      AND.B #$C0, D3
000012A8  B63C 00C0                429      CMP.B #$C0, D3      *determine if ADD or ADDA
000012AC  6700 0052                430      BEQ add_a
000012B0                           431      *if just ADD then print instruction
000012B0  43F8 042B                432      LEA add_ins, A1
000012B4  4EB8 11E4                433      JSR print
000012B8                           434      *print instruction size for ADD
000012B8  4EB9 00001718            435      JSR size
000012BE                           436      *determine direction of ADD, Dn -> EA or EA -> Dn
000012BE  3602                     437      MOVE.W D2,D3
000012C0  C67C 0100                438      AND.W #$0100, D3
000012C4  B67C 0100                439      CMP.W #$0100, D3
000012C8  6700 001C                440      BEQ ea_dest_add 
000012CC  4EB9 00001734            441      JSR addr            *if Direction bit is 0
000012D2  43F8 0486                442      LEA comma, A1
000012D6  4EB8 11E4                443      JSR print
000012DA  3A02                     444      MOVE.W D2,D5
000012DC  4EB9 000018B8            445      JSR data_reg_sr
000012E2  6000 005E                446      BRA end_add
000012E6                           447  ea_dest_add             *if Direction bit is 1
000012E6  3A02                     448      MOVE.W D2,D5
000012E8  4EB9 000018B8            449      JSR data_reg_sr
000012EE  43F8 0486                450      LEA comma, A1
000012F2  4EB8 11E4                451      JSR print
000012F6  4EB9 00001734            452      JSR addr
000012FC  6000 0044                453      BRA end_add
00001300                           454  add_a                   *if instruction is ADDA
00001300  43F8 042F                455      LEA adda_ins, A1
00001304  4EB8 11E4                456      JSR print
00001308                           457      *print instruction size for ADDA (either W or L)
00001308  3602                     458      MOVE.W D2,D3
0000130A  C67C 0100                459      AND.W #$0100, D3
0000130E  B67C 0100                460      CMP.W #$0100, D3
00001312  6700 000E                461      BEQ adda_size
00001316  43F8 0403                462      LEA word, A1
0000131A  4EB8 11E4                463      JSR print
0000131E  6000 000E                464      BRA next_add
00001322                           465  adda_size
00001322  43F8 03FF                466      LEA long,A1
00001326  4EB8 11E4                467      JSR print
0000132A  183C 0080                468      MOVE.B #$80, D4
0000132E                           469  next_add                *print effective address for ADDA
0000132E  4EB9 00001734            470      JSR addr            
00001334  43F8 0486                471      LEA comma, A1
00001338  4EB8 11E4                472      JSR print
0000133C  4EB9 000018D0            473      JSR add_reg_sr
00001342                           474  end_add                 *complete instruction printing by printing enter
00001342  4EB8 11F6                475      JSR enter
00001346  6000 FE9A                476      BRA out
0000134A                           477  
0000134A                           478  print_sub_and_or
0000134A                           479      *determine if instruction is SUB, AND, or OR.
0000134A  3602                     480      MOVE.W D2, D3
0000134C  C67C F0C0                481      AND.W #$F0C0, D3
00001350  B67C C0C0                482      CMP.W #$C0C0, D3
00001354  6700 0090                483      BEQ mul_div
00001358  B67C 80C0                484      CMP.W #$80C0, D3
0000135C  6700 0088                485      BEQ mul_div
00001360  C67C F000                486      AND.W #$F000,D3
00001364  B67C 8000                487      CMP.W #$8000, D3
00001368  6700 0028                488      BEQ print_or
0000136C  B67C 9000                489      CMP.W #$9000, D3
00001370  6700 000A                490      BEQ print_sub
00001374  43F8 043C                491      LEA and_ins, A1
00001378  6000 001C                492      BRA print_instruction
0000137C                           493  print_sub
0000137C  3602                     494      MOVE.W D2, D3
0000137E  C67C 00C0                495      AND.W #$00C0, D3
00001382  B63C 00C0                496      CMP.B #$C0, D3
00001386  6700 FE3E                497      BEQ invalid
0000138A  43F8 0440                498      LEA sub_ins, A1
0000138E  6000 0006                499      BRA print_instruction
00001392                           500  print_or
00001392  43F8 0439                501      LEA or_ins, A1
00001396                           502  print_instruction       *print correct instruction
00001396  4EB8 11E4                503      JSR print
0000139A  4EB9 00001718            504      JSR size            *print instruction size
000013A0  3602                     505      MOVE.W D2,D3
000013A2                           506  *determine direction of ADD, Dn -> EA or EA -> Dn   
000013A2  C67C 0100                507      AND.W #$0100, D3
000013A6  B67C 0100                508      CMP.W #$0100, D3
000013AA  6700 001C                509      BEQ ea_dest_sub_and_or
000013AE  4EB9 00001734            510      JSR addr            *if Direction bit is 0
000013B4  43F8 0486                511      LEA comma, A1
000013B8  4EB8 11E4                512      JSR print
000013BC  3A02                     513      MOVE.W D2,D5
000013BE  4EB9 000018B8            514      JSR data_reg_sr
000013C4  6000 FF7C                515      BRA end_add
000013C8                           516  ea_dest_sub_and_or      *if Direction bit is 1
000013C8  3A02                     517      MOVE.W D2,D5
000013CA  4EB9 000018B8            518      JSR data_reg_sr
000013D0  43F8 0486                519      LEA comma, A1
000013D4  4EB8 11E4                520      JSR print
000013D8  4EB9 00001734            521      JSR addr
000013DE                           522      *complete instruction printing by printing enter
000013DE  4EB8 11F6                523      JSR enter
000013E2  6000 FDFE                524      BRA out
000013E6                           525      
000013E6                           526  mul_div             *deal with MULU and DIVU cases
000013E6  4283                     527      CLR.L D3
000013E8  3602                     528      MOVE.W D2,D3
000013EA  C67C 00FF                529      AND.W #$00FF, D3
000013EE  B6BC 000000F8            530      CMP.L #$00F8, D3
000013F4  6D00 FDD0                531      BLT invalid
000013F8  B6BC 000000F9            532      CMP.L #$00F9, D3
000013FE  6700 0008                533      BEQ mul_div_long
00001402  544C                     534      ADDA.W #2,A4
00001404  6000 FDC0                535      BRA invalid
00001408                           536  mul_div_long
00001408  584C                     537      ADDA.W #4,A4
0000140A  6000 FDBA                538      BRA invalid
0000140E                           539      
0000140E                           540  print_ls_as_ro
0000140E                           541      *figure out if shift or rotation are memory or register based               
0000140E  3602                     542      MOVE.W D2, D3
00001410  C63C 00C0                543      AND.B #$C0, D3
00001414  B63C 00C0                544      CMP.B #$C0, D3
00001418  6700 0072                545      BEQ ls_as_ro_mem
0000141C  3602                     546      MOVE.W D2, D3
0000141E  E60B                     547      LSR.B #3, D3
00001420                           548      *print correct instruction type (logical shift, arithmetic shift, or rotation)
00001420  4EB9 000016A0            549      JSR print_correct_shift_rotation
00001426  4EB9 0000167E            550      JSR print_direction     *print direction
0000142C  4EB9 00001718            551      JSR size                *print size
00001432  3602                     552      MOVE.W D2, D3
00001434  C63C 0020                553      AND.B #$20,D3
00001438  B63C 0020                554      CMP.B #$20, D3
0000143C                           555      *determine if instruction is using immediate address or register
0000143C  6700 0030                556      BEQ ls_as_ro_reg     
00001440  43F8 0489                557      LEA pound, A1        *if immediate address print '#'
00001444  4EB8 11E4                558      JSR print
00001448                           559      *print immediate address rotation value
00001448  3C02                     560      MOVE.W D2,D6
0000144A  EF5E                     561      ROL.W #7,D6
0000144C  CC7C 0007                562      AND.W #$0007, D6
00001450  43F8 0499                563      LEA dollar, A1
00001454  4EB8 11E4                564      JSR print
00001458  4281                     565      CLR.L D1
0000145A  3206                     566      MOVE.W D6, D1
0000145C  3602                     567      MOVE.W D2, D3
0000145E  143C 0010                568      MOVE.B #16, D2
00001462  103C 000F                569      MOVE.B #15, D0
00001466  4E4F                     570      TRAP #15
00001468  3403                     571      MOVE.W D3,D2
0000146A  6000 000A                572      BRA continue_instruction_ls_as_ro
0000146E                           573  ls_as_ro_reg            *if instruction is using register to shift values in another register
0000146E  3A02                     574      MOVE.W D2,D5
00001470  4EB9 000018B8            575      JSR data_reg_sr
00001476                           576  continue_instruction_ls_as_ro *complete instrcuction
00001476  43F8 0486                577      LEA comma, A1       *print comma
0000147A  4EB8 11E4                578      JSR print
0000147E  3A02                     579      MOVE.W D2,D5
00001480  EE5D                     580      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001482  4EB9 000018B8            581      JSR data_reg_sr     *determine destination data register to perform instruction on
00001488  6000 0030                582      BRA next_ls_as_ro   *finish printing instruction
0000148C                           583  ls_as_ro_mem            *check if immediate address is being shifted or rotated
0000148C  3602                     584      MOVE.W D2, D3
0000148E  C63C 003F                585      AND.B #$3F, D3
00001492  B63C 003C                586      CMP.B #$3C, D3
00001496  6700 FD2E                587      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
0000149A                           588      *if not immediate adress print normally 
0000149A  3602                     589      MOVE.W D2, D3
0000149C  EF5B                     590      ROL.W #7, D3    
0000149E  4EB9 000016A0            591      JSR print_correct_shift_rotation
000014A4  3602                     592      MOVE.W D2,D3
000014A6  4EB9 0000167E            593      JSR print_direction
000014AC  43F8 0403                594      LEA word, A1
000014B0  4EB8 11E4                595      JSR print
000014B4  4EB9 00001734            596      JSR addr
000014BA                           597  next_ls_as_ro
000014BA  4EB8 11F6                598      JSR enter
000014BE  6000 FD22                599      BRA out
000014C2                           600      
000014C2                           601  print_not
000014C2  43F8 044D                602      LEA not_ins, A1 *print instruction
000014C6  4EB8 11E4                603      JSR print
000014CA  4EB9 00001718            604      JSR size
000014D0  3602                     605      MOVE.W D2, D3
000014D2  C63C 003F                606      AND.B #$3F, D3
000014D6  B63C 003C                607      CMP.B #$3C, D3
000014DA  6700 FCEA                608      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
000014DE  4EB9 00001734            609      JSR addr
000014E4  4EB8 11F6                610      JSR enter
000014E8  6000 FCF8                611      BRA out
000014EC                           612  
000014EC                           613  print_jsr
000014EC  43F8 0451                614      LEA jsr_ins, A1 *print instruction
000014F0  4EB8 11E4                615      JSR print
000014F4  4EB9 00001734            616      JSR addr    *print address
000014FA  4EB8 11F6                617      JSR enter   *print enter (next line)
000014FE  6000 FCE2                618      BRA out
00001502                           619  
00001502                           620  print_lea
00001502  43F8 0456                621      LEA lea_ins, A1 *print instruction
00001506  4EB8 11E4                622      JSR print   
0000150A  4EB9 00001734            623      JSR addr    *print address
00001510  43F8 0486                624      LEA comma, A1   *print comma
00001514  4EB8 11E4                625      JSR print
00001518  4EB9 000018D0            626      JSR add_reg_sr *print destination address register
0000151E  4EB8 11F6                627      JSR enter
00001522  6000 FCBE                628      BRA out
00001526                           629  
00001526                           630  print_addq
00001526  43F8 0434                631      LEA addq_ins, A1    *print instruction
0000152A  4EB8 11E4                632      JSR print
0000152E  4EB9 00001718            633      JSR size            *print instruction size
00001534  43F8 0489                634      LEA pound, A1
00001538  4EB8 11E4                635      JSR print           *print '#' for immediate addressing
0000153C  3C02                     636      MOVE.W D2,D6
0000153E  EF5E                     637      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
00001540  CC7C 0007                638      AND.W #$0007, D6
00001544  4EB9 000018AC            639      JSR Xn
0000154A  43F8 0486                640      LEA comma, A1       *print comma
0000154E  4EB8 11E4                641      JSR print
00001552  4EB9 00001734            642      JSR addr            *print destination address
00001558  4EB8 11F6                643      JSR enter
0000155C  6000 FC84                644      BRA out
00001560                           645  
00001560                           646  print_bra_bcc           *needs comments
00001560  3602                     647      MOVE.W D2,D3
00001562  C67C 0F00                648      AND.W #$0F00, D3
00001566  B67C 0000                649      CMP.W #$0000, D3
0000156A  6700 001E                650      BEQ print_bra
0000156E  B67C 0700                651      CMP.W #$0700, D3
00001572  6700 0022                652      BEQ print_beq
00001576  B67C 0E00                653      CMP.W #$0E00, D3
0000157A  6700 0032                654      BEQ print_bgt
0000157E  B67C 0F00                655      CMP.W #$0F00, D3
00001582  6700 001E                656      BEQ print_ble
00001586  6000 FC3E                657      BRA invalid
0000158A                           658  print_bra
0000158A  43F8 046C                659      LEA bra_ins, A1
0000158E  4EB8 11E4                660      JSR print
00001592  6000 0022                661      BRA next_bra_bcc
00001596                           662  print_beq
00001596  43F8 0468                663      LEA beq_ins, A1
0000159A  4EB8 11E4                664      JSR print
0000159E  6000 0016                665      BRA next_bra_bcc
000015A2                           666  print_ble
000015A2  43F8 0464                667      LEA ble_ins, A1
000015A6  4EB8 11E4                668      JSR print
000015AA  6000 000A                669      BRA next_bra_bcc
000015AE                           670  print_bgt
000015AE  43F8 0460                671      LEA bgt_ins, A1
000015B2  4EB8 11E4                672      JSR print
000015B6                           673  next_bra_bcc
000015B6  3602                     674      MOVE.W D2, D3
000015B8  C67C 00FF                675      AND.W #$00FF, D3
000015BC  B67C 0000                676      CMP.W #$0000, D3
000015C0  6700 0026                677      BEQ check_word
000015C4  43F8 0407                678      LEA byte, A1
000015C8  4EB8 11E4                679      JSR print
000015CC  43F8 0499                680      LEA dollar, A1
000015D0  4EB8 11E4                681      JSR print
000015D4  3203                     682      MOVE.W D3, D1
000015D6  3602                     683      MOVE.W D2, D3
000015D8  343C 0010                684      MOVE.W #16, D2
000015DC  303C 000F                685      MOVE.W #15,D0
000015E0  4E4F                     686      trap #15            *print immediate address value
000015E2  3403                     687      MOVE.W D3, D2
000015E4  6000 0024                688      BRA end_bra_bcc
000015E8                           689  check_word
000015E8  43F8 0403                690      LEA word, A1
000015EC  4EB8 11E4                691      JSR print
000015F0  43F8 0499                692      LEA dollar, A1
000015F4  4EB8 11E4                693      JSR print
000015F8  544C                     694      ADDA.W #2,A4        *update current address
000015FA  3214                     695      MOVE.W (A4),D1      *retrieve word data stored in the new current address
000015FC  3602                     696      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
000015FE  343C 0010                697      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001602  103C 000F                698      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001606  4E4F                     699      TRAP #15
00001608  3403                     700      MOVE.W D3,D2        *copy opcode back to register D2
0000160A                           701  end_bra_bcc
0000160A  4EB8 11F6                702      JSR enter
0000160E  6000 FBD2                703      BRA out
00001612                           704  
00001612                           705  print_movem         *needs comments
00001612  43F8 041F                706      LEA movem_ins, A1
00001616  4EB8 11E4                707      JSR print
0000161A  3602                     708      MOVE.W D2,D3
0000161C  C67C 0040                709      AND.W #$0040,D3
00001620  B67C 0040                710      CMP.W #$0040,D3
00001624  6700 000E                711      BEQ movem_long
00001628  43F8 0403                712      LEA word, A1
0000162C  4EB8 11E4                713      JSR print
00001630  6000 000A                714      BRA movem_direction
00001634                           715  movem_long
00001634  43F8 03FF                716      LEA long, A1
00001638  4EB8 11E4                717      JSR print
0000163C                           718  movem_direction
0000163C  3602                     719      MOVE.W D2,D3
0000163E  C67C 0400                720      AND.W #$0400,D3
00001642  B67C 0400                721      CMP.W #$0400,D3
00001646  6700 001A                722      BEQ mem_to_reg
0000164A  4EB9 000018E8            723      JSR movem_predec
00001650  43F8 0486                724      LEA comma, A1
00001654  4EB8 11E4                725      JSR print
00001658  4EB9 00001734            726      JSR addr
0000165E  6000 0016                727      BRA end_movem
00001662                           728  mem_to_reg
00001662  4EB9 00001734            729      JSR addr
00001668  43F8 0486                730      LEA comma, A1
0000166C  4EB8 11E4                731      JSR print
00001670  4EB9 000019BA            732      JSR movem_postinc
00001676                           733  end_movem
00001676  4EB8 11F6                734      JSR enter
0000167A  6000 FB66                735      BRA out
0000167E                           736  
0000167E                           737  print_direction:
0000167E                           738  *print correct direction given direction bit
0000167E  C67C 0100                739      AND.W #$0100, D3
00001682  B67C 0100                740      CMP.W #$0100, D3
00001686  6700 000E                741      BEQ print_left  *print left
0000168A  43F8 0470                742      LEA right, A1
0000168E  4EB8 11E4                743      JSR print
00001692  6000 FB4E                744      BRA out
00001696                           745  print_left
00001696  43F8 0472                746      LEA left, A1
0000169A  4EB8 11E4                747      JSR print *print right
0000169E  4E75                     748      RTS
000016A0                           749      
000016A0                           750  print_correct_shift_rotation:
000016A0                           751  *determine if instruction is logical, arithmetic, or rotation 
000016A0  C63C 0003                752      AND.B #$03, D3
000016A4  B63C 0000                753      CMP.B #$00, D3
000016A8  6700 0016                754      BEQ print_as
000016AC  B63C 0001                755      CMP.B #$01, D3
000016B0  6700 0016                756      BEQ print_ls
000016B4  B63C 0003                757      CMP.B #$03, D3
000016B8  43F8 044A                758      LEA ro_ins, A1  print rotation
000016BC  6000 000E                759      BRA print_it
000016C0                           760  print_as
000016C0  43F8 0447                761      LEA as_ins, A1  print arithmetic shift
000016C4  6000 0006                762      BRA print_it
000016C8                           763  print_ls
000016C8  43F8 0444                764      LEA ls_ins, A1 print logical shift
000016CC                           765  print_it
000016CC  4EB8 11E4                766      JSR print
000016D0  4E75                     767      RTS
000016D2                           768  * --------- End Print Instruction ----------*
000016D2                           769  
000016D2                           770  * ------- Instruction sizes ---------*
000016D2                           771  
000016D2                           772  move_size:  *print size for MOVE and MOVEA instruction
000016D2  4284                     773      CLR.L D4
000016D4  3802                     774      MOVE.W D2, D4
000016D6  C87C 3000                775      AND.W #$3000, D4
000016DA  B87C 1000                776      CMP.W #$1000, D4
000016DE  6700 0014                777      BEQ print_b
000016E2  B87C 3000                778      CMP.W #$3000, D4
000016E6  6700 0018                779      BEQ print_w
000016EA  B87C 2000                780      CMP.W #$2000, D4
000016EE  6700 001C                781      BEQ print_l
000016F2  4E75                     782      RTS
000016F4                           783      
000016F4                           784  print_b     *print '.B'
000016F4  43F8 0407                785      LEA byte, A1
000016F8  4EB8 11E4                786      JSR print
000016FC  6000 FAE4                787      BRA out
00001700                           788      
00001700                           789  print_w     *print '.W'
00001700  43F8 0403                790      LEA word, A1
00001704  4EB8 11E4                791      JSR print
00001708  6000 FAD8                792      BRA out
0000170C                           793      
0000170C                           794  print_l:    *print '.L'
0000170C  43F8 03FF                795      LEA long, A1
00001710  4EB8 11E4                796      JSR print
00001714  6000 FACC                797      BRA out
00001718                           798  
00001718                           799  size:       *print size for non "move" instructions
00001718  4284                     800      CLR.L D4
0000171A  1802                     801      MOVE.B D2,D4
0000171C  C83C 00C0                802      AND.B #$C0, D4
00001720  B83C 0000                803      CMP.B #$00, D4
00001724  67CE                     804      BEQ print_b
00001726  B83C 0040                805      CMP.B #$40,D4
0000172A  67D4                     806      BEQ print_w
0000172C  B83C 0080                807      CMP.B #$80, D4
00001730  67DA                     808      BEQ print_l
00001732  4E75                     809      RTS
00001734                           810      
00001734                           811  * ------- End Instruction sizes ---------*
00001734                           812  
00001734                           813  * ------- Effective Address -------*
00001734                           814  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
00001734  3A02                     815      MOVE.W D2, D5
00001736  3C02                     816      MOVE.W D2, D6               
00001738  BE3C 0001                817      CMP.B #1, D7
0000173C  6700 003A                818      BEQ destination *check if evaluating destination address (used for MOVE)
00001740                           819  cont
00001740  CC3C 0038                820      AND.B #$38, D6
00001744  BC3C 0000                821      CMP.B #0, D6
00001748  6700 0038                822      BEQ data_reg        *check if EA mode is data register
0000174C  BC3C 0008                823      CMP.B #$08, D6
00001750  6700 0048                824      BEQ add_reg         *check if EA mode is address register
00001754  BC3C 0010                825      CMP.B #$10, D6
00001758  6700 0058                826      BEQ add_indirect    *check if EA mode is address indirect
0000175C  BC3C 0018                827      CMP.B #$18, D6
00001760  6700 0070                828      BEQ post_increment  *check if EA mode is post increment
00001764  BC3C 0020                829      CMP.B #$20, D6
00001768  6700 0088                830      BEQ pre_decrement   *check if EA mode is pre_decrement
0000176C  BC3C 0038                831      CMP.B #$38, D6
00001770  6700 00A0                832      BEQ absolute_or_immediate
00001774  6000 FA6C                833      BRA out *needs Immediate, Abs Long, and Abs Word
00001778                           834  destination     *perform correct rotation to retrieve destination address
00001778  3C05                     835      MOVE.W D5,D6
0000177A  EF5D                     836      ROL.W #7,D5
0000177C  E64E                     837      LSR.W #3,D6
0000177E  60C0                     838      BRA cont
00001780  4E75                     839      RTS
00001782                           840  
00001782                           841  data_reg    *used with addr sub routine
00001782  3C05                     842      MOVE.W D5,D6    
00001784  CC3C 0007                843      AND.B #$07, D6  
00001788  43F8 0474                844      LEA D_reg, A1   
0000178C  4EB8 11E4                845      JSR print
00001790  4EB9 000018AC            846      JSR Xn
00001796  6000 FA4A                847      BRA out
0000179A                           848  
0000179A                           849  add_reg     *used with addr sub routine
0000179A  3C05                     850      MOVE.W D5,D6    
0000179C  CC3C 0007                851      AND.B #$07, D6
000017A0  43F8 0476                852      LEA A_reg, A1   
000017A4  4EB8 11E4                853      JSR print
000017A8  4EB9 000018AC            854      JSR Xn
000017AE  6000 FA32                855      BRA out
000017B2                           856      
000017B2                           857  add_indirect    *used with addr sub routine
000017B2  3C05                     858      MOVE.W D5,D6    
000017B4  CC3C 0007                859      AND.B #$07, D6
000017B8  43F8 0478                860      LEA open_paran, A1  
000017BC  4EB8 11E4                861      JSR print
000017C0  4EB9 000018AC            862      JSR Xn
000017C6  43F8 047B                863      LEA close_paran, A1 
000017CA  4EB8 11E4                864      JSR print
000017CE  6000 FA12                865      BRA out
000017D2                           866      
000017D2                           867  post_increment  *used with addr sub routine
000017D2  3C05                     868      MOVE.W D5,D6    
000017D4  CC3C 0007                869      AND.B #$07, D6
000017D8  43F8 0478                870      LEA open_paran, A1  
000017DC  4EB8 11E4                871      JSR print
000017E0  4EB9 000018AC            872      JSR Xn
000017E6  43F8 047D                873      LEA post_inc, A1    
000017EA  4EB8 11E4                874      JSR print
000017EE  6000 F9F2                875      BRA out
000017F2                           876      
000017F2                           877  pre_decrement   *used with addr sub routine
000017F2  3C05                     878      MOVE.W D5,D6    
000017F4  CC3C 0007                879      AND.B #$07, D6
000017F8  43F8 0480                880      LEA pre_dec, A1 
000017FC  4EB8 11E4                881      JSR print
00001800  4EB9 000018AC            882      JSR Xn
00001806  43F8 047B                883      LEA close_paran, A1 
0000180A  4EB8 11E4                884      JSR print
0000180E  6000 F9D2                885      BRA out
00001812                           886  
00001812                           887  absolute_or_immediate *check if EA is immediate or absolute address
00001812  3C05                     888      MOVE.W D5,D6    
00001814  CC3C 0007                889      AND.B #$07, D6
00001818  BC3C 0000                890      CMP.B #$00, D6
0000181C  6700 0054                891      BEQ w_imm
00001820  BC3C 0001                892      CMP.B #$01, D6
00001824  6700 0068                893      BEQ l_imm
00001828  BC3C 0004                894      CMP.B #04, D6
0000182C  6700 0002                895      BEQ immediate
00001830                           896      
00001830                           897  immediate
00001830  43F8 0489                898      LEA pound, A1
00001834  4EB8 11E4                899      JSR print
00001838  B4BC 00004000            900      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
0000183E  6D00 0016                901      BLT move_movea      *check if instruction is move or movea
00001842  B8BC 00000040            902      CMP.L #$0040, D4        *if not move or movea
00001848  6D00 0028                903      BLT w_imm           *byte and word check the next 2 addresses in mem
0000184C  B8BC 00000080            904      CMP.L #$0080, D4
00001852  6700 003A                905      BEQ l_imm           *long checks the next 4 addresses in mem
00001856                           906  move_movea              *similar comparisons, but for different bits in OPCODE
00001856  B87C 1000                907      CMP.W #$1000, D4
0000185A  6700 0016                908      BEQ w_imm
0000185E  B87C 3000                909      CMP.W #$3000, D4
00001862  6700 000E                910      BEQ w_imm
00001866  B87C 2000                911      CMP.W #$2000, D4
0000186A  6700 0022                912      BEQ l_imm
0000186E                           913  imm_complete
0000186E  6000 F972                914      BRA out
00001872                           915      
00001872                           916  w_imm
00001872  43F8 0499                917      LEA dollar, A1      *print '$'
00001876  4EB8 11E4                918      JSR print
0000187A  544C                     919      ADDA.W #2,A4        *update current address
0000187C  3214                     920      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000187E  3602                     921      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
00001880  343C 0010                922      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001884  103C 000F                923      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001888  4E4F                     924      TRAP #15
0000188A  3403                     925      MOVE.W D3,D2        *copy opcode back to register D2
0000188C  60E0                     926      BRA imm_complete    *exit addr subroutine
0000188E                           927      
0000188E                           928  l_imm
0000188E  43F8 0499                929      LEA dollar, A1      *print '$'
00001892  4EB8 11E4                930      JSR print
00001896  544C                     931      ADDA.W  #2,A4       *update current address
00001898  2214                     932      MOVE.L (A4),D1      *retrieve long data stored in the new current address
0000189A  3602                     933      MOVE.W D2, D3
0000189C  343C 0010                934      MOVE.W #16, D2
000018A0  103C 000F                935      MOVE.B #15, D0
000018A4  4E4F                     936      TRAP #15
000018A6  3403                     937      MOVE.W D3,D2
000018A8  544C                     938      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
000018AA  60C2                     939      BRA imm_complete    *exit addr subroutine
000018AC                           940  
000018AC                           941  Xn:                     *retieve signed decimal value of data stored in register D6
000018AC  4281                     942      CLR.L D1
000018AE  1206                     943      MOVE.B D6,D1
000018B0  103C 0003                944      MOVE.B #3, D0
000018B4  4E4F                     945      TRAP #15
000018B6  4E75                     946      RTS
000018B8                           947  
000018B8                           948  data_reg_sr:    *use if dealing with Dn only
000018B8  4286                     949      CLR.L D6
000018BA  3C05                     950      MOVE.W D5,D6
000018BC  EF5E                     951      ROL.W #7,D6
000018BE  CC3C 0007                952      AND.B #$07, D6  
000018C2  43F8 0474                953      LEA D_reg, A1   
000018C6  4EB8 11E4                954      JSR print
000018CA  4EB8 18AC                955      JSR Xn
000018CE  4E75                     956      RTS
000018D0                           957      
000018D0                           958  add_reg_sr:     *use if dealing with An only
000018D0  4286                     959      CLR.L D6
000018D2  3C02                     960      MOVE.W D2,D6
000018D4  EF5E                     961      ROL.W #7,D6
000018D6  CC3C 0007                962      AND.B #$07, D6  
000018DA  43F8 0476                963      LEA A_reg, A1   
000018DE  4EB8 11E4                964      JSR print
000018E2  4EB8 18AC                965      JSR Xn
000018E6  4E75                     966      RTS
000018E8                           967      
000018E8                           968  movem_predec:           *needs to be worked on
000018E8  4285                     969      CLR.L D5
000018EA  544C                     970      ADDA.W  #2,A4       *update current address
000018EC  3A14                     971      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000018EE  BA3C 0000                972      CMP.B #$00, D5
000018F2  6700 006C                973      BEQ predec_skip_to_d
000018F6  3C05                     974      MOVE.W D5,D6
000018F8  4281                     975      CLR.L D1
000018FA  123C 0000                976      MOVE.B #0, D1
000018FE                           977  a_loop1
000018FE  E31E                     978      ROL.B #1,D6
00001900  6500 0006                979      BCS a_loop1_done
00001904  5201                     980      ADD.B #1,D1
00001906  60F6                     981      BRA a_loop1
00001908                           982  a_loop1_done
00001908  43F8 0476                983      LEA A_reg,A1
0000190C  4EB8 11E4                984      JSR print
00001910  103C 0003                985      MOVE.B #3,D0
00001914  4E4F                     986      TRAP #15
00001916  4287                     987      CLR.L D7
00001918  1E3C 0000                988      MOVE.B #0, D7
0000191C                           989  a_loop2
0000191C  E31E                     990      ROL.B #1,D6
0000191E  6400 0010                991      BCC a_loop2_done
00001922  5207                     992      ADD.B #1,D7
00001924  5201                     993      ADD.B #1,D1
00001926  B23C 0007                994      CMP.B #7, D1
0000192A  6700 0004                995      BEQ a_loop2_done
0000192E  60EC                     996      BRA a_loop2
00001930                           997  a_loop2_done
00001930  BE3C 0000                998      CMP.B #0, D7
00001934  6700 0018                999      BEQ predec_no_dash
00001938  43F8 048B               1000      LEA dash, A1
0000193C  4EB8 11E4               1001      JSR print
00001940  43F8 0476               1002      LEA A_reg,A1
00001944  4EB8 11E4               1003      JSR print
00001948  103C 0003               1004      MOVE.B #3,D0
0000194C  4E4F                    1005      TRAP #15
0000194E                          1006  predec_no_dash
0000194E  BABC 000000FF           1007      CMP.L #$00FF,D5
00001954  6F00 0062               1008      BLE end_movem_predec
00001958  43F8 048D               1009      LEA slash, A1
0000195C  4EB8 11E4               1010      JSR print
00001960                          1011  predec_skip_to_d    
00001960  3C05                    1012      MOVE.W D5,D6
00001962  E04E                    1013      LSR.W #8,D6
00001964  4281                    1014      CLR.L D1
00001966  123C 0000               1015      MOVE.B #0, D1
0000196A                          1016  d_loop1
0000196A  E31E                    1017      ROL.B #1,D6
0000196C  6500 0006               1018      BCS d_loop1_done
00001970  5201                    1019      ADD.B #1,D1
00001972  60F6                    1020      BRA d_loop1
00001974                          1021  d_loop1_done
00001974  43F8 0474               1022      LEA D_reg,A1
00001978  4EB8 11E4               1023      JSR print
0000197C  103C 0003               1024      MOVE.B #3,D0
00001980  4E4F                    1025      TRAP #15
00001982  4287                    1026      CLR.L D7
00001984  1E3C 0000               1027      MOVE.B #0, D7
00001988                          1028  d_loop2
00001988  E31E                    1029      ROL.B #1,D6
0000198A  6400 000E               1030      BCC d_loop2_done
0000198E  5201                    1031      ADD.B #1,D1
00001990  B23C 0007               1032      CMP.B #7, D1
00001994  6700 0004               1033      BEQ d_loop2_done
00001998  60EE                    1034      BRA d_loop2
0000199A                          1035  d_loop2_done
0000199A  BE3C 0000               1036      CMP.B #0, D7
0000199E  6F00 0018               1037      BLE end_movem_predec
000019A2  43F8 048B               1038      LEA dash, A1
000019A6  4EB8 11E4               1039      JSR print
000019AA  43F8 0474               1040      LEA D_reg,A1
000019AE  4EB8 11E4               1041      JSR print
000019B2  103C 0003               1042      MOVE.B #3,D0
000019B6  4E4F                    1043      TRAP #15
000019B8                          1044  end_movem_predec
000019B8  4E75                    1045      RTS
000019BA                          1046      
000019BA                          1047  movem_postinc:          *needs to be worked on
000019BA  4285                    1048      CLR.L D5
000019BC  544C                    1049      ADDA.W  #2,A4       *update current address
000019BE  3A14                    1050      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019C0  3C05                    1051      MOVE.W D5,D6
000019C2  E04E                    1052      LSR.W #8,D6
000019C4  BC3C 0000               1053      CMP.B #$00, D6
000019C8  6700 0068               1054      BEQ postinc_skip_to_d
000019CC  4281                    1055      CLR.L D1
000019CE  123C 0000               1056      MOVE.B #0, D1
000019D2                          1057  a_loop3
000019D2  E21E                    1058      ROR.B #1,D6
000019D4  6500 0006               1059      BCS a_loop3_done
000019D8  5201                    1060      ADD.B #1,D1
000019DA  60F6                    1061      BRA a_loop3
000019DC                          1062  a_loop3_done
000019DC  43F8 0476               1063      LEA A_reg,A1
000019E0  4EB8 11E4               1064      JSR print
000019E4  103C 0003               1065      MOVE.B #3,D0
000019E8  4E4F                    1066      TRAP #15
000019EA  4287                    1067      CLR.L D7
000019EC  1E3C 0000               1068      MOVE.B #0, D7
000019F0                          1069  a_loop4
000019F0  E21E                    1070      ROR.B #1,D6
000019F2  6400 0010               1071      BCC a_loop4_done
000019F6  5207                    1072      ADD.B #1,D7
000019F8  5201                    1073      ADD.B #1,D1
000019FA  B23C 0007               1074      CMP.B #7, D1
000019FE  6700 0004               1075      BEQ a_loop4_done
00001A02  60EC                    1076      BRA a_loop4
00001A04                          1077  a_loop4_done
00001A04  BE3C 0000               1078      CMP.B #0, D7
00001A08  6700 0018               1079      BEQ postinc_no_dash
00001A0C  43F8 048B               1080      LEA dash, A1
00001A10  4EB8 11E4               1081      JSR print
00001A14  43F8 0476               1082      LEA A_reg,A1
00001A18  4EB8 11E4               1083      JSR print
00001A1C  103C 0003               1084      MOVE.B #3,D0
00001A20  4E4F                    1085      TRAP #15
00001A22                          1086  postinc_no_dash
00001A22  BA3C 0000               1087      CMP.B #$00, D5
00001A26  6700 0060               1088      BEQ end_movem_postinc
00001A2A  43F8 048D               1089      LEA slash, A1
00001A2E  4EB8 11E4               1090      JSR print
00001A32                          1091  postinc_skip_to_d   
00001A32  3C05                    1092      MOVE.W D5,D6
00001A34  4281                    1093      CLR.L D1
00001A36  123C 0000               1094      MOVE.B #0, D1
00001A3A                          1095  d_loop3
00001A3A  E21E                    1096      ROR.B #1,D6
00001A3C  6500 0006               1097      BCS d_loop3_done
00001A40  5201                    1098      ADD.B #1,D1
00001A42  60F6                    1099      BRA d_loop3
00001A44                          1100  d_loop3_done
00001A44  43F8 0474               1101      LEA D_reg,A1
00001A48  4EB8 11E4               1102      JSR print
00001A4C  103C 0003               1103      MOVE.B #3,D0
00001A50  4E4F                    1104      TRAP #15
00001A52  4287                    1105      CLR.L D7
00001A54  1E3C 0000               1106      MOVE.B #0, D7
00001A58                          1107  d_loop4
00001A58  E21E                    1108      ROR.B #1,D6
00001A5A  6400 000E               1109      BCC d_loop4_done
00001A5E  5201                    1110      ADD.B #1,D1
00001A60  B23C 0007               1111      CMP.B #7, D1
00001A64  6700 0004               1112      BEQ d_loop4_done
00001A68  60EE                    1113      BRA d_loop4
00001A6A                          1114  d_loop4_done
00001A6A  BE3C 0000               1115      CMP.B #0, D7
00001A6E  6F00 0018               1116      BLE end_movem_postinc
00001A72  43F8 048B               1117      LEA dash, A1
00001A76  4EB8 11E4               1118      JSR print
00001A7A  43F8 0474               1119      LEA D_reg,A1
00001A7E  4EB8 11E4               1120      JSR print
00001A82  103C 0003               1121      MOVE.B #3,D0
00001A86  4E4F                    1122      TRAP #15
00001A88                          1123  end_movem_postinc
00001A88  4E75                    1124      RTS
00001A8A                          1125  
00001A8A                          1126  
00001A8A                          1127  * ------- End Effective Address -------*
00001A8A                          1128  
00001A8A                          1129  * ----- Hex to ASCII & ASCII to HEX -----*
00001A8A                          1130  
00001A8A                          1131  ASCIItoHex:
00001A8A  4EB9 00001A98           1132          jsr     ASCII2Hex_init  
00001A90  4EB9 00001A9E           1133          jsr     conversion_loop
00001A96  4E75                    1134          rts                    
00001A98                          1135  
00001A98                          1136  ASCII2Hex_init:   
00001A98  143C 0000               1137          move.b  #0,D2       *set up counter    
00001A9C  4E75                    1138          rts         
00001A9E                          1139          
00001A9E                          1140  conversion_loop:            
00001A9E  5282                    1141          add.l   #1,D2       *increment counter
00001AA0  B4BC 00000009           1142          cmp.l   #9,D2       *ends at 9
00001AA6  6700 004A               1143          BEQ     DONE        *branch when compare is true
00001AAA  1819                    1144          move.b  (A1)+,D4    *Get first num
00001AAC                          1145          
00001AAC  B83C 0040               1146          cmp.b   #$40,D4        
00001AB0  6E00 000C               1147          bgt     Letters_Cap  
00001AB4                          1148          
00001AB4  B83C 0039               1149          cmp.b   #$39,D4
00001AB8  6F00 0016               1150          BLE     Numbers      
00001ABC  4E75                    1151          rts
00001ABE                          1152          
00001ABE                          1153  Letters_Cap:      
00001ABE  B83C 0046               1154          cmp.b   #$46,D4          
00001AC2  6E00 001E               1155          bgt     ERROR  
00001AC6  0404 0037               1156          sub.b   #$37,D4     
00001ACA  E986                    1157          asl.l   #4,D6       
00001ACC  DC84                    1158          add.l   D4,D6     
00001ACE  60CE                    1159          bra     conversion_loop 
00001AD0                          1160  Numbers:
00001AD0  B83C 0030               1161          cmp.b   #$30,D4         
00001AD4  6D00 000C               1162          blt     ERROR        
00001AD8  0404 0030               1163          sub.b   #$30,D4      
00001ADC  E986                    1164          asl.l   #4,D6        
00001ADE  DC84                    1165          add.l   D4,D6     
00001AE0  60BC                    1166          bra     conversion_loop
00001AE2                          1167          
00001AE2                          1168  ERROR:
00001AE2  43F8 011E               1169          lea     ErrorMsg,A1    
00001AE6  103C 000E               1170          move.b  #14,D0
00001AEA  4E4F                    1171          trap    #15
00001AEC                          1172      
00001AEC  103C 0009               1173          move.b  #9,D0
00001AF0  4E4F                    1174          trap    #15
00001AF2                          1175          
00001AF2                          1176  DONE:
00001AF2                          1177     
00001AF2  4241                    1178          clr     D1
00001AF4  4242                    1179          clr     D2
00001AF6  4244                    1180          clr     D4
00001AF8                          1181      
00001AF8  43F8 014F               1182          lea     ASCIItoHexMsg,A1
00001AFC  103C 000E               1183          move.b  #14,D0
00001B00  4E4F                    1184          trap    #15
00001B02                          1185  
00001B02  4E75                    1186          rts
00001B04                          1187          
00001B04                          1188  
00001B04                          1189          
00001B04                          1190  * -- End of Hex to ASCII & ASCII to HEX --*
00001B04                          1191  
00001B04                          1192  * Put program code here
00001B04                          1193  
00001B04  FFFF FFFF               1194      SIMHALT             ; halt simulator
00001B08                          1195  
00001B08                          1196  * Put variables and constants here
00001B08                          1197  
00001B08                          1198      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  1812
ADDA_INS            42F
ADDA_SIZE           1322
ADDQ_INS            434
ADDR                1734
ADD_A               1300
ADD_INDIRECT        17B2
ADD_INS             42B
ADD_REG             179A
ADD_REG_SR          18D0
ANDQ_INS            45B
AND_INS             43C
ASCII2HEX_INIT      1A98
ASCIITOHEX          1A8A
ASCIITOHEXMSG       14F
AS_INS              447
A_LOOP1             18FE
A_LOOP1_DONE        1908
A_LOOP2             191C
A_LOOP2_DONE        1930
A_LOOP3             19D2
A_LOOP3_DONE        19DC
A_LOOP4             19F0
A_LOOP4_DONE        1A04
A_REG               476
BEQ_INS             468
BGT_INS             460
BLE_INS             464
BRA_INS             46C
BYTE                407
CHECKADDRESS        10D2
CHECK_WORD          15E8
CLEAR_REGISTERS     1044
CLOSE_PARAN         47B
COMMA               486
CONT                1740
CONTINUEORNOTMSG    1CC
CONTINUE_INSTRUCTION_LS_AS_RO  1476
CONVERSION_LOOP     1A9E
CR                  D
CREATORS            1F
DASH                48B
DATA                492
DATA_REG            1782
DATA_REG_SR         18B8
DESTINATION         1778
DOLLAR              499
DONE                1AF2
D_LOOP1             196A
D_LOOP1_DONE        1974
D_LOOP2             1988
D_LOOP2_DONE        199A
D_LOOP3             1A3A
D_LOOP3_DONE        1A44
D_LOOP4             1A58
D_LOOP4_DONE        1A6A
D_REG               474
EA_DEST_ADD         12E6
EA_DEST_SUB_AND_OR  13C8
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             1342
END_ADDR_BUFFER     2FF
END_BRA_BCC         160A
END_MOVEM           1676
END_MOVEM_POSTINC   1A88
END_MOVEM_PREDEC    19B8
ENTER               11F6
ERROR               1AE2
ERRORMSG            11E
EXITMSG             1EF
FLUSHSCREEN         112E
GETENDADDRESS       10B8
GETSTARTADDRESS     109E
HELPMSG             190
HEXTOASCIIMSG       12D
IMMEDIATE           1830
IMM_COMPLETE        186E
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             11C6
JSR_INS             451
LEA_INS             456
LEFT                472
LETTERS_CAP         1ABE
LF                  A
LONG                3FF
LS_AS_RO_MEM        148C
LS_AS_RO_REG        146E
LS_INS              444
L_IMM               188E
MEMSEARCH           10D6
MEMSEARCHLOOP       10DE
MEMSEARCH_DONE      110C
MEM_TO_REG          1662
MENU                1080
MOVEA_INS           425
MOVEM_DIRECTION     163C
MOVEM_INS           41F
MOVEM_LONG          1634
MOVEM_POSTINC       19BA
MOVEM_PREDEC        18E8
MOVEQ_INS           418
MOVE_A              1272
MOVE_INS            413
MOVE_MOVEA          1856
MOVE_SIZE           16D2
MUL_DIV             13E6
MUL_DIV_LONG        1408
M_SIZE              127A
NEXT_ADD            132E
NEXT_BRA_BCC        15B6
NEXT_LS_AS_RO       14BA
NOP_INS             40B
NOT_INS             44D
NUMBERS             1AD0
OPCODE_DECODE       112E
OPEN_PARAN          478
OR_INS              439
OUT                 11E2
POSTINC_NO_DASH     1A22
POSTINC_SKIP_TO_D   1A32
POST_INC            47D
POST_INCREMENT      17D2
POUND               489
PREDEC_NO_DASH      194E
PREDEC_SKIP_TO_D    1960
PRE_DEC             480
PRE_DECREMENT       17F2
PRINT               11E4
PRINTLN             11EE
PRINT_ADDQ          1526
PRINT_ADD_ADDA      12A2
PRINT_AS            16C0
PRINT_B             16F4
PRINT_BEQ           1596
PRINT_BGT           15AE
PRINT_BLE           15A2
PRINT_BRA           158A
PRINT_BRA_BCC       1560
PRINT_CORRECT_SHIFT_ROTATION  16A0
PRINT_DIRECTION     167E
PRINT_INSTRUCTION   1396
PRINT_IT            16CC
PRINT_JSR           14EC
PRINT_L             170C
PRINT_LEA           1502
PRINT_LEFT          1696
PRINT_LS            16C8
PRINT_LS_AS_RO      140E
PRINT_MOVEM         1612
PRINT_MOVEQ         1214
PRINT_MOVE_MOVEA    1258
PRINT_NOP           1200
PRINT_NOT           14C2
PRINT_OR            1392
PRINT_RTS           120A
PRINT_SUB           137C
PRINT_SUB_AND_OR    134A
PRINT_W             1700
RETURN              48F
RIGHT               470
RO_INS              44A
RTS_INS             40F
SCREENFLUSH         1124
SIZE                1718
SLASH               48D
SPACE               484
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   1FF
SUB_INS             440
TAB                 9
TERMINATEORCONT     1118
WORD                403
W_IMM               1872
XN                  18AC
