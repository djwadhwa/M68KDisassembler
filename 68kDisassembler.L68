00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/9/2020 3:30:55 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  68k Disassebler
00000000                             3  * Written by :  Dj Wadhwa, Mohammed Ali, Tarcisius Hartanto
00000000                             4  * Date       :  June 2nd, 2020
00000000                             5  * Description:  This program decodes machine code and turns it into assembly code for the 68k processor
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR  EQU $0D
00000000  =0000000A                  8  LF  EQU $0A
00000000                             9  
00000000= 54 68 69 73 20 69 ...     10  StartingMsg         dc.b    'This is our 68k Disassembler',CR,LF,0
0000001F= 43 72 65 61 74 6F ...     11  Creators            dc.b    'Creators: Mohammed Ali, DJ Wadhwa, Tarcisius',CR,LF,0
0000004E                            12  
0000004E= 53 74 61 72 74 20 ...     13  InputMsg1           dc.b    'Start by giving a starting address in range (00009000,00FFFFFF) ',0
0000008F= 4E 6F 77 20 67 69 ...     14  InputMsg2           dc.b    'Now give an ending adress in range (00009000,00FFFFFF) ',0
000000C7= 54 68 69 73 20 69 ...     15  InputIsInc          dc.b    'This input is not an address',0
000000E4= 54 68 65 20 65 6E ...     16  EndAddressInc       dc.b    'The end address is before the starting address, TRY AGAIN',0
0000011E= 45 72 72 6F 72 20 ...     17  ErrorMsg            dc.b    'Error in Input',0
0000012D                            18  
0000012D= 43 6F 6D 70 6C 65 ...     19  HextoASCIIMsg       dc.b    'Completed hex to ASCII conversion',0
0000014F= 43 6F 6D 70 6C 65 ...     20  ASCIItoHexMsg       dc.b    'Completed ASCII to hex conversion',CR,LF,0
00000173                            21  
00000173= 2D 2D 2D 2D 2D 2D ...     22  EndOfMemLoop        dc.b    '-------End of mem loop----',CR,LF,0
00000190= 49 6E 70 75 74 73 ...     23  HelpMsg             dc.b    'Inputs must be in hexadecimal in this format --> FFFFFFFF',CR,LF,0
000001CC= 57 6F 75 6C 64 20 ...     24  ContinueOrNotMsg    dc.b    'Would you like to Contunue or quit',0
000001EF= 45 78 69 74 69 6E ...     25  ExitMsg             dc.b    'Exiting Program',0
000001FF                            26  
000001FF= 50 72 65 73 73 20 ...     27  Flush_Message       dc.b    'Press Enter to get next set of instructions',0
0000022B                            28  
0000022B                            29  START_ADDR_BUFFER  DS.B    256
0000032B                            30  END_ADDR_BUFFER    DS.B    256
0000042B                            31  
0000042B                            32  *size
0000042B= 2E 4C 20 00               33  long                DC.B    '.L ',0
0000042F= 2E 57 20 00               34  word                DC.B    '.W ',0
00000433= 2E 42 20 00               35  byte                DC.B    '.B ',0
00000437                            36  
00000437                            37  *instructions
00000437= 4E 4F 50 00               38  nop_ins             DC.B    'NOP',0
0000043B= 52 54 53 00               39  rts_ins             DC.B    'RTS',0
0000043F= 4D 4F 56 45 00            40  move_ins            DC.B    'MOVE',0
00000444= 4D 4F 56 45 51 20 00      41  moveq_ins           DC.B    'MOVEQ ',0
0000044B= 4D 4F 56 45 4D 00         42  movem_ins           DC.B    'MOVEM',0
00000451= 4D 4F 56 45 41 00         43  movea_ins           DC.B    'MOVEA',0
00000457= 41 44 44 00               44  add_ins             DC.B    'ADD',0
0000045B= 41 44 44 41 00            45  adda_ins            DC.B    'ADDA',0
00000460= 41 44 44 51 00            46  addq_ins            DC.B    'ADDQ',0
00000465= 4F 52 00                  47  or_ins              DC.B    'OR',0
00000468= 41 4E 44 00               48  and_ins             DC.B    'AND',0
0000046C= 53 55 42 00               49  sub_ins             DC.B    'SUB',0
00000470= 4C 53 00                  50  ls_ins              DC.B    'LS',0
00000473= 41 53 00                  51  as_ins              DC.B    'AS',0
00000476= 52 4F 00                  52  ro_ins              DC.B    'RO',0
00000479= 4E 4F 54 00               53  not_ins             DC.B    'NOT',0
0000047D= 4A 53 52 20 00            54  jsr_ins             DC.B    'JSR ',0
00000482= 4C 45 41 20 00            55  lea_ins             DC.B    'LEA ',0
00000487= 41 44 44 51 00            56  andq_ins            DC.B    'ADDQ',0
0000048C= 42 47 54 00               57  bgt_ins             DC.B    'BGT',0
00000490= 42 4C 45 00               58  ble_ins             DC.B    'BLE',0
00000494= 42 45 51 00               59  beq_ins             DC.B    'BEQ',0
00000498= 42 52 41 00               60  bra_ins             DC.B    'BRA',0
0000049C                            61  
0000049C                            62  *direction
0000049C= 52 00                     63  right               DC.B    'R',0
0000049E= 4C 00                     64  left                DC.B    'L',0
000004A0                            65  
000004A0                            66  *EA
000004A0= 44 00                     67  D_reg               DC.B    'D',0
000004A2= 41 00                     68  A_reg               DC.B    'A',0
000004A4= 28 41 00                  69  open_paran          DC.B    '(A',0
000004A7= 29 00                     70  close_paran         DC.B    ')',0
000004A9= 29 2B 00                  71  post_inc            DC.B    ')+',0
000004AC= 2D 28 41 00               72  pre_dec             DC.B    '-(A',0
000004B0                            73  
000004B0                            74  *extra
000004B0= 20 00                     75  space               DC.B    ' ',0
000004B2= 2C 20 00                  76  comma               DC.B    ', ',0
000004B5= 23 00                     77  pound               DC.B    '#',0
000004B7= 2D 00                     78  dash                DC.B    '-',0
000004B9= 2F 00                     79  slash               DC.B    '/',0
000004BB  =00000009                 80  tab                 EQU     $9
000004BB= 0D 0A 00                  81  return              DC.B    CR,LF,0
000004BE= 44 41 54 41 20 24 00      82  data                DC.B    'DATA $',0
000004C5= 24 00                     83  dollar              DC.B    '$',0
00001000                            84      ORG    $1000    *Start at address $1000
00001000                            85  START:                  ; first instruction of program
00001000                            86  
00001000                            87  *---------- Test value, will remove in final build ----------*
00001000                            88  
00001000  33FC 4E75 00009234        89      Move.W #$4E75,$00009234 *RTS
00001008  33FC 3C05 00009236        90      MOVE.W #$3C05,$00009236 *MOVE.W D5,D6
00001010  33FC 2447 00009238        91      MOVE.W #$2447,$00009238 *MOVEA.L D7,A2
00001018  33FC 4E71 0000923A        92      MOVE.W #$4E71,$0000923A *NOP
00001020  33FC D95C 0000923C        93      MOVE.W #$D95C,$0000923C *ADD.W D0,(A4)+
00001028  33FC D3C2 0000923E        94      MOVE.W #$D3C2,$0000923E *ADDA.L D2,A1
00001030  33FC 9822 00009240        95      MOVE.W #$9822,$00009240 *SUB.B -(A2),D4
00001038  33FC C246 00009242        96      MOVE.W #$C246,$00009242 *AND.W D6,D1
00001040  33FC 8593 00009244        97      MOVE.W #$8593,$00009244 *OR.L D2,(A3)
00001048  33FC E0C7 00009246        98      MOVE.W #$E0C7,$00009246 *ASR D7
00001050  33FC ED4C 00009248        99      MOVE.W #$ED4C,$00009248 *LSL.W #6, D4
00001058  33FC E4BB 0000924A       100      MOVE.W #$E4BB,$0000924A *ROR.L D2, D3
00001060  33FC 7404 0000924C       101      MOVE.W #$7404,$0000924C *MOVEQ #4, D2
00001068  33FC C23C 0000924E       102      MOVE.W #$C23C,$0000924E *AND.B #12, D1
00001070  33FC 000C 00009250       103      MOVE.W #$000C,$00009250
00001078  33FC 2C3C 00009252       104      MOVE.W #$2C3C,$00009252 *MOVE.L #$12345678, D6
00001080  23FC 12345678 00009254   105      MOVE.L #$12345678,$00009254
0000108A  33FC D4F8 00009258       106      MOVE.W #$D4F8,$00009258 *ADDA.W $12, A2
00001092  33FC 0012 0000925A       107      MOVE.W #$0012,$0000925A
0000109A  33FC 4607 0000925C       108      MOVE.W #$4607,$0000925C *NOT.B D7
000010A2  33FC 4EB9 0000925E       109      MOVE.W #$4EB9,$0000925E *JSR $9208
000010AA  23FC 00009208 00009260   110      MOVE.L #$00009208,$00009260
000010B4  33FC 4E90 00009264       111      MOVE.W #$4E90,$00009264 *JSR (A0)
000010BC  33FC 41D0 00009266       112      MOVE.W #$41D0,$00009266 *LEA (A0), A0 
000010C4  33FC 5E14 00009268       113      MOVE.W #$5E14,$00009268 *ADDQ.B #7, (A4)
000010CC  33FC 6EFE 0000926A       114      MOVE.W #$6EFE,$0000926A *BGT.B FE
000010D4  33FC 6F00 0000926C       115      MOVE.W #$6F00,$0000926C *BLE.W FE7A
000010DC  33FC FE7A 0000926E       116      MOVE.W #$FE7A,$0000926E
000010E4  33FC 6700 00009270       117      MOVE.W #$6700,$00009270 *BEQ.W FE60
000010EC  33FC FE60 00009272       118      MOVE.W #$FE60,$00009272
000010F4  33FC 4EB9 00009274       119      MOVE.W #$4EB9,$00009274 *JSR 00009208
000010FC  23FC 00009208 00009276   120      MOVE.L #$00009208,$000009276
00001106  33FC 48A1 0000927A       121      MOVE.W #$48A1,$0000927A
0000110E  33FC 011F 0000927C       122      MOVE.W #$011F,$0000927C
00001116  33FC 4C91 0000927E       123      MOVE.W #$4C91,$0000927E
0000111E  33FC 0280 00009280       124      MOVE.W #$0280,$00009280
00001126                           125  *---------- END Test ----------*
00001126                           126  
00001126                           127  
00001126                           128  
00001126                           129  *---------- Beginning Messages ----------*
00001126                           130      
00001126  103C 000E                131      move.b      #14,D0
0000112A  43F8 0000                132      lea         StartingMsg,A1 
0000112E  4E4F                     133      trap        #15
00001130                           134      
00001130  103C 000E                135      move.b      #14,D0
00001134  43F8 001F                136      lea         Creators,A1
00001138  4E4F                     137      trap        #15
0000113A                           138      
0000113A  4EB9 0000118C            139      jsr         MENU
00001140                           140      
00001140                           141      
00001140                           142  * ---------- END OF PROGRAM -------------*
00001140                           143  
00001140  103C 000E                144      move.b      #14,D0
00001144  43F8 01EF                145      lea         ExitMsg,A1 
00001148  4E4F                     146      trap        #15
0000114A                           147      
0000114A  103C 0009                148      move.b      #9,D0
0000114E  4E4F                     149      trap        #15
00001150                           150  * ---------------------------------------*
00001150                           151      
00001150                           152  *-- End of Opening and Ending Messages --*
00001150                           153  
00001150                           154  *--------- Start of I/O Section ---------*
00001150                           155  
00001150                           156  Clear_Registers:
00001150  4280                     157      clr.l     D0
00001152  4281                     158      clr.l     D1
00001154  4282                     159      clr.l     D2
00001156  4283                     160      clr.l     D3
00001158  4284                     161      clr.l     D4
0000115A  4285                     162      clr.l     D5
0000115C  4286                     163      clr.l     D6
0000115E  4287                     164      clr.l     D7
00001160                           165      
00001160  207C 00000000            166      movea.l   #0,A0
00001166  227C 00000000            167      movea.l   #0,A1
0000116C  247C 00000000            168      movea.l   #0,A2
00001172  267C 00000000            169      movea.l   #0,A3
00001178  287C 00000000            170      movea.l   #0,A4
0000117E  2A7C 00000000            171      movea.l   #0,A5
00001184  2C7C 00000000            172      movea.l   #0,A6
0000118A  4E75                     173      rts
0000118C                           174  
0000118C                           175  MENU:
0000118C  4EB8 1150                176      jsr         Clear_Registers
00001190  4EB9 000011AA            177      jsr         GetStartAddress
00001196  4EB9 000011C4            178      jsr         GetEndAddress
0000119C  4EB9 000011DE            179      jsr         CheckAddress
000011A2                           180      
000011A2  4EB9 000011E2            181      jsr         MemSearch
000011A8  4E75                     182      rts
000011AA                           183      
000011AA                           184  GetStartAddress:
000011AA                           185      
000011AA  103C 000E                186      move.b      #14, D0         *Display input message
000011AE  43F8 004E                187      lea         InputMsg1,A1
000011B2  4E4F                     188      trap        #15
000011B4                           189      
000011B4  103C 0002                190      move.b      #2,D0
000011B8  4E4F                     191      trap        #15
000011BA                           192          
000011BA  4EB9 00001B94            193      jsr ASCIItoHex              *conversion to Hex
000011C0                           194      * Address Located in D6
000011C0  2846                     195      movea.l     D6,A4           *move into address register 4
000011C2  4E75                     196      rts
000011C4                           197      
000011C4                           198      
000011C4                           199  GetEndAddress:
000011C4  103C 000E                200      move.b      #14,D0          *Display input message
000011C8  43F8 008F                201      lea         InputMsg2,A1
000011CC  4E4F                     202      trap        #15
000011CE                           203      
000011CE  103C 0002                204      move.b      #2,D0
000011D2  4E4F                     205      trap        #15
000011D4                           206      
000011D4  4EB9 00001B94            207      jsr         ASCIItoHex      *conversion to hex
000011DA                           208      * Address Located in D6 (overwrite)
000011DA  2A46                     209      movea.l     D6,A5           *move into address register 5
000011DC  4E75                     210      rts
000011DE                           211      
000011DE                           212  CheckAddress:
000011DE  BBCC                     213      cmp.l       A4,A5
000011E0  67AA                     214      beq         Menu
000011E2                           215  
000011E2                           216      
000011E2                           217  MemSearch:
000011E2  4EB9 000011EA            218      jsr MemSearchLoop
000011E8  4E75                     219      rts
000011EA                           220      
000011EA                           221  MemSearchLoop:
000011EA                           222      
000011EA                           223      * Check if we reached the end address
000011EA  BBCC                     224      cmp.l       A4,A5
000011EC  6700 0030                225      beq         MemSearch_Done
000011F0                           226      
000011F0                           227      * Get data from memory
000011F0  4241                     228      CLR D1
000011F2  3414                     229      move.w     (A4),D2
000011F4  3602                     230      move.w      D2, D3  mutable copy in D3
000011F6                           231      * OPCODE Word Located in D2, mutable copy in D3
000011F6  220C                     232      MOVE.L      A4, D1
000011F8  143C 0010                233      MOVE.B      #16, D2
000011FC  103C 000F                234      MOVE.B      #15, D0     print address of instruction
00001200  4E4F                     235      TRAP        #15
00001202  3403                     236      MOVE.W      D3,D2
00001204  43F8 04B0                237      LEA         space,A1
00001208  4EB9 000013A0            238      JSR         print
0000120E  4EB9 000012AE            239      jsr         OPCODE_DECODE    
00001214                           240      
00001214  544C                     241      adda.w      #2,A4
00001216                           242      
00001216                           243      
00001216                           244         
00001216  4EB9 00001236            245      jsr         FlushScreen_check
0000121C  60CC                     246      bra         MemSearchLoop
0000121E                           247      
0000121E                           248      
0000121E                           249  MemSearch_Done:
0000121E  103C 000E                250      move.b      #14,D0
00001222  43F8 0173                251      lea         EndOfMemLoop,A1 
00001226  4E4F                     252      trap        #15
00001228  4E75                     253      rts
0000122A                           254      
0000122A                           255  TerminateOrCont:
0000122A                           256      * Used to check if user would like to terminate the program or continue to disassemble more data
0000122A  103C 000E                257      move.b      #14,D0
0000122E  43F8 01CC                258      lea         ContinueOrNotMsg,A1 
00001232  4E4F                     259      trap        #15
00001234                           260      
00001234  4E75                     261      rts
00001236                           262  
00001236                           263  FlushScreen_check:
00001236  BC7C 001E                264          cmp.w   #30,D6
0000123A  6700 0004                265          beq     FlushScreen_flush
0000123E  4E75                     266          rts
00001240                           267  
00001240                           268  FlushScreen_flush:
00001240  3C3C 0000                269          move.w  #0,D6
00001244                           270          * -- Show Message --
00001244  43F8 01FF                271          lea     flush_Message,A1
00001248  103C 000E                272          move.b  #14,D0
0000124C  4E4F                     273          trap    #15
0000124E                           274          * -- Read character from keyboard --
0000124E  103C 0005                275          move.b  #5,D0
00001252  4E4F                     276          trap    #15
00001254                           277          
00001254  4EB9 00001266            278          jsr     FlushScreen_processReply
0000125A                           279          
0000125A                           280          * -- Flush the screen --
0000125A  4EB9 00001290            281          jsr     FlushScreen_clearscreen
00001260  3C3C 0000                282          move.w  #0,D6
00001264  4E75                     283          rts
00001266                           284  FlushScreen_processReply:
00001266  B23C 000D                285          cmp.b   #CR,D1
0000126A  6700 0022                286          beq     FlushScreen_processReplyGood
0000126E  103C 0006                287          move.b  #6,D0
00001272  123C 000D                288          move.b  #CR,D1
00001276  4E4F                     289          trap    #15
00001278  123C 000A                290          move.b  #LF,D1
0000127C  4E4F                     291          trap    #15
0000127E  123C 000D                292          move.b  #CR,D1
00001282  4E4F                     293          trap    #15
00001284  123C 000A                294          move.b  #LF,D1
00001288  4E4F                     295          trap    #15
0000128A  4EB8 1240                296          jsr     FlushScreen_flush
0000128E                           297  FlushScreen_processReplyGood:
0000128E  4E75                     298          rts
00001290                           299  FlushScreen_clearscreen:
00001290  123C 000D                300          move.b  #CR,D1
00001294  103C 0006                301          move.b  #6,D0
00001298  4E4F                     302          trap    #15
0000129A  123C 000A                303          move.b  #LF,D1
0000129E  4E4F                     304          trap    #15
000012A0  BC7C 0028                305          cmp.w   #40,D6
000012A4  6700 0006                306          beq     FlushScreen_toFlush
000012A8  5246                     307          add.w   #1,D6
000012AA  60E4                     308          bra     FlushScreen_clearscreen
000012AC                           309  
000012AC                           310  FlushScreen_toFlush:
000012AC  4E75                     311          rts
000012AE                           312  
000012AE                           313  * -------- Start of Opcode Section -------*    
000012AE                           314  
000012AE                           315  OPCODE_DECODE:
000012AE                           316      * Begin OPCODE Decoding here
000012AE                           317      * Check first four bits and begin
000012AE                           318      * if-branch breakdown
000012AE  4284                     319      CLR.L D4
000012B0  4285                     320      CLR.L D5
000012B2  4286                     321      CLR.L D6
000012B4  4287                     322      CLR.L D7
000012B6                           323      
000012B6  B47C 4E71                324      CMP.W #$4E71, D2        
000012BA  6700 0100                325      BEQ print_nop           *check if value is NOP
000012BE                           326      
000012BE  B47C 4E75                327      CMP.W #$4E75, D2        
000012C2  6700 0102                328      BEQ print_rts           *check if value is RTS
000012C6                           329      
000012C6                           330      * Mask out only the first 4 bits
000012C6  C67C F000                331      AND.W #$F000,D3
000012CA                           332      
000012CA  B67C 9000                333      CMP.W #$9000,D3
000012CE  6700 01EE                334      BEQ print_sub_and_or    *check if value is SUB
000012D2                           335      
000012D2  B67C 6000                336      CMP.W #$6000,D3
000012D6  6700 0396                337      BEQ print_bra_bcc       *check if value is BRA, BEQ, BGT, or BLE
000012DA                           338      
000012DA  B67C 8000                339      CMP.W #$8000, D3
000012DE  6700 01DE                340      BEQ print_sub_and_or    *check if value is OR
000012E2                           341  
000012E2  B67C C000                342      CMP.W #$C000,D3
000012E6  6700 01D6                343      BEQ print_sub_and_or    *check if value is AND
000012EA                           344      
000012EA  B67C D000                345      CMP.W #$D000,D3
000012EE  6700 012A                346      BEQ print_add_adda      *check if value is ADD or ADDA
000012F2                           347      
000012F2  B67C E000                348      CMP.W #$E000,D3
000012F6  6700 0238                349      BEQ print_ls_as_ro      *check if value is LSL, LSR, ASL, ASR, ROL, or ROR
000012FA                           350      
000012FA  B67C 7000                351      CMP.W #$7000,D3
000012FE  6700 0064                352      BEQ print_moveq     *check if value is MOVEQ
00001302                           353      
00001302  B47C 1000                354      CMP.W #$1000,D2
00001306  6D00 003E                355      BLT invalid
0000130A  B47C 4000                356      CMP.W #$4000,D2
0000130E  6D00 00C0                357      BLT print_move_movea    *check if value is MOVE or MOVEA
00001312                           358      
00001312                           359      * Mask out only the first 8 bits
00001312  3602                     360      MOVE.W D2, D3
00001314  C67C FF00                361      AND.W #$FF00,D3
00001318                           362      
00001318  B67C 4600                363      CMP.W #$4600,D3
0000131C  6700 02B2                364      BEQ print_not           *check if value is NOT
00001320                           365      
00001320  B67C 4E00                366      CMP.W #$4E00,D3
00001324  6700 02D4                367      BEQ print_jsr           *check if value is JSR
00001328                           368      
00001328                           369      * Mask out only the first 4 bits and the 8th bit
00001328  3602                     370      MOVE.W D2,D3
0000132A  C67C F100                371      AND.W #$F100, D3
0000132E                           372      
0000132E  B67C 4000                373      CMP.W #$4000, D3
00001332  6700 03EC                374      BEQ print_movem         *check if value is MOVEM
00001336                           375      
00001336  B67C 4100                376      CMP.W #$4100, D3
0000133A  6700 02D4                377      BEQ print_lea           *check if value is LEA
0000133E                           378      
0000133E  B67C 5000                379      CMP.W #$5000,D3
00001342  6700 02F0                380      BEQ print_addq          *check if value is ANDQ     
00001346                           381      
00001346                           382      
00001346                           383  invalid 
00001346  43F8 04BE                384      LEA data, A1
0000134A  4EB9 000013A0            385      JSR print
00001350  2202                     386      MOVE.L D2, D1
00001352  143C 0010                387      MOVE.B #16, D2
00001356  103C 000F                388      MOVE.B  #15, D0     
0000135A  4E4F                     389      TRAP #15
0000135C  4EB9 000013B2            390      JSR enter
00001362  4E75                     391  out rts
00001364                           392  
00001364                           393      
00001364                           394  * -------- End of Opcode Section --------*   
00001364                           395  
00001364                           396  * --------- Print Instructions ----------*
00001364                           397  
00001364                           398  print_moveq
00001364  43F8 0444                399      lea moveq_ins, A1   *print MOVEQ
00001368  4EB9 000013A0            400      jsr print
0000136E  3602                     401      move.w  D2,D3
00001370  C67C 00FF                402      and.w   #$00FF,D3   * Figure out the immediate address value
00001374  43F8 04B5                403      lea pound,A1        *print '#'
00001378  4EB9 000013A0            404      jsr print
0000137E  103C 0003                405      move.b  #3,D0
00001382  3203                     406      move.w  D3,D1
00001384  4E4F                     407      trap    #15         *print immediate address value
00001386  43F8 04B2                408      lea comma,A1        *print comma
0000138A  4EB9 000013A0            409      jsr print
00001390  3A02                     410      MOVE.W D2, D5
00001392  4EB9 000019C2            411      JSR data_reg_sr     *figure out data address
00001398  4EB9 000013B2            412      jsr enter           *print out enter
0000139E  60C2                     413      bra out
000013A0                           414  
000013A0                           415  print:
000013A0  4240                     416      CLR D0 
000013A2  103C 000E                417      MOVE.B #14,D0
000013A6  4E4F                     418      TRAP #15
000013A8  4E75                     419      RTS
000013AA                           420  
000013AA                           421  println:
000013AA  103C 000D                422      MOVE.B #13, D0
000013AE  4E4F                     423      TRAP #15
000013B0  4E75                     424      RTS
000013B2                           425      
000013B2                           426  enter: 
000013B2  43F8 04BB                427      LEA return, A1
000013B6  4EB8 13A0                428      JSR print
000013BA  4E75                     429      RTS
000013BC                           430      
000013BC                           431  print_nop
000013BC  43F8 0437                432      LEA nop_ins, A1
000013C0  4EB8 13AA                433      JSR println
000013C4  609C                     434      BRA out
000013C6                           435  
000013C6                           436  print_rts
000013C6  43F8 043B                437      LEA rts_ins, A1
000013CA  4EB8 13AA                438      JSR println
000013CE  6092                     439      BRA out
000013D0                           440  
000013D0                           441  print_move_movea
000013D0  3602                     442      MOVE.W D2, D3       
000013D2  C67C 01C0                443      AND.W #$01C0, D3
000013D6  B67C 0040                444      CMP.W #$0040, D3    *determine if MOVE or MOVEA
000013DA  6700 000E                445      BEQ move_a
000013DE  43F8 043F                446      LEA move_ins, A1 *print Instruction 
000013E2  4EB8 13A0                447      JSR print
000013E6  6000 000A                448      BRA m_size
000013EA                           449  move_a          *if instruction is MOVEA
000013EA  43F8 0451                450      LEA movea_ins, A1
000013EE  4EB8 13A0                451      JSR print
000013F2                           452  m_size              *determine instruction size
000013F2  4EB9 000017E0            453      JSR move_size
000013F8  4EB9 00001842            454      JSR addr        *determine the source address
000013FE  43F8 04B2                455      LEA comma, A1   *print comma
00001402  4EB8 13A0                456      JSR print
00001406  4207                     457      CLR.B D7
00001408  1E3C 0001                458      MOVE.B #1, D7   *determine destination address
0000140C  4EB9 00001842            459      JSR addr
00001412  4EB8 13B2                460      JSR enter       *print enter
00001416  6000 FF4A                461      BRA out
0000141A                           462      
0000141A                           463  print_add_adda
0000141A  3602                     464      MOVE.W D2, D3   
0000141C  C63C 00C0                465      AND.B #$C0, D3
00001420  B63C 00C0                466      CMP.B #$C0, D3      *determine if ADD or ADDA
00001424  6700 0052                467      BEQ add_a
00001428                           468      *if just ADD then print instruction
00001428  43F8 0457                469      LEA add_ins, A1
0000142C  4EB8 13A0                470      JSR print
00001430                           471      *print instruction size for ADD
00001430  4EB9 00001826            472      JSR size
00001436                           473      *determine direction of ADD, Dn -> EA or EA -> Dn
00001436  3602                     474      MOVE.W D2,D3
00001438  C67C 0100                475      AND.W #$0100, D3
0000143C  B67C 0100                476      CMP.W #$0100, D3
00001440  6700 001C                477      BEQ ea_dest_add 
00001444  4EB9 00001842            478      JSR addr            *if Direction bit is 0
0000144A  43F8 04B2                479      LEA comma, A1
0000144E  4EB8 13A0                480      JSR print
00001452  3A02                     481      MOVE.W D2,D5
00001454  4EB9 000019C2            482      JSR data_reg_sr
0000145A  6000 005A                483      BRA end_add
0000145E                           484  ea_dest_add             *if Direction bit is 1
0000145E  3A02                     485      MOVE.W D2,D5
00001460  4EB9 000019C2            486      JSR data_reg_sr
00001466  43F8 04B2                487      LEA comma, A1
0000146A  4EB8 13A0                488      JSR print
0000146E  4EB9 00001842            489      JSR addr
00001474  6000 0040                490      BRA end_add
00001478                           491  add_a                   *if instruction is ADDA
00001478  43F8 045B                492      LEA adda_ins, A1
0000147C  4EB8 13A0                493      JSR print
00001480                           494      *print instruction size for ADDA (either W or L)
00001480  3602                     495      MOVE.W D2,D3
00001482  C67C 0100                496      AND.W #$0100, D3
00001486  B67C 0100                497      CMP.W #$0100, D3
0000148A  6700 000E                498      BEQ adda_size
0000148E  43F8 042F                499      LEA word, A1
00001492  4EB8 13A0                500      JSR print
00001496  6000 000A                501      BRA next_add
0000149A                           502  adda_size
0000149A  43F8 042B                503      LEA long,A1
0000149E  4EB8 13A0                504      JSR print
000014A2                           505  next_add                *print effective address for ADDA
000014A2  4EB9 00001842            506      JSR addr            
000014A8  43F8 04B2                507      LEA comma, A1
000014AC  4EB8 13A0                508      JSR print
000014B0  4EB9 000019DA            509      JSR add_reg_sr
000014B6                           510  end_add                 *complete instruction printing by printing enter
000014B6  4EB8 13B2                511      JSR enter
000014BA  6000 FEA6                512      BRA out
000014BE                           513  
000014BE                           514  print_sub_and_or
000014BE                           515      *determine if instruction is SUB, AND, or OR.
000014BE  B67C 8000                516      CMP.W #$8000, D3
000014C2  6700 001A                517      BEQ print_or
000014C6  B67C 9000                518      CMP.W #$9000, D3
000014CA  6700 000A                519      BEQ print_sub
000014CE  43F8 0468                520      LEA and_ins, A1
000014D2  6000 000E                521      BRA print_instruction
000014D6                           522  print_sub
000014D6  43F8 046C                523      LEA sub_ins, A1
000014DA  6000 0006                524      BRA print_instruction
000014DE                           525  print_or
000014DE  43F8 0465                526      LEA or_ins, A1
000014E2                           527  print_instruction       *print correct instruction
000014E2  4EB8 13A0                528      JSR print
000014E6  4EB9 00001826            529      JSR size            *print instruction size
000014EC  3602                     530      MOVE.W D2,D3
000014EE                           531  *determine direction of ADD, Dn -> EA or EA -> Dn   
000014EE  C67C 0100                532      AND.W #$0100, D3
000014F2  B67C 0100                533      CMP.W #$0100, D3
000014F6  6700 001A                534      BEQ ea_dest_sub_and_or
000014FA  4EB9 00001842            535      JSR addr            *if Direction bit is 0
00001500  43F8 04B2                536      LEA comma, A1
00001504  4EB8 13A0                537      JSR print
00001508  3A02                     538      MOVE.W D2,D5
0000150A  4EB9 000019C2            539      JSR data_reg_sr
00001510  60A4                     540      BRA end_add
00001512                           541  ea_dest_sub_and_or      *if Direction bit is 1
00001512  3A02                     542      MOVE.W D2,D5
00001514  4EB9 000019C2            543      JSR data_reg_sr
0000151A  43F8 04B2                544      LEA comma, A1
0000151E  4EB8 13A0                545      JSR print
00001522  4EB9 00001842            546      JSR addr
00001528                           547      *complete instruction printing by printing enter
00001528  4EB8 13B2                548      JSR enter
0000152C  6000 FE34                549      BRA out
00001530                           550  
00001530                           551  print_ls_as_ro
00001530                           552      *figure out if shift or rotation are memory or register based               
00001530  3602                     553      MOVE.W D2, D3
00001532  C63C 00C0                554      AND.B #$C0, D3
00001536  B63C 00C0                555      CMP.B #$C0, D3
0000153A  6700 005E                556      BEQ ls_as_ro_mem
0000153E  3602                     557      MOVE.W D2, D3
00001540  E60B                     558      LSR.B #3, D3
00001542                           559      *print correct instruction type (logical shift, arithmetic shift, or rotation)
00001542  4EB9 000017AE            560      JSR print_correct_shift_rotation
00001548  4EB9 0000178C            561      JSR print_direction     *print direction
0000154E  4EB9 00001826            562      JSR size                *print size
00001554  3602                     563      MOVE.W D2, D3
00001556  C63C 0020                564      AND.B #$20,D3
0000155A  B63C 0020                565      CMP.B #$20, D3
0000155E                           566      *determine if instruction is using immediate address or register
0000155E  6700 001C                567      BEQ ls_as_ro_reg     
00001562  43F8 04B5                568      LEA pound, A1        *if immediate address print '#'
00001566  4EB8 13A0                569      JSR print
0000156A                           570      *print immediate address rotation value
0000156A  3C02                     571      MOVE.W D2,D6
0000156C  EF5E                     572      ROL.W #7,D6
0000156E  CC7C 0007                573      AND.W #$0007, D6
00001572  4EB9 000019B6            574      JSR Xn
00001578  6000 000A                575      BRA continue_instruction_ls_as_ro
0000157C                           576  ls_as_ro_reg            *if instruction is using register to shift values in another register
0000157C  3A02                     577      MOVE.W D2,D5
0000157E  4EB9 000019C2            578      JSR data_reg_sr
00001584                           579  continue_instruction_ls_as_ro *complete instrcuction
00001584  43F8 04B2                580      LEA comma, A1       *print comma
00001588  4EB8 13A0                581      JSR print
0000158C  3A02                     582      MOVE.W D2,D5
0000158E  EE5D                     583      ROR.W #7,D5         *rotate instruction to allow for subroutine reuse
00001590  4EB9 000019C2            584      JSR data_reg_sr     *determine destination data register to perform instruction on
00001596  6000 0030                585      BRA next_ls_as_ro   *finish printing instruction
0000159A                           586  ls_as_ro_mem            *check if immediate address is being shifted or rotated
0000159A  3602                     587      MOVE.W D2, D3
0000159C  C63C 003F                588      AND.B #$3F, D3
000015A0  B63C 003C                589      CMP.B #$3C, D3
000015A4  6700 FDA0                590      BEQ invalid     *ROL #4 <- not allowed (immediate addressing)
000015A8                           591      *if not immediate adress print normally 
000015A8  3602                     592      MOVE.W D2, D3
000015AA  EF5B                     593      ROL.W #7, D3    
000015AC  4EB9 000017AE            594      JSR print_correct_shift_rotation
000015B2  3602                     595      MOVE.W D2,D3
000015B4  4EB9 0000178C            596      JSR print_direction
000015BA  43F8 04B0                597      LEA space, A1
000015BE  4EB8 13A0                598      JSR print
000015C2  4EB9 00001842            599      JSR addr
000015C8                           600  next_ls_as_ro
000015C8  4EB8 13B2                601      JSR enter
000015CC  6000 FD94                602      BRA out
000015D0                           603      
000015D0                           604  print_not
000015D0  43F8 0479                605      LEA not_ins, A1 *print instruction
000015D4  4EB8 13A0                606      JSR print
000015D8  4EB9 00001826            607      JSR size
000015DE  3602                     608      MOVE.W D2, D3
000015E0  C63C 003F                609      AND.B #$3F, D3
000015E4  B63C 003C                610      CMP.B #$3C, D3
000015E8  6700 FD5C                611      BEQ invalid     *NOT #4 <- not allowed (immediate addressing)
000015EC  4EB9 00001842            612      JSR addr
000015F2  4EB8 13B2                613      JSR enter
000015F6  6000 FD6A                614      BRA out
000015FA                           615  
000015FA                           616  print_jsr
000015FA  43F8 047D                617      LEA jsr_ins, A1 *print instruction
000015FE  4EB8 13A0                618      JSR print
00001602  4EB9 00001842            619      JSR addr    *print address
00001608  4EB8 13B2                620      JSR enter   *print enter (next line)
0000160C  6000 FD54                621      BRA out
00001610                           622  
00001610                           623  print_lea
00001610  43F8 0482                624      LEA lea_ins, A1 *print instruction
00001614  4EB8 13A0                625      JSR print   
00001618  4EB9 00001842            626      JSR addr    *print address
0000161E  43F8 04B2                627      LEA comma, A1   *print comma
00001622  4EB8 13A0                628      JSR print
00001626  4EB9 000019DA            629      JSR add_reg_sr *print destination address register
0000162C  4EB8 13B2                630      JSR enter
00001630  6000 FD30                631      BRA out
00001634                           632  
00001634                           633  print_addq
00001634  43F8 0460                634      LEA addq_ins, A1    *print instruction
00001638  4EB8 13A0                635      JSR print
0000163C  4EB9 00001826            636      JSR size            *print instruction size
00001642  43F8 04B5                637      LEA pound, A1
00001646  4EB8 13A0                638      JSR print           *print '#' for immediate addressing
0000164A  3C02                     639      MOVE.W D2,D6
0000164C  EF5E                     640      ROL.W #7,D6         *appropriately rotate opcode to allow for sub-routine reuse
0000164E  CC7C 0007                641      AND.W #$0007, D6
00001652  4EB9 000019B6            642      JSR Xn
00001658  43F8 04B2                643      LEA comma, A1       *print comma
0000165C  4EB8 13A0                644      JSR print
00001660  4EB9 00001842            645      JSR addr            *print destination address
00001666  4EB8 13B2                646      JSR enter
0000166A  6000 FCF6                647      BRA out
0000166E                           648  
0000166E                           649  print_bra_bcc           *needs comments
0000166E  3602                     650      MOVE.W D2,D3
00001670  C67C 0F00                651      AND.W #$0F00, D3
00001674  B67C 0000                652      CMP.W #$0000, D3
00001678  6700 001E                653      BEQ print_bra
0000167C  B67C 0700                654      CMP.W #$0700, D3
00001680  6700 0022                655      BEQ print_beq
00001684  B67C 0E00                656      CMP.W #$0E00, D3
00001688  6700 0032                657      BEQ print_bgt
0000168C  B67C 0F00                658      CMP.W #$0F00, D3
00001690  6700 001E                659      BEQ print_ble
00001694  6000 FCB0                660      BRA invalid
00001698                           661  print_bra
00001698  43F8 0498                662      LEA bra_ins, A1
0000169C  4EB8 13A0                663      JSR print
000016A0  6000 0022                664      BRA next_bra_bcc
000016A4                           665  print_beq
000016A4  43F8 0494                666      LEA beq_ins, A1
000016A8  4EB8 13A0                667      JSR print
000016AC  6000 0016                668      BRA next_bra_bcc
000016B0                           669  print_ble
000016B0  43F8 0490                670      LEA ble_ins, A1
000016B4  4EB8 13A0                671      JSR print
000016B8  6000 000A                672      BRA next_bra_bcc
000016BC                           673  print_bgt
000016BC  43F8 048C                674      LEA bgt_ins, A1
000016C0  4EB8 13A0                675      JSR print
000016C4                           676  next_bra_bcc
000016C4  3602                     677      MOVE.W D2, D3
000016C6  C67C 00FF                678      AND.W #$00FF, D3
000016CA  B67C 0000                679      CMP.W #$0000, D3
000016CE  6700 0026                680      BEQ check_word
000016D2  43F8 0433                681      LEA byte, A1
000016D6  4EB8 13A0                682      JSR print
000016DA  43F8 04C5                683      LEA dollar, A1
000016DE  4EB8 13A0                684      JSR print
000016E2  3203                     685      MOVE.W D3, D1
000016E4  3602                     686      MOVE.W D2, D3
000016E6  343C 0010                687      MOVE.W #16, D2
000016EA  303C 000F                688      MOVE.W #15,D0
000016EE  4E4F                     689      trap #15            *print immediate address value
000016F0  3403                     690      MOVE.W D3, D2
000016F2  6000 0024                691      BRA end_bra_bcc
000016F6                           692  check_word
000016F6  43F8 042F                693      LEA word, A1
000016FA  4EB8 13A0                694      JSR print
000016FE  43F8 04C5                695      LEA dollar, A1
00001702  4EB8 13A0                696      JSR print
00001706  544C                     697      ADDA.W #2,A4        *update current address
00001708  3214                     698      MOVE.W (A4),D1      *retrieve word data stored in the new current address
0000170A  3602                     699      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000170C  343C 0010                700      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
00001710  103C 000F                701      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001714  4E4F                     702      TRAP #15
00001716  3403                     703      MOVE.W D3,D2        *copy opcode back to register D2
00001718                           704  end_bra_bcc
00001718  4EB8 13B2                705      JSR enter
0000171C  6000 FC44                706      BRA out
00001720                           707  
00001720                           708  print_movem         *needs comments
00001720  43F8 044B                709      LEA movem_ins, A1
00001724  4EB8 13A0                710      JSR print
00001728  3602                     711      MOVE.W D2,D3
0000172A  C67C 0040                712      AND.W #$0040,D3
0000172E  B67C 0040                713      CMP.W #$0040,D3
00001732  6700 000E                714      BEQ movem_long
00001736  43F8 042F                715      LEA word, A1
0000173A  4EB8 13A0                716      JSR print
0000173E  6000 000A                717      BRA movem_direction
00001742                           718  movem_long
00001742  43F8 042B                719      LEA long, A1
00001746  4EB8 13A0                720      JSR print
0000174A                           721  movem_direction
0000174A  3602                     722      MOVE.W D2,D3
0000174C  C67C 0400                723      AND.W #$0400,D3
00001750  B67C 0400                724      CMP.W #$0400,D3
00001754  6700 001A                725      BEQ mem_to_reg
00001758  4EB9 000019F2            726      JSR movem_predec
0000175E  43F8 04B2                727      LEA comma, A1
00001762  4EB8 13A0                728      JSR print
00001766  4EB9 00001842            729      JSR addr
0000176C  6000 0016                730      BRA end_movem
00001770                           731  mem_to_reg
00001770  4EB9 00001842            732      JSR addr
00001776  43F8 04B2                733      LEA comma, A1
0000177A  4EB8 13A0                734      JSR print
0000177E  4EB9 00001AC4            735      JSR movem_postinc
00001784                           736  end_movem
00001784  4EB8 13B2                737      JSR enter
00001788  6000 FBD8                738      BRA out
0000178C                           739  
0000178C                           740  print_direction:
0000178C                           741  *print correct direction given direction bit
0000178C  C67C 0100                742      AND.W #$0100, D3
00001790  B67C 0100                743      CMP.W #$0100, D3
00001794  6700 000E                744      BEQ print_left  *print left
00001798  43F8 049C                745      LEA right, A1
0000179C  4EB8 13A0                746      JSR print
000017A0  6000 FBC0                747      BRA out
000017A4                           748  print_left
000017A4  43F8 049E                749      LEA left, A1
000017A8  4EB8 13A0                750      JSR print *print right
000017AC  4E75                     751      RTS
000017AE                           752      
000017AE                           753  print_correct_shift_rotation:
000017AE                           754  *determine if instruction is logical, arithmetic, or rotation 
000017AE  C63C 0003                755      AND.B #$03, D3
000017B2  B63C 0000                756      CMP.B #$00, D3
000017B6  6700 0016                757      BEQ print_as
000017BA  B63C 0001                758      CMP.B #$01, D3
000017BE  6700 0016                759      BEQ print_ls
000017C2  B63C 0003                760      CMP.B #$03, D3
000017C6  43F8 0476                761      LEA ro_ins, A1  print rotation
000017CA  6000 000E                762      BRA print_it
000017CE                           763  print_as
000017CE  43F8 0473                764      LEA as_ins, A1  print arithmetic shift
000017D2  6000 0006                765      BRA print_it
000017D6                           766  print_ls
000017D6  43F8 0470                767      LEA ls_ins, A1 print logical shift
000017DA                           768  print_it
000017DA  4EB8 13A0                769      JSR print
000017DE  4E75                     770      RTS
000017E0                           771  * --------- End Print Instruction ----------*
000017E0                           772  
000017E0                           773  * ------- Instruction sizes ---------*
000017E0                           774  
000017E0                           775  move_size:  *print size for MOVE and MOVEA instruction
000017E0  4284                     776      CLR.L D4
000017E2  3802                     777      MOVE.W D2, D4
000017E4  C87C 3000                778      AND.W #$3000, D4
000017E8  B87C 1000                779      CMP.W #$1000, D4
000017EC  6700 0014                780      BEQ print_b
000017F0  B87C 3000                781      CMP.W #$3000, D4
000017F4  6700 0018                782      BEQ print_w
000017F8  B87C 2000                783      CMP.W #$2000, D4
000017FC  6700 001C                784      BEQ print_l
00001800  4E75                     785      RTS
00001802                           786      
00001802                           787  print_b     *print '.B'
00001802  43F8 0433                788      LEA byte, A1
00001806  4EB8 13A0                789      JSR print
0000180A  6000 FB56                790      BRA out
0000180E                           791      
0000180E                           792  print_w     *print '.W'
0000180E  43F8 042F                793      LEA word, A1
00001812  4EB8 13A0                794      JSR print
00001816  6000 FB4A                795      BRA out
0000181A                           796      
0000181A                           797  print_l:    *print '.L'
0000181A  43F8 042B                798      LEA long, A1
0000181E  4EB8 13A0                799      JSR print
00001822  6000 FB3E                800      BRA out
00001826                           801  
00001826                           802  size:       *print size for non "move" instructions
00001826  4284                     803      CLR.L D4
00001828  1802                     804      MOVE.B D2,D4
0000182A  C83C 00C0                805      AND.B #$C0, D4
0000182E  B83C 0000                806      CMP.B #$00, D4
00001832  67CE                     807      BEQ print_b
00001834  B83C 0040                808      CMP.B #$40,D4
00001838  67D4                     809      BEQ print_w
0000183A  B83C 0080                810      CMP.B #$80, D4
0000183E  67DA                     811      BEQ print_l
00001840  4E75                     812      RTS
00001842                           813      
00001842                           814  * ------- End Instruction sizes ---------*
00001842                           815  
00001842                           816  * ------- Effective Address -------*
00001842                           817  addr:           *use if dealing with Mode, Xn (source) or Xn, Mode (destination, set D7 to 1)
00001842  3A02                     818      MOVE.W D2, D5
00001844  3C02                     819      MOVE.W D2, D6               
00001846  BE3C 0001                820      CMP.B #1, D7
0000184A  6700 003A                821      BEQ destination *check if evaluating destination address (used for MOVE)
0000184E                           822  cont
0000184E  CC3C 0038                823      AND.B #$38, D6
00001852  BC3C 0000                824      CMP.B #0, D6
00001856  6700 0038                825      BEQ data_reg        *check if EA mode is data register
0000185A  BC3C 0008                826      CMP.B #$08, D6
0000185E  6700 0048                827      BEQ add_reg         *check if EA mode is address register
00001862  BC3C 0010                828      CMP.B #$10, D6
00001866  6700 0058                829      BEQ add_indirect    *check if EA mode is address indirect
0000186A  BC3C 0018                830      CMP.B #$18, D6
0000186E  6700 0070                831      BEQ post_increment  *check if EA mode is post increment
00001872  BC3C 0020                832      CMP.B #$20, D6
00001876  6700 0088                833      BEQ pre_decrement   *check if EA mode is pre_decrement
0000187A  BC3C 0038                834      CMP.B #$38, D6
0000187E  6700 00A0                835      BEQ absolute_or_immediate
00001882  6000 FADE                836      BRA out *needs Immediate, Abs Long, and Abs Word
00001886                           837  destination     *perform correct rotation to retrieve destination address
00001886  3C05                     838      MOVE.W D5,D6
00001888  EF5D                     839      ROL.W #7,D5
0000188A  E64E                     840      LSR.W #3,D6
0000188C  60C0                     841      BRA cont
0000188E  4E75                     842      RTS
00001890                           843  
00001890                           844  data_reg    *used with addr sub routine
00001890  3C05                     845      MOVE.W D5,D6    
00001892  CC3C 0007                846      AND.B #$07, D6  
00001896  43F8 04A0                847      LEA D_reg, A1   
0000189A  4EB8 13A0                848      JSR print
0000189E  4EB9 000019B6            849      JSR Xn
000018A4  6000 FABC                850      BRA out
000018A8                           851  
000018A8                           852  add_reg     *used with addr sub routine
000018A8  3C05                     853      MOVE.W D5,D6    
000018AA  CC3C 0007                854      AND.B #$07, D6
000018AE  43F8 04A2                855      LEA A_reg, A1   
000018B2  4EB8 13A0                856      JSR print
000018B6  4EB9 000019B6            857      JSR Xn
000018BC  6000 FAA4                858      BRA out
000018C0                           859      
000018C0                           860  add_indirect    *used with addr sub routine
000018C0  3C05                     861      MOVE.W D5,D6    
000018C2  CC3C 0007                862      AND.B #$07, D6
000018C6  43F8 04A4                863      LEA open_paran, A1  
000018CA  4EB8 13A0                864      JSR print
000018CE  4EB9 000019B6            865      JSR Xn
000018D4  43F8 04A7                866      LEA close_paran, A1 
000018D8  4EB8 13A0                867      JSR print
000018DC  6000 FA84                868      BRA out
000018E0                           869      
000018E0                           870  post_increment  *used with addr sub routine
000018E0  3C05                     871      MOVE.W D5,D6    
000018E2  CC3C 0007                872      AND.B #$07, D6
000018E6  43F8 04A4                873      LEA open_paran, A1  
000018EA  4EB8 13A0                874      JSR print
000018EE  4EB9 000019B6            875      JSR Xn
000018F4  43F8 04A9                876      LEA post_inc, A1    
000018F8  4EB8 13A0                877      JSR print
000018FC  6000 FA64                878      BRA out
00001900                           879      
00001900                           880  pre_decrement   *used with addr sub routine
00001900  3C05                     881      MOVE.W D5,D6    
00001902  CC3C 0007                882      AND.B #$07, D6
00001906  43F8 04AC                883      LEA pre_dec, A1 
0000190A  4EB8 13A0                884      JSR print
0000190E  4EB9 000019B6            885      JSR Xn
00001914  43F8 04A7                886      LEA close_paran, A1 
00001918  4EB8 13A0                887      JSR print
0000191C  6000 FA44                888      BRA out
00001920                           889  
00001920                           890  absolute_or_immediate *check if EA is immediate or absolute address
00001920  3C05                     891      MOVE.W D5,D6    
00001922  CC3C 0007                892      AND.B #$07, D6
00001926  BC3C 0000                893      CMP.B #$00, D6
0000192A  6700 0050                894      BEQ w_imm
0000192E  BC3C 0001                895      CMP.B #$01, D6
00001932  6700 0064                896      BEQ l_imm
00001936  BC3C 0004                897      CMP.B #04, D6
0000193A  6700 0002                898      BEQ immediate
0000193E                           899      
0000193E                           900  immediate
0000193E  43F8 04B5                901      LEA pound, A1
00001942  4EB8 13A0                902      JSR print
00001946  B4BC 00004000            903      CMP.L #$4000, D2    *using CMP.L to avoid sign extention for value in D2 caused previously by CMP.W
0000194C  6D00 0012                904      BLT move_movea      *check if instruction is move or movea
00001950  B83C 0040                905      CMP.B #$40, D4      *if not move or movea
00001954  6D00 0026                906      BLT w_imm           *byte and word check the next 2 addresses in mem
00001958  B83C 0080                907      CMP.B #$80, D4
0000195C  6700 003A                908      BEQ l_imm           *long checks the next 4 addresses in mem
00001960                           909  move_movea              *similar comparisons, but for different bits in OPCODE
00001960  B87C 1000                910      CMP.W #$1000, D4
00001964  6700 0016                911      BEQ w_imm
00001968  B87C 3000                912      CMP.W #$3000, D4
0000196C  6700 000E                913      BEQ w_imm
00001970  B87C 2000                914      CMP.W #$2000, D4
00001974  6700 0022                915      BEQ l_imm
00001978                           916  imm_complete
00001978  6000 F9E8                917      BRA out
0000197C                           918      
0000197C                           919  w_imm
0000197C  43F8 04C5                920      LEA dollar, A1      *print '$'
00001980  4EB8 13A0                921      JSR print
00001984  544C                     922      ADDA.W #2,A4        *update current address
00001986  3214                     923      MOVE.W (A4),D1      *retrieve word data stored in the new current address
00001988  3602                     924      MOVE.W D2, D3       *temporarily copy OPCODE to register D3
0000198A  343C 0010                925      MOVE.W #16, D2      *store #16 to allow for use of base 16 output
0000198E  103C 000F                926      MOVE.B #15, D0      *use trap instruction that allows use of base 16
00001992  4E4F                     927      TRAP #15
00001994  3403                     928      MOVE.W D3,D2        *copy opcode back to register D2
00001996  60E0                     929      BRA imm_complete    *exit addr subroutine
00001998                           930      
00001998                           931  l_imm
00001998  43F8 04C5                932      LEA dollar, A1      *print '$'
0000199C  4EB8 13A0                933      JSR print
000019A0  544C                     934      ADDA.W  #2,A4       *update current address
000019A2  2214                     935      MOVE.L (A4),D1      *retrieve long data stored in the new current address
000019A4  3602                     936      MOVE.W D2, D3
000019A6  343C 0010                937      MOVE.W #16, D2
000019AA  103C 000F                938      MOVE.B #15, D0
000019AE  4E4F                     939      TRAP #15
000019B0  3403                     940      MOVE.W D3,D2
000019B2  544C                     941      ADD.W  #2,A4        *update current address again since 2 more address were occupied by long data
000019B4  60C2                     942      BRA imm_complete    *exit addr subroutine
000019B6                           943  
000019B6                           944  Xn:                     *retieve signed decimal value of data stored in register D6
000019B6  4281                     945      CLR.L D1
000019B8  1206                     946      MOVE.B D6,D1
000019BA  103C 0003                947      MOVE.B #3, D0
000019BE  4E4F                     948      TRAP #15
000019C0  4E75                     949      RTS
000019C2                           950  
000019C2                           951  data_reg_sr:    *use if dealing with Dn only
000019C2  4286                     952      CLR.L D6
000019C4  3C05                     953      MOVE.W D5,D6
000019C6  EF5E                     954      ROL.W #7,D6
000019C8  CC3C 0007                955      AND.B #$07, D6  
000019CC  43F8 04A0                956      LEA D_reg, A1   
000019D0  4EB8 13A0                957      JSR print
000019D4  4EB8 19B6                958      JSR Xn
000019D8  4E75                     959      RTS
000019DA                           960      
000019DA                           961  add_reg_sr:     *use if dealing with An only
000019DA  4286                     962      CLR.L D6
000019DC  3C02                     963      MOVE.W D2,D6
000019DE  EF5E                     964      ROL.W #7,D6
000019E0  CC3C 0007                965      AND.B #$07, D6  
000019E4  43F8 04A2                966      LEA A_reg, A1   
000019E8  4EB8 13A0                967      JSR print
000019EC  4EB8 19B6                968      JSR Xn
000019F0  4E75                     969      RTS
000019F2                           970      
000019F2                           971  movem_predec:           *needs to be worked on
000019F2  4285                     972      CLR.L D5
000019F4  544C                     973      ADDA.W  #2,A4       *update current address
000019F6  3A14                     974      MOVE.W (A4),D5      *retrieve long data stored in the new current address
000019F8  BA3C 0000                975      CMP.B #$00, D5
000019FC  6700 006C                976      BEQ predec_skip_to_d
00001A00  3C05                     977      MOVE.W D5,D6
00001A02  4281                     978      CLR.L D1
00001A04  123C 0000                979      MOVE.B #0, D1
00001A08                           980  a_loop1
00001A08  E31E                     981      ROL.B #1,D6
00001A0A  6500 0006                982      BCS a_loop1_done
00001A0E  5201                     983      ADD.B #1,D1
00001A10  60F6                     984      BRA a_loop1
00001A12                           985  a_loop1_done
00001A12  43F8 04A2                986      LEA A_reg,A1
00001A16  4EB8 13A0                987      JSR print
00001A1A  103C 0003                988      MOVE.B #3,D0
00001A1E  4E4F                     989      TRAP #15
00001A20  4287                     990      CLR.L D7
00001A22  1E3C 0000                991      MOVE.B #0, D7
00001A26                           992  a_loop2
00001A26  E31E                     993      ROL.B #1,D6
00001A28  6400 0010                994      BCC a_loop2_done
00001A2C  5207                     995      ADD.B #1,D7
00001A2E  5201                     996      ADD.B #1,D1
00001A30  B23C 0007                997      CMP.B #7, D1
00001A34  6700 0004                998      BEQ a_loop2_done
00001A38  60EC                     999      BRA a_loop2
00001A3A                          1000  a_loop2_done
00001A3A  BE3C 0000               1001      CMP.B #0, D7
00001A3E  6700 0018               1002      BEQ predec_no_dash
00001A42  43F8 04B7               1003      LEA dash, A1
00001A46  4EB8 13A0               1004      JSR print
00001A4A  43F8 04A2               1005      LEA A_reg,A1
00001A4E  4EB8 13A0               1006      JSR print
00001A52  103C 0003               1007      MOVE.B #3,D0
00001A56  4E4F                    1008      TRAP #15
00001A58                          1009  predec_no_dash
00001A58  BABC 000000FF           1010      CMP.L #$00FF,D5
00001A5E  6F00 0062               1011      BLE end_movem_predec
00001A62  43F8 04B9               1012      LEA slash, A1
00001A66  4EB8 13A0               1013      JSR print
00001A6A                          1014  predec_skip_to_d    
00001A6A  3C05                    1015      MOVE.W D5,D6
00001A6C  E04E                    1016      LSR.W #8,D6
00001A6E  4281                    1017      CLR.L D1
00001A70  123C 0000               1018      MOVE.B #0, D1
00001A74                          1019  d_loop1
00001A74  E31E                    1020      ROL.B #1,D6
00001A76  6500 0006               1021      BCS d_loop1_done
00001A7A  5201                    1022      ADD.B #1,D1
00001A7C  60F6                    1023      BRA d_loop1
00001A7E                          1024  d_loop1_done
00001A7E  43F8 04A0               1025      LEA D_reg,A1
00001A82  4EB8 13A0               1026      JSR print
00001A86  103C 0003               1027      MOVE.B #3,D0
00001A8A  4E4F                    1028      TRAP #15
00001A8C  4287                    1029      CLR.L D7
00001A8E  1E3C 0000               1030      MOVE.B #0, D7
00001A92                          1031  d_loop2
00001A92  E31E                    1032      ROL.B #1,D6
00001A94  6400 000E               1033      BCC d_loop2_done
00001A98  5201                    1034      ADD.B #1,D1
00001A9A  B23C 0007               1035      CMP.B #7, D1
00001A9E  6700 0004               1036      BEQ d_loop2_done
00001AA2  60EE                    1037      BRA d_loop2
00001AA4                          1038  d_loop2_done
00001AA4  BE3C 0000               1039      CMP.B #0, D7
00001AA8  6F00 0018               1040      BLE end_movem_predec
00001AAC  43F8 04B7               1041      LEA dash, A1
00001AB0  4EB8 13A0               1042      JSR print
00001AB4  43F8 04A0               1043      LEA D_reg,A1
00001AB8  4EB8 13A0               1044      JSR print
00001ABC  103C 0003               1045      MOVE.B #3,D0
00001AC0  4E4F                    1046      TRAP #15
00001AC2                          1047  end_movem_predec
00001AC2  4E75                    1048      RTS
00001AC4                          1049      
00001AC4                          1050  movem_postinc:          *needs to be worked on
00001AC4  4285                    1051      CLR.L D5
00001AC6  544C                    1052      ADDA.W  #2,A4       *update current address
00001AC8  3A14                    1053      MOVE.W (A4),D5      *retrieve long data stored in the new current address
00001ACA  3C05                    1054      MOVE.W D5,D6
00001ACC  E04E                    1055      LSR.W #8,D6
00001ACE  BC3C 0000               1056      CMP.B #$00, D6
00001AD2  6700 0068               1057      BEQ postinc_skip_to_d
00001AD6  4281                    1058      CLR.L D1
00001AD8  123C 0000               1059      MOVE.B #0, D1
00001ADC                          1060  a_loop3
00001ADC  E21E                    1061      ROR.B #1,D6
00001ADE  6500 0006               1062      BCS a_loop3_done
00001AE2  5201                    1063      ADD.B #1,D1
00001AE4  60F6                    1064      BRA a_loop3
00001AE6                          1065  a_loop3_done
00001AE6  43F8 04A2               1066      LEA A_reg,A1
00001AEA  4EB8 13A0               1067      JSR print
00001AEE  103C 0003               1068      MOVE.B #3,D0
00001AF2  4E4F                    1069      TRAP #15
00001AF4  4287                    1070      CLR.L D7
00001AF6  1E3C 0000               1071      MOVE.B #0, D7
00001AFA                          1072  a_loop4
00001AFA  E21E                    1073      ROR.B #1,D6
00001AFC  6400 0010               1074      BCC a_loop4_done
00001B00  5207                    1075      ADD.B #1,D7
00001B02  5201                    1076      ADD.B #1,D1
00001B04  B23C 0007               1077      CMP.B #7, D1
00001B08  6700 0004               1078      BEQ a_loop4_done
00001B0C  60EC                    1079      BRA a_loop4
00001B0E                          1080  a_loop4_done
00001B0E  BE3C 0000               1081      CMP.B #0, D7
00001B12  6700 0018               1082      BEQ postinc_no_dash
00001B16  43F8 04B7               1083      LEA dash, A1
00001B1A  4EB8 13A0               1084      JSR print
00001B1E  43F8 04A2               1085      LEA A_reg,A1
00001B22  4EB8 13A0               1086      JSR print
00001B26  103C 0003               1087      MOVE.B #3,D0
00001B2A  4E4F                    1088      TRAP #15
00001B2C                          1089  postinc_no_dash
00001B2C  BA3C 0000               1090      CMP.B #$00, D5
00001B30  6700 0060               1091      BEQ end_movem_postinc
00001B34  43F8 04B9               1092      LEA slash, A1
00001B38  4EB8 13A0               1093      JSR print
00001B3C                          1094  postinc_skip_to_d   
00001B3C  3C05                    1095      MOVE.W D5,D6
00001B3E  4281                    1096      CLR.L D1
00001B40  123C 0000               1097      MOVE.B #0, D1
00001B44                          1098  d_loop3
00001B44  E21E                    1099      ROR.B #1,D6
00001B46  6500 0006               1100      BCS d_loop3_done
00001B4A  5201                    1101      ADD.B #1,D1
00001B4C  60F6                    1102      BRA d_loop3
00001B4E                          1103  d_loop3_done
00001B4E  43F8 04A0               1104      LEA D_reg,A1
00001B52  4EB8 13A0               1105      JSR print
00001B56  103C 0003               1106      MOVE.B #3,D0
00001B5A  4E4F                    1107      TRAP #15
00001B5C  4287                    1108      CLR.L D7
00001B5E  1E3C 0000               1109      MOVE.B #0, D7
00001B62                          1110  d_loop4
00001B62  E21E                    1111      ROR.B #1,D6
00001B64  6400 000E               1112      BCC d_loop4_done
00001B68  5201                    1113      ADD.B #1,D1
00001B6A  B23C 0007               1114      CMP.B #7, D1
00001B6E  6700 0004               1115      BEQ d_loop4_done
00001B72  60EE                    1116      BRA d_loop4
00001B74                          1117  d_loop4_done
00001B74  BE3C 0000               1118      CMP.B #0, D7
00001B78  6F00 0018               1119      BLE end_movem_postinc
00001B7C  43F8 04B7               1120      LEA dash, A1
00001B80  4EB8 13A0               1121      JSR print
00001B84  43F8 04A0               1122      LEA D_reg,A1
00001B88  4EB8 13A0               1123      JSR print
00001B8C  103C 0003               1124      MOVE.B #3,D0
00001B90  4E4F                    1125      TRAP #15
00001B92                          1126  end_movem_postinc
00001B92  4E75                    1127      RTS
00001B94                          1128  
00001B94                          1129  
00001B94                          1130  * ------- End Effective Address -------*
00001B94                          1131  
00001B94                          1132  * ----- Hex to ASCII & ASCII to HEX -----*
00001B94                          1133  
00001B94                          1134  ASCIItoHex:
00001B94  4EB9 00001BA2           1135          jsr     ASCII2Hex_init  
00001B9A  4EB9 00001BA8           1136          jsr     conversion_loop
00001BA0  4E75                    1137          rts                    
00001BA2                          1138  
00001BA2                          1139  ASCII2Hex_init:   
00001BA2  143C 0000               1140          move.b  #0,D2       *set up counter    
00001BA6  4E75                    1141          rts         
00001BA8                          1142          
00001BA8                          1143  conversion_loop:            
00001BA8  5282                    1144          add.l   #1,D2       *increment counter
00001BAA  B4BC 00000009           1145          cmp.l   #9,D2       *ends at 9
00001BB0  6700 004A               1146          BEQ     DONE        *branch when compare is true
00001BB4  1819                    1147          move.b  (A1)+,D4    *Get first num
00001BB6                          1148          
00001BB6  B83C 0040               1149          cmp.b   #$40,D4        
00001BBA  6E00 000C               1150          bgt     Letters_Cap  
00001BBE                          1151          
00001BBE  B83C 0039               1152          cmp.b   #$39,D4
00001BC2  6F00 0016               1153          BLE     Numbers      
00001BC6  4E75                    1154          rts
00001BC8                          1155          
00001BC8                          1156  Letters_Cap:      
00001BC8  B83C 0046               1157          cmp.b   #$46,D4          
00001BCC  6E00 001E               1158          bgt     ERROR  
00001BD0  0404 0037               1159          sub.b   #$37,D4     
00001BD4  E986                    1160          asl.l   #4,D6       
00001BD6  DC84                    1161          add.l   D4,D6     
00001BD8  60CE                    1162          bra     conversion_loop 
00001BDA                          1163  Numbers:
00001BDA  B83C 0030               1164          cmp.b   #$30,D4         
00001BDE  6D00 000C               1165          blt     ERROR        
00001BE2  0404 0030               1166          sub.b   #$30,D4      
00001BE6  E986                    1167          asl.l   #4,D6        
00001BE8  DC84                    1168          add.l   D4,D6     
00001BEA  60BC                    1169          bra     conversion_loop
00001BEC                          1170          
00001BEC                          1171  ERROR:
00001BEC  43F8 011E               1172          lea     ErrorMsg,A1    
00001BF0  103C 000E               1173          move.b  #14,D0
00001BF4  4E4F                    1174          trap    #15
00001BF6                          1175      
00001BF6  103C 0009               1176          move.b  #9,D0
00001BFA  4E4F                    1177          trap    #15
00001BFC                          1178          
00001BFC                          1179  DONE:
00001BFC                          1180     
00001BFC  4241                    1181          clr     D1
00001BFE  4242                    1182          clr     D2
00001C00  4244                    1183          clr     D4
00001C02                          1184      
00001C02  43F8 014F               1185          lea     ASCIItoHexMsg,A1
00001C06  103C 000E               1186          move.b  #14,D0
00001C0A  4E4F                    1187          trap    #15
00001C0C                          1188  
00001C0C  4E75                    1189          rts
00001C0E                          1190          
00001C0E                          1191  
00001C0E                          1192          
00001C0E                          1193  * -- End of Hex to ASCII & ASCII to HEX --*
00001C0E                          1194  
00001C0E                          1195  * Put program code here
00001C0E                          1196  
00001C0E  FFFF FFFF               1197      SIMHALT             ; halt simulator
00001C12                          1198  
00001C12                          1199  * Put variables and constants here
00001C12                          1200  
00001C12                          1201      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_OR_IMMEDIATE  1920
ADDA_INS            45B
ADDA_SIZE           149A
ADDQ_INS            460
ADDR                1842
ADD_A               1478
ADD_INDIRECT        18C0
ADD_INS             457
ADD_REG             18A8
ADD_REG_SR          19DA
ANDQ_INS            487
AND_INS             468
ASCII2HEX_INIT      1BA2
ASCIITOHEX          1B94
ASCIITOHEXMSG       14F
AS_INS              473
A_LOOP1             1A08
A_LOOP1_DONE        1A12
A_LOOP2             1A26
A_LOOP2_DONE        1A3A
A_LOOP3             1ADC
A_LOOP3_DONE        1AE6
A_LOOP4             1AFA
A_LOOP4_DONE        1B0E
A_REG               4A2
BEQ_INS             494
BGT_INS             48C
BLE_INS             490
BRA_INS             498
BYTE                433
CHECKADDRESS        11DE
CHECK_WORD          16F6
CLEAR_REGISTERS     1150
CLOSE_PARAN         4A7
COMMA               4B2
CONT                184E
CONTINUEORNOTMSG    1CC
CONTINUE_INSTRUCTION_LS_AS_RO  1584
CONVERSION_LOOP     1BA8
CR                  D
CREATORS            1F
DASH                4B7
DATA                4BE
DATA_REG            1890
DATA_REG_SR         19C2
DESTINATION         1886
DOLLAR              4C5
DONE                1BFC
D_LOOP1             1A74
D_LOOP1_DONE        1A7E
D_LOOP2             1A92
D_LOOP2_DONE        1AA4
D_LOOP3             1B44
D_LOOP3_DONE        1B4E
D_LOOP4             1B62
D_LOOP4_DONE        1B74
D_REG               4A0
EA_DEST_ADD         145E
EA_DEST_SUB_AND_OR  1512
ENDADDRESSINC       E4
ENDOFMEMLOOP        173
END_ADD             14B6
END_ADDR_BUFFER     32B
END_BRA_BCC         1718
END_MOVEM           1784
END_MOVEM_POSTINC   1B92
END_MOVEM_PREDEC    1AC2
ENTER               13B2
ERROR               1BEC
ERRORMSG            11E
EXITMSG             1EF
FLUSHSCREEN_CHECK   1236
FLUSHSCREEN_CLEARSCREEN  1290
FLUSHSCREEN_FLUSH   1240
FLUSHSCREEN_PROCESSREPLY  1266
FLUSHSCREEN_PROCESSREPLYGOOD  128E
FLUSHSCREEN_TOFLUSH  12AC
FLUSH_MESSAGE       1FF
GETENDADDRESS       11C4
GETSTARTADDRESS     11AA
HELPMSG             190
HEXTOASCIIMSG       12D
IMMEDIATE           193E
IMM_COMPLETE        1978
INPUTISINC          C7
INPUTMSG1           4E
INPUTMSG2           8F
INVALID             1346
JSR_INS             47D
LEA_INS             482
LEFT                49E
LETTERS_CAP         1BC8
LF                  A
LONG                42B
LS_AS_RO_MEM        159A
LS_AS_RO_REG        157C
LS_INS              470
L_IMM               1998
MEMSEARCH           11E2
MEMSEARCHLOOP       11EA
MEMSEARCH_DONE      121E
MEM_TO_REG          1770
MENU                118C
MOVEA_INS           451
MOVEM_DIRECTION     174A
MOVEM_INS           44B
MOVEM_LONG          1742
MOVEM_POSTINC       1AC4
MOVEM_PREDEC        19F2
MOVEQ_INS           444
MOVE_A              13EA
MOVE_INS            43F
MOVE_MOVEA          1960
MOVE_SIZE           17E0
M_SIZE              13F2
NEXT_ADD            14A2
NEXT_BRA_BCC        16C4
NEXT_LS_AS_RO       15C8
NOP_INS             437
NOT_INS             479
NUMBERS             1BDA
OPCODE_DECODE       12AE
OPEN_PARAN          4A4
OR_INS              465
OUT                 1362
POSTINC_NO_DASH     1B2C
POSTINC_SKIP_TO_D   1B3C
POST_INC            4A9
POST_INCREMENT      18E0
POUND               4B5
PREDEC_NO_DASH      1A58
PREDEC_SKIP_TO_D    1A6A
PRE_DEC             4AC
PRE_DECREMENT       1900
PRINT               13A0
PRINTLN             13AA
PRINT_ADDQ          1634
PRINT_ADD_ADDA      141A
PRINT_AS            17CE
PRINT_B             1802
PRINT_BEQ           16A4
PRINT_BGT           16BC
PRINT_BLE           16B0
PRINT_BRA           1698
PRINT_BRA_BCC       166E
PRINT_CORRECT_SHIFT_ROTATION  17AE
PRINT_DIRECTION     178C
PRINT_INSTRUCTION   14E2
PRINT_IT            17DA
PRINT_JSR           15FA
PRINT_L             181A
PRINT_LEA           1610
PRINT_LEFT          17A4
PRINT_LS            17D6
PRINT_LS_AS_RO      1530
PRINT_MOVEM         1720
PRINT_MOVEQ         1364
PRINT_MOVE_MOVEA    13D0
PRINT_NOP           13BC
PRINT_NOT           15D0
PRINT_OR            14DE
PRINT_RTS           13C6
PRINT_SUB           14D6
PRINT_SUB_AND_OR    14BE
PRINT_W             180E
RETURN              4BB
RIGHT               49C
RO_INS              476
RTS_INS             43B
SIZE                1826
SLASH               4B9
SPACE               4B0
START               1000
STARTINGMSG         0
START_ADDR_BUFFER   22B
SUB_INS             46C
TAB                 9
TERMINATEORCONT     122A
WORD                42F
W_IMM               197C
XN                  19B6
